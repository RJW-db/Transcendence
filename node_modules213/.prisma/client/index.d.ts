
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model BlockedUser
 * 
 */
export type BlockedUser = $Result.DefaultSelection<Prisma.$BlockedUserPayload>
/**
 * Model Friend
 * 
 */
export type Friend = $Result.DefaultSelection<Prisma.$FriendPayload>
/**
 * Model Invitation
 * 
 */
export type Invitation = $Result.DefaultSelection<Prisma.$InvitationPayload>
/**
 * Model Log
 * 
 */
export type Log = $Result.DefaultSelection<Prisma.$LogPayload>
/**
 * Model Match
 * 
 */
export type Match = $Result.DefaultSelection<Prisma.$MatchPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Tournament
 * 
 */
export type Tournament = $Result.DefaultSelection<Prisma.$TournamentPayload>
/**
 * Model TournamentMatch
 * 
 */
export type TournamentMatch = $Result.DefaultSelection<Prisma.$TournamentMatchPayload>
/**
 * Model TournamentUser
 * 
 */
export type TournamentUser = $Result.DefaultSelection<Prisma.$TournamentUserPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blockedUser`: Exposes CRUD operations for the **BlockedUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlockedUsers
    * const blockedUsers = await prisma.blockedUser.findMany()
    * ```
    */
  get blockedUser(): Prisma.BlockedUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.friend`: Exposes CRUD operations for the **Friend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Friends
    * const friends = await prisma.friend.findMany()
    * ```
    */
  get friend(): Prisma.FriendDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invitation`: Exposes CRUD operations for the **Invitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invitations
    * const invitations = await prisma.invitation.findMany()
    * ```
    */
  get invitation(): Prisma.InvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **Log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.LogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.match`: Exposes CRUD operations for the **Match** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Matches
    * const matches = await prisma.match.findMany()
    * ```
    */
  get match(): Prisma.MatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournament`: Exposes CRUD operations for the **Tournament** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tournaments
    * const tournaments = await prisma.tournament.findMany()
    * ```
    */
  get tournament(): Prisma.TournamentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournamentMatch`: Exposes CRUD operations for the **TournamentMatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentMatches
    * const tournamentMatches = await prisma.tournamentMatch.findMany()
    * ```
    */
  get tournamentMatch(): Prisma.TournamentMatchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tournamentUser`: Exposes CRUD operations for the **TournamentUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TournamentUsers
    * const tournamentUsers = await prisma.tournamentUser.findMany()
    * ```
    */
  get tournamentUser(): Prisma.TournamentUserDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    BlockedUser: 'BlockedUser',
    Friend: 'Friend',
    Invitation: 'Invitation',
    Log: 'Log',
    Match: 'Match',
    Message: 'Message',
    Tournament: 'Tournament',
    TournamentMatch: 'TournamentMatch',
    TournamentUser: 'TournamentUser'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "blockedUser" | "friend" | "invitation" | "log" | "match" | "message" | "tournament" | "tournamentMatch" | "tournamentUser"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      BlockedUser: {
        payload: Prisma.$BlockedUserPayload<ExtArgs>
        fields: Prisma.BlockedUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlockedUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlockedUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findFirst: {
            args: Prisma.BlockedUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlockedUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          findMany: {
            args: Prisma.BlockedUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          create: {
            args: Prisma.BlockedUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          createMany: {
            args: Prisma.BlockedUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlockedUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          delete: {
            args: Prisma.BlockedUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          update: {
            args: Prisma.BlockedUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          deleteMany: {
            args: Prisma.BlockedUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlockedUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlockedUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>[]
          }
          upsert: {
            args: Prisma.BlockedUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlockedUserPayload>
          }
          aggregate: {
            args: Prisma.BlockedUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlockedUser>
          }
          groupBy: {
            args: Prisma.BlockedUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlockedUserCountArgs<ExtArgs>
            result: $Utils.Optional<BlockedUserCountAggregateOutputType> | number
          }
        }
      }
      Friend: {
        payload: Prisma.$FriendPayload<ExtArgs>
        fields: Prisma.FriendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FriendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FriendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload>
          }
          findFirst: {
            args: Prisma.FriendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FriendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload>
          }
          findMany: {
            args: Prisma.FriendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload>[]
          }
          create: {
            args: Prisma.FriendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload>
          }
          createMany: {
            args: Prisma.FriendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FriendCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload>[]
          }
          delete: {
            args: Prisma.FriendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload>
          }
          update: {
            args: Prisma.FriendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload>
          }
          deleteMany: {
            args: Prisma.FriendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FriendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FriendUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload>[]
          }
          upsert: {
            args: Prisma.FriendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FriendPayload>
          }
          aggregate: {
            args: Prisma.FriendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFriend>
          }
          groupBy: {
            args: Prisma.FriendGroupByArgs<ExtArgs>
            result: $Utils.Optional<FriendGroupByOutputType>[]
          }
          count: {
            args: Prisma.FriendCountArgs<ExtArgs>
            result: $Utils.Optional<FriendCountAggregateOutputType> | number
          }
        }
      }
      Invitation: {
        payload: Prisma.$InvitationPayload<ExtArgs>
        fields: Prisma.InvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findFirst: {
            args: Prisma.InvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          findMany: {
            args: Prisma.InvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          create: {
            args: Prisma.InvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          createMany: {
            args: Prisma.InvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          delete: {
            args: Prisma.InvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          update: {
            args: Prisma.InvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          deleteMany: {
            args: Prisma.InvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>[]
          }
          upsert: {
            args: Prisma.InvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvitationPayload>
          }
          aggregate: {
            args: Prisma.InvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvitation>
          }
          groupBy: {
            args: Prisma.InvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvitationCountArgs<ExtArgs>
            result: $Utils.Optional<InvitationCountAggregateOutputType> | number
          }
        }
      }
      Log: {
        payload: Prisma.$LogPayload<ExtArgs>
        fields: Prisma.LogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findFirst: {
            args: Prisma.LogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          findMany: {
            args: Prisma.LogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          create: {
            args: Prisma.LogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          createMany: {
            args: Prisma.LogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          delete: {
            args: Prisma.LogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          update: {
            args: Prisma.LogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          deleteMany: {
            args: Prisma.LogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>[]
          }
          upsert: {
            args: Prisma.LogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogPayload>
          }
          aggregate: {
            args: Prisma.LogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLog>
          }
          groupBy: {
            args: Prisma.LogGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogCountArgs<ExtArgs>
            result: $Utils.Optional<LogCountAggregateOutputType> | number
          }
        }
      }
      Match: {
        payload: Prisma.$MatchPayload<ExtArgs>
        fields: Prisma.MatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findFirst: {
            args: Prisma.MatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          findMany: {
            args: Prisma.MatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          create: {
            args: Prisma.MatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          createMany: {
            args: Prisma.MatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          delete: {
            args: Prisma.MatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          update: {
            args: Prisma.MatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          deleteMany: {
            args: Prisma.MatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>[]
          }
          upsert: {
            args: Prisma.MatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MatchPayload>
          }
          aggregate: {
            args: Prisma.MatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMatch>
          }
          groupBy: {
            args: Prisma.MatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<MatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.MatchCountArgs<ExtArgs>
            result: $Utils.Optional<MatchCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Tournament: {
        payload: Prisma.$TournamentPayload<ExtArgs>
        fields: Prisma.TournamentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findFirst: {
            args: Prisma.TournamentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          findMany: {
            args: Prisma.TournamentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          create: {
            args: Prisma.TournamentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          createMany: {
            args: Prisma.TournamentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          delete: {
            args: Prisma.TournamentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          update: {
            args: Prisma.TournamentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          deleteMany: {
            args: Prisma.TournamentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TournamentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>[]
          }
          upsert: {
            args: Prisma.TournamentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentPayload>
          }
          aggregate: {
            args: Prisma.TournamentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournament>
          }
          groupBy: {
            args: Prisma.TournamentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentCountAggregateOutputType> | number
          }
        }
      }
      TournamentMatch: {
        payload: Prisma.$TournamentMatchPayload<ExtArgs>
        fields: Prisma.TournamentMatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentMatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentMatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload>
          }
          findFirst: {
            args: Prisma.TournamentMatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentMatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload>
          }
          findMany: {
            args: Prisma.TournamentMatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload>[]
          }
          create: {
            args: Prisma.TournamentMatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload>
          }
          createMany: {
            args: Prisma.TournamentMatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentMatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload>[]
          }
          delete: {
            args: Prisma.TournamentMatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload>
          }
          update: {
            args: Prisma.TournamentMatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload>
          }
          deleteMany: {
            args: Prisma.TournamentMatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentMatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TournamentMatchUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload>[]
          }
          upsert: {
            args: Prisma.TournamentMatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentMatchPayload>
          }
          aggregate: {
            args: Prisma.TournamentMatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamentMatch>
          }
          groupBy: {
            args: Prisma.TournamentMatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentMatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentMatchCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentMatchCountAggregateOutputType> | number
          }
        }
      }
      TournamentUser: {
        payload: Prisma.$TournamentUserPayload<ExtArgs>
        fields: Prisma.TournamentUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TournamentUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TournamentUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload>
          }
          findFirst: {
            args: Prisma.TournamentUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TournamentUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload>
          }
          findMany: {
            args: Prisma.TournamentUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload>[]
          }
          create: {
            args: Prisma.TournamentUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload>
          }
          createMany: {
            args: Prisma.TournamentUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TournamentUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload>[]
          }
          delete: {
            args: Prisma.TournamentUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload>
          }
          update: {
            args: Prisma.TournamentUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload>
          }
          deleteMany: {
            args: Prisma.TournamentUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TournamentUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TournamentUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload>[]
          }
          upsert: {
            args: Prisma.TournamentUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TournamentUserPayload>
          }
          aggregate: {
            args: Prisma.TournamentUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTournamentUser>
          }
          groupBy: {
            args: Prisma.TournamentUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<TournamentUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.TournamentUserCountArgs<ExtArgs>
            result: $Utils.Optional<TournamentUserCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    blockedUser?: BlockedUserOmit
    friend?: FriendOmit
    invitation?: InvitationOmit
    log?: LogOmit
    match?: MatchOmit
    message?: MessageOmit
    tournament?: TournamentOmit
    tournamentMatch?: TournamentMatchOmit
    tournamentUser?: TournamentUserOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    BlockedBy: number
    Blocked: number
    Friends1: number
    Friends2: number
    InvitationsSent: number
    InvitationsReceived: number
    matchesAsPlayer1: number
    matchesAsPlayer2: number
    matchesAsWinner: number
    MessagesSent: number
    MessagesReceived: number
    TournamentUsers: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlockedBy?: boolean | UserCountOutputTypeCountBlockedByArgs
    Blocked?: boolean | UserCountOutputTypeCountBlockedArgs
    Friends1?: boolean | UserCountOutputTypeCountFriends1Args
    Friends2?: boolean | UserCountOutputTypeCountFriends2Args
    InvitationsSent?: boolean | UserCountOutputTypeCountInvitationsSentArgs
    InvitationsReceived?: boolean | UserCountOutputTypeCountInvitationsReceivedArgs
    matchesAsPlayer1?: boolean | UserCountOutputTypeCountMatchesAsPlayer1Args
    matchesAsPlayer2?: boolean | UserCountOutputTypeCountMatchesAsPlayer2Args
    matchesAsWinner?: boolean | UserCountOutputTypeCountMatchesAsWinnerArgs
    MessagesSent?: boolean | UserCountOutputTypeCountMessagesSentArgs
    MessagesReceived?: boolean | UserCountOutputTypeCountMessagesReceivedArgs
    TournamentUsers?: boolean | UserCountOutputTypeCountTournamentUsersArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBlockedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriends1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFriends2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchesAsPlayer1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchesAsPlayer2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMatchesAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTournamentUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentUserWhereInput
  }


  /**
   * Count Type MatchCountOutputType
   */

  export type MatchCountOutputType = {
    Invitations: number
  }

  export type MatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Invitations?: boolean | MatchCountOutputTypeCountInvitationsArgs
  }

  // Custom InputTypes
  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MatchCountOutputType
     */
    select?: MatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MatchCountOutputType without action
   */
  export type MatchCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
  }


  /**
   * Count Type TournamentCountOutputType
   */

  export type TournamentCountOutputType = {
    Matches: number
    Users: number
    TournamentUsers: number
  }

  export type TournamentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Matches?: boolean | TournamentCountOutputTypeCountMatchesArgs
    Users?: boolean | TournamentCountOutputTypeCountUsersArgs
    TournamentUsers?: boolean | TournamentCountOutputTypeCountTournamentUsersArgs
  }

  // Custom InputTypes
  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentCountOutputType
     */
    select?: TournamentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountMatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentMatchWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentUserWhereInput
  }

  /**
   * TournamentCountOutputType without action
   */
  export type TournamentCountOutputTypeCountTournamentUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentUserWhereInput
  }


  /**
   * Count Type TournamentUserCountOutputType
   */

  export type TournamentUserCountOutputType = {
    matchesAsPlayer1: number
    matchesAsPlayer2: number
    matchesAsWinner: number
    tournaments: number
    tournamentsAsWinner: number
  }

  export type TournamentUserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    matchesAsPlayer1?: boolean | TournamentUserCountOutputTypeCountMatchesAsPlayer1Args
    matchesAsPlayer2?: boolean | TournamentUserCountOutputTypeCountMatchesAsPlayer2Args
    matchesAsWinner?: boolean | TournamentUserCountOutputTypeCountMatchesAsWinnerArgs
    tournaments?: boolean | TournamentUserCountOutputTypeCountTournamentsArgs
    tournamentsAsWinner?: boolean | TournamentUserCountOutputTypeCountTournamentsAsWinnerArgs
  }

  // Custom InputTypes
  /**
   * TournamentUserCountOutputType without action
   */
  export type TournamentUserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUserCountOutputType
     */
    select?: TournamentUserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TournamentUserCountOutputType without action
   */
  export type TournamentUserCountOutputTypeCountMatchesAsPlayer1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentMatchWhereInput
  }

  /**
   * TournamentUserCountOutputType without action
   */
  export type TournamentUserCountOutputTypeCountMatchesAsPlayer2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentMatchWhereInput
  }

  /**
   * TournamentUserCountOutputType without action
   */
  export type TournamentUserCountOutputTypeCountMatchesAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentMatchWhereInput
  }

  /**
   * TournamentUserCountOutputType without action
   */
  export type TournamentUserCountOutputTypeCountTournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentWhereInput
  }

  /**
   * TournamentUserCountOutputType without action
   */
  export type TournamentUserCountOutputTypeCountTournamentsAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    ID: number | null
    GamesWon: number | null
  }

  export type UserSumAggregateOutputType = {
    ID: number | null
    GamesWon: number | null
  }

  export type UserMinAggregateOutputType = {
    ID: number | null
    Alias: string | null
    Email: string | null
    Password: string | null
    Online: boolean | null
    CreationDate: Date | null
    GamesWon: number | null
    ProfilePicture: Bytes | null
  }

  export type UserMaxAggregateOutputType = {
    ID: number | null
    Alias: string | null
    Email: string | null
    Password: string | null
    Online: boolean | null
    CreationDate: Date | null
    GamesWon: number | null
    ProfilePicture: Bytes | null
  }

  export type UserCountAggregateOutputType = {
    ID: number
    Alias: number
    Email: number
    Password: number
    Online: number
    CreationDate: number
    GamesWon: number
    ProfilePicture: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    ID?: true
    GamesWon?: true
  }

  export type UserSumAggregateInputType = {
    ID?: true
    GamesWon?: true
  }

  export type UserMinAggregateInputType = {
    ID?: true
    Alias?: true
    Email?: true
    Password?: true
    Online?: true
    CreationDate?: true
    GamesWon?: true
    ProfilePicture?: true
  }

  export type UserMaxAggregateInputType = {
    ID?: true
    Alias?: true
    Email?: true
    Password?: true
    Online?: true
    CreationDate?: true
    GamesWon?: true
    ProfilePicture?: true
  }

  export type UserCountAggregateInputType = {
    ID?: true
    Alias?: true
    Email?: true
    Password?: true
    Online?: true
    CreationDate?: true
    GamesWon?: true
    ProfilePicture?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    ID: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date
    GamesWon: number
    ProfilePicture: Bytes | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Alias?: boolean
    Email?: boolean
    Password?: boolean
    Online?: boolean
    CreationDate?: boolean
    GamesWon?: boolean
    ProfilePicture?: boolean
    BlockedBy?: boolean | User$BlockedByArgs<ExtArgs>
    Blocked?: boolean | User$BlockedArgs<ExtArgs>
    Friends1?: boolean | User$Friends1Args<ExtArgs>
    Friends2?: boolean | User$Friends2Args<ExtArgs>
    InvitationsSent?: boolean | User$InvitationsSentArgs<ExtArgs>
    InvitationsReceived?: boolean | User$InvitationsReceivedArgs<ExtArgs>
    matchesAsPlayer1?: boolean | User$matchesAsPlayer1Args<ExtArgs>
    matchesAsPlayer2?: boolean | User$matchesAsPlayer2Args<ExtArgs>
    matchesAsWinner?: boolean | User$matchesAsWinnerArgs<ExtArgs>
    MessagesSent?: boolean | User$MessagesSentArgs<ExtArgs>
    MessagesReceived?: boolean | User$MessagesReceivedArgs<ExtArgs>
    TournamentUsers?: boolean | User$TournamentUsersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Alias?: boolean
    Email?: boolean
    Password?: boolean
    Online?: boolean
    CreationDate?: boolean
    GamesWon?: boolean
    ProfilePicture?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Alias?: boolean
    Email?: boolean
    Password?: boolean
    Online?: boolean
    CreationDate?: boolean
    GamesWon?: boolean
    ProfilePicture?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    ID?: boolean
    Alias?: boolean
    Email?: boolean
    Password?: boolean
    Online?: boolean
    CreationDate?: boolean
    GamesWon?: boolean
    ProfilePicture?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Alias" | "Email" | "Password" | "Online" | "CreationDate" | "GamesWon" | "ProfilePicture", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    BlockedBy?: boolean | User$BlockedByArgs<ExtArgs>
    Blocked?: boolean | User$BlockedArgs<ExtArgs>
    Friends1?: boolean | User$Friends1Args<ExtArgs>
    Friends2?: boolean | User$Friends2Args<ExtArgs>
    InvitationsSent?: boolean | User$InvitationsSentArgs<ExtArgs>
    InvitationsReceived?: boolean | User$InvitationsReceivedArgs<ExtArgs>
    matchesAsPlayer1?: boolean | User$matchesAsPlayer1Args<ExtArgs>
    matchesAsPlayer2?: boolean | User$matchesAsPlayer2Args<ExtArgs>
    matchesAsWinner?: boolean | User$matchesAsWinnerArgs<ExtArgs>
    MessagesSent?: boolean | User$MessagesSentArgs<ExtArgs>
    MessagesReceived?: boolean | User$MessagesReceivedArgs<ExtArgs>
    TournamentUsers?: boolean | User$TournamentUsersArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      BlockedBy: Prisma.$BlockedUserPayload<ExtArgs>[]
      Blocked: Prisma.$BlockedUserPayload<ExtArgs>[]
      Friends1: Prisma.$FriendPayload<ExtArgs>[]
      Friends2: Prisma.$FriendPayload<ExtArgs>[]
      InvitationsSent: Prisma.$InvitationPayload<ExtArgs>[]
      InvitationsReceived: Prisma.$InvitationPayload<ExtArgs>[]
      matchesAsPlayer1: Prisma.$MatchPayload<ExtArgs>[]
      matchesAsPlayer2: Prisma.$MatchPayload<ExtArgs>[]
      matchesAsWinner: Prisma.$MatchPayload<ExtArgs>[]
      MessagesSent: Prisma.$MessagePayload<ExtArgs>[]
      MessagesReceived: Prisma.$MessagePayload<ExtArgs>[]
      TournamentUsers: Prisma.$TournamentUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Alias: string
      Email: string
      Password: string
      Online: boolean
      CreationDate: Date
      GamesWon: number
      ProfilePicture: Prisma.Bytes | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const userWithIDOnly = await prisma.user.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `ID`
     * const userWithIDOnly = await prisma.user.createManyAndReturn({
     *   select: { ID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `ID`
     * const userWithIDOnly = await prisma.user.updateManyAndReturn({
     *   select: { ID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    BlockedBy<T extends User$BlockedByArgs<ExtArgs> = {}>(args?: Subset<T, User$BlockedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Blocked<T extends User$BlockedArgs<ExtArgs> = {}>(args?: Subset<T, User$BlockedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Friends1<T extends User$Friends1Args<ExtArgs> = {}>(args?: Subset<T, User$Friends1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Friends2<T extends User$Friends2Args<ExtArgs> = {}>(args?: Subset<T, User$Friends2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    InvitationsSent<T extends User$InvitationsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$InvitationsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    InvitationsReceived<T extends User$InvitationsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$InvitationsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchesAsPlayer1<T extends User$matchesAsPlayer1Args<ExtArgs> = {}>(args?: Subset<T, User$matchesAsPlayer1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchesAsPlayer2<T extends User$matchesAsPlayer2Args<ExtArgs> = {}>(args?: Subset<T, User$matchesAsPlayer2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchesAsWinner<T extends User$matchesAsWinnerArgs<ExtArgs> = {}>(args?: Subset<T, User$matchesAsWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MessagesSent<T extends User$MessagesSentArgs<ExtArgs> = {}>(args?: Subset<T, User$MessagesSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    MessagesReceived<T extends User$MessagesReceivedArgs<ExtArgs> = {}>(args?: Subset<T, User$MessagesReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TournamentUsers<T extends User$TournamentUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$TournamentUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly ID: FieldRef<"User", 'Int'>
    readonly Alias: FieldRef<"User", 'String'>
    readonly Email: FieldRef<"User", 'String'>
    readonly Password: FieldRef<"User", 'String'>
    readonly Online: FieldRef<"User", 'Boolean'>
    readonly CreationDate: FieldRef<"User", 'DateTime'>
    readonly GamesWon: FieldRef<"User", 'Int'>
    readonly ProfilePicture: FieldRef<"User", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.BlockedBy
   */
  export type User$BlockedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    cursor?: BlockedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * User.Blocked
   */
  export type User$BlockedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    cursor?: BlockedUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * User.Friends1
   */
  export type User$Friends1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    where?: FriendWhereInput
    orderBy?: FriendOrderByWithRelationInput | FriendOrderByWithRelationInput[]
    cursor?: FriendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendScalarFieldEnum | FriendScalarFieldEnum[]
  }

  /**
   * User.Friends2
   */
  export type User$Friends2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    where?: FriendWhereInput
    orderBy?: FriendOrderByWithRelationInput | FriendOrderByWithRelationInput[]
    cursor?: FriendWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FriendScalarFieldEnum | FriendScalarFieldEnum[]
  }

  /**
   * User.InvitationsSent
   */
  export type User$InvitationsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User.InvitationsReceived
   */
  export type User$InvitationsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * User.matchesAsPlayer1
   */
  export type User$matchesAsPlayer1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * User.matchesAsPlayer2
   */
  export type User$matchesAsPlayer2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * User.matchesAsWinner
   */
  export type User$matchesAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    cursor?: MatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * User.MessagesSent
   */
  export type User$MessagesSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.MessagesReceived
   */
  export type User$MessagesReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.TournamentUsers
   */
  export type User$TournamentUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    where?: TournamentUserWhereInput
    orderBy?: TournamentUserOrderByWithRelationInput | TournamentUserOrderByWithRelationInput[]
    cursor?: TournamentUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentUserScalarFieldEnum | TournamentUserScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model BlockedUser
   */

  export type AggregateBlockedUser = {
    _count: BlockedUserCountAggregateOutputType | null
    _avg: BlockedUserAvgAggregateOutputType | null
    _sum: BlockedUserSumAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  export type BlockedUserAvgAggregateOutputType = {
    ID: number | null
    BlockerID: number | null
    BlockedID: number | null
  }

  export type BlockedUserSumAggregateOutputType = {
    ID: number | null
    BlockerID: number | null
    BlockedID: number | null
  }

  export type BlockedUserMinAggregateOutputType = {
    ID: number | null
    BlockerID: number | null
    BlockedID: number | null
    BlockedDate: Date | null
  }

  export type BlockedUserMaxAggregateOutputType = {
    ID: number | null
    BlockerID: number | null
    BlockedID: number | null
    BlockedDate: Date | null
  }

  export type BlockedUserCountAggregateOutputType = {
    ID: number
    BlockerID: number
    BlockedID: number
    BlockedDate: number
    _all: number
  }


  export type BlockedUserAvgAggregateInputType = {
    ID?: true
    BlockerID?: true
    BlockedID?: true
  }

  export type BlockedUserSumAggregateInputType = {
    ID?: true
    BlockerID?: true
    BlockedID?: true
  }

  export type BlockedUserMinAggregateInputType = {
    ID?: true
    BlockerID?: true
    BlockedID?: true
    BlockedDate?: true
  }

  export type BlockedUserMaxAggregateInputType = {
    ID?: true
    BlockerID?: true
    BlockedID?: true
    BlockedDate?: true
  }

  export type BlockedUserCountAggregateInputType = {
    ID?: true
    BlockerID?: true
    BlockedID?: true
    BlockedDate?: true
    _all?: true
  }

  export type BlockedUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUser to aggregate.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlockedUsers
    **/
    _count?: true | BlockedUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlockedUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlockedUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlockedUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlockedUserMaxAggregateInputType
  }

  export type GetBlockedUserAggregateType<T extends BlockedUserAggregateArgs> = {
        [P in keyof T & keyof AggregateBlockedUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlockedUser[P]>
      : GetScalarType<T[P], AggregateBlockedUser[P]>
  }




  export type BlockedUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlockedUserWhereInput
    orderBy?: BlockedUserOrderByWithAggregationInput | BlockedUserOrderByWithAggregationInput[]
    by: BlockedUserScalarFieldEnum[] | BlockedUserScalarFieldEnum
    having?: BlockedUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlockedUserCountAggregateInputType | true
    _avg?: BlockedUserAvgAggregateInputType
    _sum?: BlockedUserSumAggregateInputType
    _min?: BlockedUserMinAggregateInputType
    _max?: BlockedUserMaxAggregateInputType
  }

  export type BlockedUserGroupByOutputType = {
    ID: number
    BlockerID: number
    BlockedID: number
    BlockedDate: Date
    _count: BlockedUserCountAggregateOutputType | null
    _avg: BlockedUserAvgAggregateOutputType | null
    _sum: BlockedUserSumAggregateOutputType | null
    _min: BlockedUserMinAggregateOutputType | null
    _max: BlockedUserMaxAggregateOutputType | null
  }

  type GetBlockedUserGroupByPayload<T extends BlockedUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlockedUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlockedUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
            : GetScalarType<T[P], BlockedUserGroupByOutputType[P]>
        }
      >
    >


  export type BlockedUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    BlockerID?: boolean
    BlockedID?: boolean
    BlockedDate?: boolean
    Blocker?: boolean | UserDefaultArgs<ExtArgs>
    Blocked?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    BlockerID?: boolean
    BlockedID?: boolean
    BlockedDate?: boolean
    Blocker?: boolean | UserDefaultArgs<ExtArgs>
    Blocked?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    BlockerID?: boolean
    BlockedID?: boolean
    BlockedDate?: boolean
    Blocker?: boolean | UserDefaultArgs<ExtArgs>
    Blocked?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blockedUser"]>

  export type BlockedUserSelectScalar = {
    ID?: boolean
    BlockerID?: boolean
    BlockedID?: boolean
    BlockedDate?: boolean
  }

  export type BlockedUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "BlockerID" | "BlockedID" | "BlockedDate", ExtArgs["result"]["blockedUser"]>
  export type BlockedUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Blocker?: boolean | UserDefaultArgs<ExtArgs>
    Blocked?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlockedUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Blocker?: boolean | UserDefaultArgs<ExtArgs>
    Blocked?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BlockedUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Blocker?: boolean | UserDefaultArgs<ExtArgs>
    Blocked?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BlockedUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlockedUser"
    objects: {
      Blocker: Prisma.$UserPayload<ExtArgs>
      Blocked: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      BlockerID: number
      BlockedID: number
      BlockedDate: Date
    }, ExtArgs["result"]["blockedUser"]>
    composites: {}
  }

  type BlockedUserGetPayload<S extends boolean | null | undefined | BlockedUserDefaultArgs> = $Result.GetResult<Prisma.$BlockedUserPayload, S>

  type BlockedUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlockedUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlockedUserCountAggregateInputType | true
    }

  export interface BlockedUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlockedUser'], meta: { name: 'BlockedUser' } }
    /**
     * Find zero or one BlockedUser that matches the filter.
     * @param {BlockedUserFindUniqueArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlockedUserFindUniqueArgs>(args: SelectSubset<T, BlockedUserFindUniqueArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlockedUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlockedUserFindUniqueOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlockedUserFindUniqueOrThrowArgs>(args: SelectSubset<T, BlockedUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlockedUserFindFirstArgs>(args?: SelectSubset<T, BlockedUserFindFirstArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlockedUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindFirstOrThrowArgs} args - Arguments to find a BlockedUser
     * @example
     * // Get one BlockedUser
     * const blockedUser = await prisma.blockedUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlockedUserFindFirstOrThrowArgs>(args?: SelectSubset<T, BlockedUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlockedUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany()
     * 
     * // Get first 10 BlockedUsers
     * const blockedUsers = await prisma.blockedUser.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const blockedUserWithIDOnly = await prisma.blockedUser.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends BlockedUserFindManyArgs>(args?: SelectSubset<T, BlockedUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlockedUser.
     * @param {BlockedUserCreateArgs} args - Arguments to create a BlockedUser.
     * @example
     * // Create one BlockedUser
     * const BlockedUser = await prisma.blockedUser.create({
     *   data: {
     *     // ... data to create a BlockedUser
     *   }
     * })
     * 
     */
    create<T extends BlockedUserCreateArgs>(args: SelectSubset<T, BlockedUserCreateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlockedUsers.
     * @param {BlockedUserCreateManyArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlockedUserCreateManyArgs>(args?: SelectSubset<T, BlockedUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlockedUsers and returns the data saved in the database.
     * @param {BlockedUserCreateManyAndReturnArgs} args - Arguments to create many BlockedUsers.
     * @example
     * // Create many BlockedUsers
     * const blockedUser = await prisma.blockedUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlockedUsers and only return the `ID`
     * const blockedUserWithIDOnly = await prisma.blockedUser.createManyAndReturn({
     *   select: { ID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlockedUserCreateManyAndReturnArgs>(args?: SelectSubset<T, BlockedUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlockedUser.
     * @param {BlockedUserDeleteArgs} args - Arguments to delete one BlockedUser.
     * @example
     * // Delete one BlockedUser
     * const BlockedUser = await prisma.blockedUser.delete({
     *   where: {
     *     // ... filter to delete one BlockedUser
     *   }
     * })
     * 
     */
    delete<T extends BlockedUserDeleteArgs>(args: SelectSubset<T, BlockedUserDeleteArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlockedUser.
     * @param {BlockedUserUpdateArgs} args - Arguments to update one BlockedUser.
     * @example
     * // Update one BlockedUser
     * const blockedUser = await prisma.blockedUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlockedUserUpdateArgs>(args: SelectSubset<T, BlockedUserUpdateArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlockedUsers.
     * @param {BlockedUserDeleteManyArgs} args - Arguments to filter BlockedUsers to delete.
     * @example
     * // Delete a few BlockedUsers
     * const { count } = await prisma.blockedUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlockedUserDeleteManyArgs>(args?: SelectSubset<T, BlockedUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlockedUsers
     * const blockedUser = await prisma.blockedUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlockedUserUpdateManyArgs>(args: SelectSubset<T, BlockedUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlockedUsers and returns the data updated in the database.
     * @param {BlockedUserUpdateManyAndReturnArgs} args - Arguments to update many BlockedUsers.
     * @example
     * // Update many BlockedUsers
     * const blockedUser = await prisma.blockedUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlockedUsers and only return the `ID`
     * const blockedUserWithIDOnly = await prisma.blockedUser.updateManyAndReturn({
     *   select: { ID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlockedUserUpdateManyAndReturnArgs>(args: SelectSubset<T, BlockedUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlockedUser.
     * @param {BlockedUserUpsertArgs} args - Arguments to update or create a BlockedUser.
     * @example
     * // Update or create a BlockedUser
     * const blockedUser = await prisma.blockedUser.upsert({
     *   create: {
     *     // ... data to create a BlockedUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlockedUser we want to update
     *   }
     * })
     */
    upsert<T extends BlockedUserUpsertArgs>(args: SelectSubset<T, BlockedUserUpsertArgs<ExtArgs>>): Prisma__BlockedUserClient<$Result.GetResult<Prisma.$BlockedUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlockedUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserCountArgs} args - Arguments to filter BlockedUsers to count.
     * @example
     * // Count the number of BlockedUsers
     * const count = await prisma.blockedUser.count({
     *   where: {
     *     // ... the filter for the BlockedUsers we want to count
     *   }
     * })
    **/
    count<T extends BlockedUserCountArgs>(
      args?: Subset<T, BlockedUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlockedUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlockedUserAggregateArgs>(args: Subset<T, BlockedUserAggregateArgs>): Prisma.PrismaPromise<GetBlockedUserAggregateType<T>>

    /**
     * Group by BlockedUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlockedUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlockedUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlockedUserGroupByArgs['orderBy'] }
        : { orderBy?: BlockedUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlockedUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlockedUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlockedUser model
   */
  readonly fields: BlockedUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlockedUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlockedUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Blocker<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Blocked<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlockedUser model
   */
  interface BlockedUserFieldRefs {
    readonly ID: FieldRef<"BlockedUser", 'Int'>
    readonly BlockerID: FieldRef<"BlockedUser", 'Int'>
    readonly BlockedID: FieldRef<"BlockedUser", 'Int'>
    readonly BlockedDate: FieldRef<"BlockedUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlockedUser findUnique
   */
  export type BlockedUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findUniqueOrThrow
   */
  export type BlockedUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser findFirst
   */
  export type BlockedUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findFirstOrThrow
   */
  export type BlockedUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUser to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlockedUsers.
     */
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser findMany
   */
  export type BlockedUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter, which BlockedUsers to fetch.
     */
    where?: BlockedUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlockedUsers to fetch.
     */
    orderBy?: BlockedUserOrderByWithRelationInput | BlockedUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlockedUsers.
     */
    cursor?: BlockedUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlockedUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlockedUsers.
     */
    skip?: number
    distinct?: BlockedUserScalarFieldEnum | BlockedUserScalarFieldEnum[]
  }

  /**
   * BlockedUser create
   */
  export type BlockedUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The data needed to create a BlockedUser.
     */
    data: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
  }

  /**
   * BlockedUser createMany
   */
  export type BlockedUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
  }

  /**
   * BlockedUser createManyAndReturn
   */
  export type BlockedUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * The data used to create many BlockedUsers.
     */
    data: BlockedUserCreateManyInput | BlockedUserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedUser update
   */
  export type BlockedUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The data needed to update a BlockedUser.
     */
    data: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
    /**
     * Choose, which BlockedUser to update.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser updateMany
   */
  export type BlockedUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlockedUsers.
     */
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUsers to update
     */
    where?: BlockedUserWhereInput
    /**
     * Limit how many BlockedUsers to update.
     */
    limit?: number
  }

  /**
   * BlockedUser updateManyAndReturn
   */
  export type BlockedUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * The data used to update BlockedUsers.
     */
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyInput>
    /**
     * Filter which BlockedUsers to update
     */
    where?: BlockedUserWhereInput
    /**
     * Limit how many BlockedUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlockedUser upsert
   */
  export type BlockedUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * The filter to search for the BlockedUser to update in case it exists.
     */
    where: BlockedUserWhereUniqueInput
    /**
     * In case the BlockedUser found by the `where` argument doesn't exist, create a new BlockedUser with this data.
     */
    create: XOR<BlockedUserCreateInput, BlockedUserUncheckedCreateInput>
    /**
     * In case the BlockedUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlockedUserUpdateInput, BlockedUserUncheckedUpdateInput>
  }

  /**
   * BlockedUser delete
   */
  export type BlockedUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
    /**
     * Filter which BlockedUser to delete.
     */
    where: BlockedUserWhereUniqueInput
  }

  /**
   * BlockedUser deleteMany
   */
  export type BlockedUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlockedUsers to delete
     */
    where?: BlockedUserWhereInput
    /**
     * Limit how many BlockedUsers to delete.
     */
    limit?: number
  }

  /**
   * BlockedUser without action
   */
  export type BlockedUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlockedUser
     */
    select?: BlockedUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlockedUser
     */
    omit?: BlockedUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlockedUserInclude<ExtArgs> | null
  }


  /**
   * Model Friend
   */

  export type AggregateFriend = {
    _count: FriendCountAggregateOutputType | null
    _avg: FriendAvgAggregateOutputType | null
    _sum: FriendSumAggregateOutputType | null
    _min: FriendMinAggregateOutputType | null
    _max: FriendMaxAggregateOutputType | null
  }

  export type FriendAvgAggregateOutputType = {
    ID: number | null
    User1ID: number | null
    User2ID: number | null
  }

  export type FriendSumAggregateOutputType = {
    ID: number | null
    User1ID: number | null
    User2ID: number | null
  }

  export type FriendMinAggregateOutputType = {
    ID: number | null
    User1ID: number | null
    User2ID: number | null
    DateBefriended: Date | null
  }

  export type FriendMaxAggregateOutputType = {
    ID: number | null
    User1ID: number | null
    User2ID: number | null
    DateBefriended: Date | null
  }

  export type FriendCountAggregateOutputType = {
    ID: number
    User1ID: number
    User2ID: number
    DateBefriended: number
    _all: number
  }


  export type FriendAvgAggregateInputType = {
    ID?: true
    User1ID?: true
    User2ID?: true
  }

  export type FriendSumAggregateInputType = {
    ID?: true
    User1ID?: true
    User2ID?: true
  }

  export type FriendMinAggregateInputType = {
    ID?: true
    User1ID?: true
    User2ID?: true
    DateBefriended?: true
  }

  export type FriendMaxAggregateInputType = {
    ID?: true
    User1ID?: true
    User2ID?: true
    DateBefriended?: true
  }

  export type FriendCountAggregateInputType = {
    ID?: true
    User1ID?: true
    User2ID?: true
    DateBefriended?: true
    _all?: true
  }

  export type FriendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friend to aggregate.
     */
    where?: FriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendOrderByWithRelationInput | FriendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Friends
    **/
    _count?: true | FriendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FriendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FriendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FriendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FriendMaxAggregateInputType
  }

  export type GetFriendAggregateType<T extends FriendAggregateArgs> = {
        [P in keyof T & keyof AggregateFriend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFriend[P]>
      : GetScalarType<T[P], AggregateFriend[P]>
  }




  export type FriendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FriendWhereInput
    orderBy?: FriendOrderByWithAggregationInput | FriendOrderByWithAggregationInput[]
    by: FriendScalarFieldEnum[] | FriendScalarFieldEnum
    having?: FriendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FriendCountAggregateInputType | true
    _avg?: FriendAvgAggregateInputType
    _sum?: FriendSumAggregateInputType
    _min?: FriendMinAggregateInputType
    _max?: FriendMaxAggregateInputType
  }

  export type FriendGroupByOutputType = {
    ID: number
    User1ID: number
    User2ID: number
    DateBefriended: Date
    _count: FriendCountAggregateOutputType | null
    _avg: FriendAvgAggregateOutputType | null
    _sum: FriendSumAggregateOutputType | null
    _min: FriendMinAggregateOutputType | null
    _max: FriendMaxAggregateOutputType | null
  }

  type GetFriendGroupByPayload<T extends FriendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FriendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FriendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FriendGroupByOutputType[P]>
            : GetScalarType<T[P], FriendGroupByOutputType[P]>
        }
      >
    >


  export type FriendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    User1ID?: boolean
    User2ID?: boolean
    DateBefriended?: boolean
    User1?: boolean | UserDefaultArgs<ExtArgs>
    User2?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friend"]>

  export type FriendSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    User1ID?: boolean
    User2ID?: boolean
    DateBefriended?: boolean
    User1?: boolean | UserDefaultArgs<ExtArgs>
    User2?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friend"]>

  export type FriendSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    User1ID?: boolean
    User2ID?: boolean
    DateBefriended?: boolean
    User1?: boolean | UserDefaultArgs<ExtArgs>
    User2?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["friend"]>

  export type FriendSelectScalar = {
    ID?: boolean
    User1ID?: boolean
    User2ID?: boolean
    DateBefriended?: boolean
  }

  export type FriendOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "User1ID" | "User2ID" | "DateBefriended", ExtArgs["result"]["friend"]>
  export type FriendInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User1?: boolean | UserDefaultArgs<ExtArgs>
    User2?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FriendIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User1?: boolean | UserDefaultArgs<ExtArgs>
    User2?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FriendIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User1?: boolean | UserDefaultArgs<ExtArgs>
    User2?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FriendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Friend"
    objects: {
      User1: Prisma.$UserPayload<ExtArgs>
      User2: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      User1ID: number
      User2ID: number
      DateBefriended: Date
    }, ExtArgs["result"]["friend"]>
    composites: {}
  }

  type FriendGetPayload<S extends boolean | null | undefined | FriendDefaultArgs> = $Result.GetResult<Prisma.$FriendPayload, S>

  type FriendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FriendFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FriendCountAggregateInputType | true
    }

  export interface FriendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Friend'], meta: { name: 'Friend' } }
    /**
     * Find zero or one Friend that matches the filter.
     * @param {FriendFindUniqueArgs} args - Arguments to find a Friend
     * @example
     * // Get one Friend
     * const friend = await prisma.friend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FriendFindUniqueArgs>(args: SelectSubset<T, FriendFindUniqueArgs<ExtArgs>>): Prisma__FriendClient<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Friend that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FriendFindUniqueOrThrowArgs} args - Arguments to find a Friend
     * @example
     * // Get one Friend
     * const friend = await prisma.friend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FriendFindUniqueOrThrowArgs>(args: SelectSubset<T, FriendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FriendClient<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendFindFirstArgs} args - Arguments to find a Friend
     * @example
     * // Get one Friend
     * const friend = await prisma.friend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FriendFindFirstArgs>(args?: SelectSubset<T, FriendFindFirstArgs<ExtArgs>>): Prisma__FriendClient<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Friend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendFindFirstOrThrowArgs} args - Arguments to find a Friend
     * @example
     * // Get one Friend
     * const friend = await prisma.friend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FriendFindFirstOrThrowArgs>(args?: SelectSubset<T, FriendFindFirstOrThrowArgs<ExtArgs>>): Prisma__FriendClient<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Friends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Friends
     * const friends = await prisma.friend.findMany()
     * 
     * // Get first 10 Friends
     * const friends = await prisma.friend.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const friendWithIDOnly = await prisma.friend.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends FriendFindManyArgs>(args?: SelectSubset<T, FriendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Friend.
     * @param {FriendCreateArgs} args - Arguments to create a Friend.
     * @example
     * // Create one Friend
     * const Friend = await prisma.friend.create({
     *   data: {
     *     // ... data to create a Friend
     *   }
     * })
     * 
     */
    create<T extends FriendCreateArgs>(args: SelectSubset<T, FriendCreateArgs<ExtArgs>>): Prisma__FriendClient<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Friends.
     * @param {FriendCreateManyArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friend = await prisma.friend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FriendCreateManyArgs>(args?: SelectSubset<T, FriendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Friends and returns the data saved in the database.
     * @param {FriendCreateManyAndReturnArgs} args - Arguments to create many Friends.
     * @example
     * // Create many Friends
     * const friend = await prisma.friend.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Friends and only return the `ID`
     * const friendWithIDOnly = await prisma.friend.createManyAndReturn({
     *   select: { ID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FriendCreateManyAndReturnArgs>(args?: SelectSubset<T, FriendCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Friend.
     * @param {FriendDeleteArgs} args - Arguments to delete one Friend.
     * @example
     * // Delete one Friend
     * const Friend = await prisma.friend.delete({
     *   where: {
     *     // ... filter to delete one Friend
     *   }
     * })
     * 
     */
    delete<T extends FriendDeleteArgs>(args: SelectSubset<T, FriendDeleteArgs<ExtArgs>>): Prisma__FriendClient<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Friend.
     * @param {FriendUpdateArgs} args - Arguments to update one Friend.
     * @example
     * // Update one Friend
     * const friend = await prisma.friend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FriendUpdateArgs>(args: SelectSubset<T, FriendUpdateArgs<ExtArgs>>): Prisma__FriendClient<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Friends.
     * @param {FriendDeleteManyArgs} args - Arguments to filter Friends to delete.
     * @example
     * // Delete a few Friends
     * const { count } = await prisma.friend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FriendDeleteManyArgs>(args?: SelectSubset<T, FriendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Friends
     * const friend = await prisma.friend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FriendUpdateManyArgs>(args: SelectSubset<T, FriendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Friends and returns the data updated in the database.
     * @param {FriendUpdateManyAndReturnArgs} args - Arguments to update many Friends.
     * @example
     * // Update many Friends
     * const friend = await prisma.friend.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Friends and only return the `ID`
     * const friendWithIDOnly = await prisma.friend.updateManyAndReturn({
     *   select: { ID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FriendUpdateManyAndReturnArgs>(args: SelectSubset<T, FriendUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Friend.
     * @param {FriendUpsertArgs} args - Arguments to update or create a Friend.
     * @example
     * // Update or create a Friend
     * const friend = await prisma.friend.upsert({
     *   create: {
     *     // ... data to create a Friend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Friend we want to update
     *   }
     * })
     */
    upsert<T extends FriendUpsertArgs>(args: SelectSubset<T, FriendUpsertArgs<ExtArgs>>): Prisma__FriendClient<$Result.GetResult<Prisma.$FriendPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Friends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendCountArgs} args - Arguments to filter Friends to count.
     * @example
     * // Count the number of Friends
     * const count = await prisma.friend.count({
     *   where: {
     *     // ... the filter for the Friends we want to count
     *   }
     * })
    **/
    count<T extends FriendCountArgs>(
      args?: Subset<T, FriendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FriendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Friend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FriendAggregateArgs>(args: Subset<T, FriendAggregateArgs>): Prisma.PrismaPromise<GetFriendAggregateType<T>>

    /**
     * Group by Friend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FriendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FriendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FriendGroupByArgs['orderBy'] }
        : { orderBy?: FriendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FriendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFriendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Friend model
   */
  readonly fields: FriendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Friend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FriendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User1<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    User2<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Friend model
   */
  interface FriendFieldRefs {
    readonly ID: FieldRef<"Friend", 'Int'>
    readonly User1ID: FieldRef<"Friend", 'Int'>
    readonly User2ID: FieldRef<"Friend", 'Int'>
    readonly DateBefriended: FieldRef<"Friend", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Friend findUnique
   */
  export type FriendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    /**
     * Filter, which Friend to fetch.
     */
    where: FriendWhereUniqueInput
  }

  /**
   * Friend findUniqueOrThrow
   */
  export type FriendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    /**
     * Filter, which Friend to fetch.
     */
    where: FriendWhereUniqueInput
  }

  /**
   * Friend findFirst
   */
  export type FriendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    /**
     * Filter, which Friend to fetch.
     */
    where?: FriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendOrderByWithRelationInput | FriendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendScalarFieldEnum | FriendScalarFieldEnum[]
  }

  /**
   * Friend findFirstOrThrow
   */
  export type FriendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    /**
     * Filter, which Friend to fetch.
     */
    where?: FriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendOrderByWithRelationInput | FriendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Friends.
     */
    cursor?: FriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Friends.
     */
    distinct?: FriendScalarFieldEnum | FriendScalarFieldEnum[]
  }

  /**
   * Friend findMany
   */
  export type FriendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    /**
     * Filter, which Friends to fetch.
     */
    where?: FriendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Friends to fetch.
     */
    orderBy?: FriendOrderByWithRelationInput | FriendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Friends.
     */
    cursor?: FriendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Friends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Friends.
     */
    skip?: number
    distinct?: FriendScalarFieldEnum | FriendScalarFieldEnum[]
  }

  /**
   * Friend create
   */
  export type FriendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    /**
     * The data needed to create a Friend.
     */
    data: XOR<FriendCreateInput, FriendUncheckedCreateInput>
  }

  /**
   * Friend createMany
   */
  export type FriendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Friends.
     */
    data: FriendCreateManyInput | FriendCreateManyInput[]
  }

  /**
   * Friend createManyAndReturn
   */
  export type FriendCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * The data used to create many Friends.
     */
    data: FriendCreateManyInput | FriendCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friend update
   */
  export type FriendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    /**
     * The data needed to update a Friend.
     */
    data: XOR<FriendUpdateInput, FriendUncheckedUpdateInput>
    /**
     * Choose, which Friend to update.
     */
    where: FriendWhereUniqueInput
  }

  /**
   * Friend updateMany
   */
  export type FriendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Friends.
     */
    data: XOR<FriendUpdateManyMutationInput, FriendUncheckedUpdateManyInput>
    /**
     * Filter which Friends to update
     */
    where?: FriendWhereInput
    /**
     * Limit how many Friends to update.
     */
    limit?: number
  }

  /**
   * Friend updateManyAndReturn
   */
  export type FriendUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * The data used to update Friends.
     */
    data: XOR<FriendUpdateManyMutationInput, FriendUncheckedUpdateManyInput>
    /**
     * Filter which Friends to update
     */
    where?: FriendWhereInput
    /**
     * Limit how many Friends to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Friend upsert
   */
  export type FriendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    /**
     * The filter to search for the Friend to update in case it exists.
     */
    where: FriendWhereUniqueInput
    /**
     * In case the Friend found by the `where` argument doesn't exist, create a new Friend with this data.
     */
    create: XOR<FriendCreateInput, FriendUncheckedCreateInput>
    /**
     * In case the Friend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FriendUpdateInput, FriendUncheckedUpdateInput>
  }

  /**
   * Friend delete
   */
  export type FriendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
    /**
     * Filter which Friend to delete.
     */
    where: FriendWhereUniqueInput
  }

  /**
   * Friend deleteMany
   */
  export type FriendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Friends to delete
     */
    where?: FriendWhereInput
    /**
     * Limit how many Friends to delete.
     */
    limit?: number
  }

  /**
   * Friend without action
   */
  export type FriendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Friend
     */
    select?: FriendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Friend
     */
    omit?: FriendOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FriendInclude<ExtArgs> | null
  }


  /**
   * Model Invitation
   */

  export type AggregateInvitation = {
    _count: InvitationCountAggregateOutputType | null
    _avg: InvitationAvgAggregateOutputType | null
    _sum: InvitationSumAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  export type InvitationAvgAggregateOutputType = {
    ID: number | null
    SenderID: number | null
    ReceiverID: number | null
    Status: number | null
    MatchID: number | null
  }

  export type InvitationSumAggregateOutputType = {
    ID: number | null
    SenderID: number | null
    ReceiverID: number | null
    Status: number | null
    MatchID: number | null
  }

  export type InvitationMinAggregateOutputType = {
    ID: number | null
    SenderID: number | null
    ReceiverID: number | null
    Status: number | null
    SentAt: Date | null
    RespondedAt: Date | null
    MatchID: number | null
  }

  export type InvitationMaxAggregateOutputType = {
    ID: number | null
    SenderID: number | null
    ReceiverID: number | null
    Status: number | null
    SentAt: Date | null
    RespondedAt: Date | null
    MatchID: number | null
  }

  export type InvitationCountAggregateOutputType = {
    ID: number
    SenderID: number
    ReceiverID: number
    Status: number
    SentAt: number
    RespondedAt: number
    MatchID: number
    _all: number
  }


  export type InvitationAvgAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
    Status?: true
    MatchID?: true
  }

  export type InvitationSumAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
    Status?: true
    MatchID?: true
  }

  export type InvitationMinAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
    Status?: true
    SentAt?: true
    RespondedAt?: true
    MatchID?: true
  }

  export type InvitationMaxAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
    Status?: true
    SentAt?: true
    RespondedAt?: true
    MatchID?: true
  }

  export type InvitationCountAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
    Status?: true
    SentAt?: true
    RespondedAt?: true
    MatchID?: true
    _all?: true
  }

  export type InvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitation to aggregate.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invitations
    **/
    _count?: true | InvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvitationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvitationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvitationMaxAggregateInputType
  }

  export type GetInvitationAggregateType<T extends InvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvitation[P]>
      : GetScalarType<T[P], AggregateInvitation[P]>
  }




  export type InvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithAggregationInput | InvitationOrderByWithAggregationInput[]
    by: InvitationScalarFieldEnum[] | InvitationScalarFieldEnum
    having?: InvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvitationCountAggregateInputType | true
    _avg?: InvitationAvgAggregateInputType
    _sum?: InvitationSumAggregateInputType
    _min?: InvitationMinAggregateInputType
    _max?: InvitationMaxAggregateInputType
  }

  export type InvitationGroupByOutputType = {
    ID: number
    SenderID: number
    ReceiverID: number
    Status: number
    SentAt: Date
    RespondedAt: Date | null
    MatchID: number
    _count: InvitationCountAggregateOutputType | null
    _avg: InvitationAvgAggregateOutputType | null
    _sum: InvitationSumAggregateOutputType | null
    _min: InvitationMinAggregateOutputType | null
    _max: InvitationMaxAggregateOutputType | null
  }

  type GetInvitationGroupByPayload<T extends InvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvitationGroupByOutputType[P]>
            : GetScalarType<T[P], InvitationGroupByOutputType[P]>
        }
      >
    >


  export type InvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    SenderID?: boolean
    ReceiverID?: boolean
    Status?: boolean
    SentAt?: boolean
    RespondedAt?: boolean
    MatchID?: boolean
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
    Match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    SenderID?: boolean
    ReceiverID?: boolean
    Status?: boolean
    SentAt?: boolean
    RespondedAt?: boolean
    MatchID?: boolean
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
    Match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    SenderID?: boolean
    ReceiverID?: boolean
    Status?: boolean
    SentAt?: boolean
    RespondedAt?: boolean
    MatchID?: boolean
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
    Match?: boolean | MatchDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invitation"]>

  export type InvitationSelectScalar = {
    ID?: boolean
    SenderID?: boolean
    ReceiverID?: boolean
    Status?: boolean
    SentAt?: boolean
    RespondedAt?: boolean
    MatchID?: boolean
  }

  export type InvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "SenderID" | "ReceiverID" | "Status" | "SentAt" | "RespondedAt" | "MatchID", ExtArgs["result"]["invitation"]>
  export type InvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
    Match?: boolean | MatchDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
    Match?: boolean | MatchDefaultArgs<ExtArgs>
  }
  export type InvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
    Match?: boolean | MatchDefaultArgs<ExtArgs>
  }

  export type $InvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invitation"
    objects: {
      Sender: Prisma.$UserPayload<ExtArgs>
      Receiver: Prisma.$UserPayload<ExtArgs>
      Match: Prisma.$MatchPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      SenderID: number
      ReceiverID: number
      Status: number
      SentAt: Date
      RespondedAt: Date | null
      MatchID: number
    }, ExtArgs["result"]["invitation"]>
    composites: {}
  }

  type InvitationGetPayload<S extends boolean | null | undefined | InvitationDefaultArgs> = $Result.GetResult<Prisma.$InvitationPayload, S>

  type InvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvitationCountAggregateInputType | true
    }

  export interface InvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invitation'], meta: { name: 'Invitation' } }
    /**
     * Find zero or one Invitation that matches the filter.
     * @param {InvitationFindUniqueArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvitationFindUniqueArgs>(args: SelectSubset<T, InvitationFindUniqueArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvitationFindUniqueOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, InvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvitationFindFirstArgs>(args?: SelectSubset<T, InvitationFindFirstArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindFirstOrThrowArgs} args - Arguments to find a Invitation
     * @example
     * // Get one Invitation
     * const invitation = await prisma.invitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, InvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invitations
     * const invitations = await prisma.invitation.findMany()
     * 
     * // Get first 10 Invitations
     * const invitations = await prisma.invitation.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const invitationWithIDOnly = await prisma.invitation.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends InvitationFindManyArgs>(args?: SelectSubset<T, InvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invitation.
     * @param {InvitationCreateArgs} args - Arguments to create a Invitation.
     * @example
     * // Create one Invitation
     * const Invitation = await prisma.invitation.create({
     *   data: {
     *     // ... data to create a Invitation
     *   }
     * })
     * 
     */
    create<T extends InvitationCreateArgs>(args: SelectSubset<T, InvitationCreateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invitations.
     * @param {InvitationCreateManyArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvitationCreateManyArgs>(args?: SelectSubset<T, InvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invitations and returns the data saved in the database.
     * @param {InvitationCreateManyAndReturnArgs} args - Arguments to create many Invitations.
     * @example
     * // Create many Invitations
     * const invitation = await prisma.invitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invitations and only return the `ID`
     * const invitationWithIDOnly = await prisma.invitation.createManyAndReturn({
     *   select: { ID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, InvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invitation.
     * @param {InvitationDeleteArgs} args - Arguments to delete one Invitation.
     * @example
     * // Delete one Invitation
     * const Invitation = await prisma.invitation.delete({
     *   where: {
     *     // ... filter to delete one Invitation
     *   }
     * })
     * 
     */
    delete<T extends InvitationDeleteArgs>(args: SelectSubset<T, InvitationDeleteArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invitation.
     * @param {InvitationUpdateArgs} args - Arguments to update one Invitation.
     * @example
     * // Update one Invitation
     * const invitation = await prisma.invitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvitationUpdateArgs>(args: SelectSubset<T, InvitationUpdateArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invitations.
     * @param {InvitationDeleteManyArgs} args - Arguments to filter Invitations to delete.
     * @example
     * // Delete a few Invitations
     * const { count } = await prisma.invitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvitationDeleteManyArgs>(args?: SelectSubset<T, InvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvitationUpdateManyArgs>(args: SelectSubset<T, InvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invitations and returns the data updated in the database.
     * @param {InvitationUpdateManyAndReturnArgs} args - Arguments to update many Invitations.
     * @example
     * // Update many Invitations
     * const invitation = await prisma.invitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invitations and only return the `ID`
     * const invitationWithIDOnly = await prisma.invitation.updateManyAndReturn({
     *   select: { ID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, InvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invitation.
     * @param {InvitationUpsertArgs} args - Arguments to update or create a Invitation.
     * @example
     * // Update or create a Invitation
     * const invitation = await prisma.invitation.upsert({
     *   create: {
     *     // ... data to create a Invitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invitation we want to update
     *   }
     * })
     */
    upsert<T extends InvitationUpsertArgs>(args: SelectSubset<T, InvitationUpsertArgs<ExtArgs>>): Prisma__InvitationClient<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationCountArgs} args - Arguments to filter Invitations to count.
     * @example
     * // Count the number of Invitations
     * const count = await prisma.invitation.count({
     *   where: {
     *     // ... the filter for the Invitations we want to count
     *   }
     * })
    **/
    count<T extends InvitationCountArgs>(
      args?: Subset<T, InvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvitationAggregateArgs>(args: Subset<T, InvitationAggregateArgs>): Prisma.PrismaPromise<GetInvitationAggregateType<T>>

    /**
     * Group by Invitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvitationGroupByArgs['orderBy'] }
        : { orderBy?: InvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invitation model
   */
  readonly fields: InvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Match<T extends MatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MatchDefaultArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invitation model
   */
  interface InvitationFieldRefs {
    readonly ID: FieldRef<"Invitation", 'Int'>
    readonly SenderID: FieldRef<"Invitation", 'Int'>
    readonly ReceiverID: FieldRef<"Invitation", 'Int'>
    readonly Status: FieldRef<"Invitation", 'Int'>
    readonly SentAt: FieldRef<"Invitation", 'DateTime'>
    readonly RespondedAt: FieldRef<"Invitation", 'DateTime'>
    readonly MatchID: FieldRef<"Invitation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Invitation findUnique
   */
  export type InvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findUniqueOrThrow
   */
  export type InvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation findFirst
   */
  export type InvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findFirstOrThrow
   */
  export type InvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitation to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invitations.
     */
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation findMany
   */
  export type InvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter, which Invitations to fetch.
     */
    where?: InvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invitations to fetch.
     */
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invitations.
     */
    cursor?: InvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invitations.
     */
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Invitation create
   */
  export type InvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a Invitation.
     */
    data: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
  }

  /**
   * Invitation createMany
   */
  export type InvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
  }

  /**
   * Invitation createManyAndReturn
   */
  export type InvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to create many Invitations.
     */
    data: InvitationCreateManyInput | InvitationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation update
   */
  export type InvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a Invitation.
     */
    data: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
    /**
     * Choose, which Invitation to update.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation updateMany
   */
  export type InvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
  }

  /**
   * Invitation updateManyAndReturn
   */
  export type InvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * The data used to update Invitations.
     */
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyInput>
    /**
     * Filter which Invitations to update
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invitation upsert
   */
  export type InvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the Invitation to update in case it exists.
     */
    where: InvitationWhereUniqueInput
    /**
     * In case the Invitation found by the `where` argument doesn't exist, create a new Invitation with this data.
     */
    create: XOR<InvitationCreateInput, InvitationUncheckedCreateInput>
    /**
     * In case the Invitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvitationUpdateInput, InvitationUncheckedUpdateInput>
  }

  /**
   * Invitation delete
   */
  export type InvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    /**
     * Filter which Invitation to delete.
     */
    where: InvitationWhereUniqueInput
  }

  /**
   * Invitation deleteMany
   */
  export type InvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invitations to delete
     */
    where?: InvitationWhereInput
    /**
     * Limit how many Invitations to delete.
     */
    limit?: number
  }

  /**
   * Invitation without action
   */
  export type InvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
  }


  /**
   * Model Log
   */

  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogAvgAggregateOutputType = {
    UUID: number | null
    Type: number | null
    ServerClientID: number | null
  }

  export type LogSumAggregateOutputType = {
    UUID: number | null
    Type: number | null
    ServerClientID: number | null
  }

  export type LogMinAggregateOutputType = {
    UUID: number | null
    DateTime: Date | null
    Type: number | null
    ServerClientID: number | null
    Message: string | null
  }

  export type LogMaxAggregateOutputType = {
    UUID: number | null
    DateTime: Date | null
    Type: number | null
    ServerClientID: number | null
    Message: string | null
  }

  export type LogCountAggregateOutputType = {
    UUID: number
    DateTime: number
    Type: number
    ServerClientID: number
    Message: number
    _all: number
  }


  export type LogAvgAggregateInputType = {
    UUID?: true
    Type?: true
    ServerClientID?: true
  }

  export type LogSumAggregateInputType = {
    UUID?: true
    Type?: true
    ServerClientID?: true
  }

  export type LogMinAggregateInputType = {
    UUID?: true
    DateTime?: true
    Type?: true
    ServerClientID?: true
    Message?: true
  }

  export type LogMaxAggregateInputType = {
    UUID?: true
    DateTime?: true
    Type?: true
    ServerClientID?: true
    Message?: true
  }

  export type LogCountAggregateInputType = {
    UUID?: true
    DateTime?: true
    Type?: true
    ServerClientID?: true
    Message?: true
    _all?: true
  }

  export type LogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Log to aggregate.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogWhereInput
    orderBy?: LogOrderByWithAggregationInput | LogOrderByWithAggregationInput[]
    by: LogScalarFieldEnum[] | LogScalarFieldEnum
    having?: LogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _avg?: LogAvgAggregateInputType
    _sum?: LogSumAggregateInputType
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }

  export type LogGroupByOutputType = {
    UUID: number
    DateTime: Date
    Type: number
    ServerClientID: number
    Message: string
    _count: LogCountAggregateOutputType | null
    _avg: LogAvgAggregateOutputType | null
    _sum: LogSumAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type LogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UUID?: boolean
    DateTime?: boolean
    Type?: boolean
    ServerClientID?: boolean
    Message?: boolean
  }, ExtArgs["result"]["log"]>

  export type LogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UUID?: boolean
    DateTime?: boolean
    Type?: boolean
    ServerClientID?: boolean
    Message?: boolean
  }, ExtArgs["result"]["log"]>

  export type LogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UUID?: boolean
    DateTime?: boolean
    Type?: boolean
    ServerClientID?: boolean
    Message?: boolean
  }, ExtArgs["result"]["log"]>

  export type LogSelectScalar = {
    UUID?: boolean
    DateTime?: boolean
    Type?: boolean
    ServerClientID?: boolean
    Message?: boolean
  }

  export type LogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"UUID" | "DateTime" | "Type" | "ServerClientID" | "Message", ExtArgs["result"]["log"]>

  export type $LogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Log"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      UUID: number
      DateTime: Date
      Type: number
      ServerClientID: number
      Message: string
    }, ExtArgs["result"]["log"]>
    composites: {}
  }

  type LogGetPayload<S extends boolean | null | undefined | LogDefaultArgs> = $Result.GetResult<Prisma.$LogPayload, S>

  type LogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface LogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Log'], meta: { name: 'Log' } }
    /**
     * Find zero or one Log that matches the filter.
     * @param {LogFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogFindUniqueArgs>(args: SelectSubset<T, LogFindUniqueArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Log that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogFindUniqueOrThrowArgs>(args: SelectSubset<T, LogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogFindFirstArgs>(args?: SelectSubset<T, LogFindFirstArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Log that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogFindFirstOrThrowArgs>(args?: SelectSubset<T, LogFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `UUID`
     * const logWithUUIDOnly = await prisma.log.findMany({ select: { UUID: true } })
     * 
     */
    findMany<T extends LogFindManyArgs>(args?: SelectSubset<T, LogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Log.
     * @param {LogCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
     */
    create<T extends LogCreateArgs>(args: SelectSubset<T, LogCreateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogCreateManyArgs>(args?: SelectSubset<T, LogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const log = await prisma.log.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `UUID`
     * const logWithUUIDOnly = await prisma.log.createManyAndReturn({
     *   select: { UUID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogCreateManyAndReturnArgs>(args?: SelectSubset<T, LogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Log.
     * @param {LogDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
     */
    delete<T extends LogDeleteArgs>(args: SelectSubset<T, LogDeleteArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Log.
     * @param {LogUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogUpdateArgs>(args: SelectSubset<T, LogUpdateArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogDeleteManyArgs>(args?: SelectSubset<T, LogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogUpdateManyArgs>(args: SelectSubset<T, LogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {LogUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `UUID`
     * const logWithUUIDOnly = await prisma.log.updateManyAndReturn({
     *   select: { UUID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogUpdateManyAndReturnArgs>(args: SelectSubset<T, LogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Log.
     * @param {LogUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
     */
    upsert<T extends LogUpsertArgs>(args: SelectSubset<T, LogUpsertArgs<ExtArgs>>): Prisma__LogClient<$Result.GetResult<Prisma.$LogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogCountArgs>(
      args?: Subset<T, LogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Log model
   */
  readonly fields: LogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Log model
   */
  interface LogFieldRefs {
    readonly UUID: FieldRef<"Log", 'Int'>
    readonly DateTime: FieldRef<"Log", 'DateTime'>
    readonly Type: FieldRef<"Log", 'Int'>
    readonly ServerClientID: FieldRef<"Log", 'Int'>
    readonly Message: FieldRef<"Log", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Log findUnique
   */
  export type LogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findUniqueOrThrow
   */
  export type LogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log findFirst
   */
  export type LogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findFirstOrThrow
   */
  export type LogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Filter, which Log to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log findMany
   */
  export type LogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogOrderByWithRelationInput | LogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogScalarFieldEnum | LogScalarFieldEnum[]
  }

  /**
   * Log create
   */
  export type LogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data needed to create a Log.
     */
    data: XOR<LogCreateInput, LogUncheckedCreateInput>
  }

  /**
   * Log createMany
   */
  export type LogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
  }

  /**
   * Log createManyAndReturn
   */
  export type LogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogCreateManyInput | LogCreateManyInput[]
  }

  /**
   * Log update
   */
  export type LogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data needed to update a Log.
     */
    data: XOR<LogUpdateInput, LogUncheckedUpdateInput>
    /**
     * Choose, which Log to update.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log updateMany
   */
  export type LogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log updateManyAndReturn
   */
  export type LogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The data used to update Logs.
     */
    data: XOR<LogUpdateManyMutationInput, LogUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Log upsert
   */
  export type LogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * The filter to search for the Log to update in case it exists.
     */
    where: LogWhereUniqueInput
    /**
     * In case the Log found by the `where` argument doesn't exist, create a new Log with this data.
     */
    create: XOR<LogCreateInput, LogUncheckedCreateInput>
    /**
     * In case the Log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogUpdateInput, LogUncheckedUpdateInput>
  }

  /**
   * Log delete
   */
  export type LogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
    /**
     * Filter which Log to delete.
     */
    where: LogWhereUniqueInput
  }

  /**
   * Log deleteMany
   */
  export type LogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Log without action
   */
  export type LogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Log
     */
    select?: LogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Log
     */
    omit?: LogOmit<ExtArgs> | null
  }


  /**
   * Model Match
   */

  export type AggregateMatch = {
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  export type MatchAvgAggregateOutputType = {
    ID: number | null
    Player1ID: number | null
    Player2ID: number | null
    Player1Score: number | null
    Player2Score: number | null
    WinnerID: number | null
  }

  export type MatchSumAggregateOutputType = {
    ID: number | null
    Player1ID: number | null
    Player2ID: number | null
    Player1Score: number | null
    Player2Score: number | null
    WinnerID: number | null
  }

  export type MatchMinAggregateOutputType = {
    ID: number | null
    Player1ID: number | null
    Player2ID: number | null
    Player1Score: number | null
    Player2Score: number | null
    CreationDate: Date | null
    WinnerID: number | null
  }

  export type MatchMaxAggregateOutputType = {
    ID: number | null
    Player1ID: number | null
    Player2ID: number | null
    Player1Score: number | null
    Player2Score: number | null
    CreationDate: Date | null
    WinnerID: number | null
  }

  export type MatchCountAggregateOutputType = {
    ID: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: number
    WinnerID: number
    _all: number
  }


  export type MatchAvgAggregateInputType = {
    ID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    WinnerID?: true
  }

  export type MatchSumAggregateInputType = {
    ID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    WinnerID?: true
  }

  export type MatchMinAggregateInputType = {
    ID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    CreationDate?: true
    WinnerID?: true
  }

  export type MatchMaxAggregateInputType = {
    ID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    CreationDate?: true
    WinnerID?: true
  }

  export type MatchCountAggregateInputType = {
    ID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    CreationDate?: true
    WinnerID?: true
    _all?: true
  }

  export type MatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Match to aggregate.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Matches
    **/
    _count?: true | MatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MatchMaxAggregateInputType
  }

  export type GetMatchAggregateType<T extends MatchAggregateArgs> = {
        [P in keyof T & keyof AggregateMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMatch[P]>
      : GetScalarType<T[P], AggregateMatch[P]>
  }




  export type MatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MatchWhereInput
    orderBy?: MatchOrderByWithAggregationInput | MatchOrderByWithAggregationInput[]
    by: MatchScalarFieldEnum[] | MatchScalarFieldEnum
    having?: MatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MatchCountAggregateInputType | true
    _avg?: MatchAvgAggregateInputType
    _sum?: MatchSumAggregateInputType
    _min?: MatchMinAggregateInputType
    _max?: MatchMaxAggregateInputType
  }

  export type MatchGroupByOutputType = {
    ID: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date
    WinnerID: number | null
    _count: MatchCountAggregateOutputType | null
    _avg: MatchAvgAggregateOutputType | null
    _sum: MatchSumAggregateOutputType | null
    _min: MatchMinAggregateOutputType | null
    _max: MatchMaxAggregateOutputType | null
  }

  type GetMatchGroupByPayload<T extends MatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MatchGroupByOutputType[P]>
            : GetScalarType<T[P], MatchGroupByOutputType[P]>
        }
      >
    >


  export type MatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Player1ID?: boolean
    Player2ID?: boolean
    Player1Score?: boolean
    Player2Score?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
    Player1?: boolean | UserDefaultArgs<ExtArgs>
    Player2?: boolean | UserDefaultArgs<ExtArgs>
    Winner?: boolean | Match$WinnerArgs<ExtArgs>
    Invitations?: boolean | Match$InvitationsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Player1ID?: boolean
    Player2ID?: boolean
    Player1Score?: boolean
    Player2Score?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
    Player1?: boolean | UserDefaultArgs<ExtArgs>
    Player2?: boolean | UserDefaultArgs<ExtArgs>
    Winner?: boolean | Match$WinnerArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Player1ID?: boolean
    Player2ID?: boolean
    Player1Score?: boolean
    Player2Score?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
    Player1?: boolean | UserDefaultArgs<ExtArgs>
    Player2?: boolean | UserDefaultArgs<ExtArgs>
    Winner?: boolean | Match$WinnerArgs<ExtArgs>
  }, ExtArgs["result"]["match"]>

  export type MatchSelectScalar = {
    ID?: boolean
    Player1ID?: boolean
    Player2ID?: boolean
    Player1Score?: boolean
    Player2Score?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
  }

  export type MatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Player1ID" | "Player2ID" | "Player1Score" | "Player2Score" | "CreationDate" | "WinnerID", ExtArgs["result"]["match"]>
  export type MatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Player1?: boolean | UserDefaultArgs<ExtArgs>
    Player2?: boolean | UserDefaultArgs<ExtArgs>
    Winner?: boolean | Match$WinnerArgs<ExtArgs>
    Invitations?: boolean | Match$InvitationsArgs<ExtArgs>
    _count?: boolean | MatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Player1?: boolean | UserDefaultArgs<ExtArgs>
    Player2?: boolean | UserDefaultArgs<ExtArgs>
    Winner?: boolean | Match$WinnerArgs<ExtArgs>
  }
  export type MatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Player1?: boolean | UserDefaultArgs<ExtArgs>
    Player2?: boolean | UserDefaultArgs<ExtArgs>
    Winner?: boolean | Match$WinnerArgs<ExtArgs>
  }

  export type $MatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Match"
    objects: {
      Player1: Prisma.$UserPayload<ExtArgs>
      Player2: Prisma.$UserPayload<ExtArgs>
      Winner: Prisma.$UserPayload<ExtArgs> | null
      Invitations: Prisma.$InvitationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Player1ID: number
      Player2ID: number
      Player1Score: number
      Player2Score: number
      CreationDate: Date
      WinnerID: number | null
    }, ExtArgs["result"]["match"]>
    composites: {}
  }

  type MatchGetPayload<S extends boolean | null | undefined | MatchDefaultArgs> = $Result.GetResult<Prisma.$MatchPayload, S>

  type MatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MatchCountAggregateInputType | true
    }

  export interface MatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Match'], meta: { name: 'Match' } }
    /**
     * Find zero or one Match that matches the filter.
     * @param {MatchFindUniqueArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MatchFindUniqueArgs>(args: SelectSubset<T, MatchFindUniqueArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Match that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MatchFindUniqueOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MatchFindUniqueOrThrowArgs>(args: SelectSubset<T, MatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MatchFindFirstArgs>(args?: SelectSubset<T, MatchFindFirstArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Match that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindFirstOrThrowArgs} args - Arguments to find a Match
     * @example
     * // Get one Match
     * const match = await prisma.match.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MatchFindFirstOrThrowArgs>(args?: SelectSubset<T, MatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Matches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Matches
     * const matches = await prisma.match.findMany()
     * 
     * // Get first 10 Matches
     * const matches = await prisma.match.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const matchWithIDOnly = await prisma.match.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends MatchFindManyArgs>(args?: SelectSubset<T, MatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Match.
     * @param {MatchCreateArgs} args - Arguments to create a Match.
     * @example
     * // Create one Match
     * const Match = await prisma.match.create({
     *   data: {
     *     // ... data to create a Match
     *   }
     * })
     * 
     */
    create<T extends MatchCreateArgs>(args: SelectSubset<T, MatchCreateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Matches.
     * @param {MatchCreateManyArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MatchCreateManyArgs>(args?: SelectSubset<T, MatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Matches and returns the data saved in the database.
     * @param {MatchCreateManyAndReturnArgs} args - Arguments to create many Matches.
     * @example
     * // Create many Matches
     * const match = await prisma.match.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Matches and only return the `ID`
     * const matchWithIDOnly = await prisma.match.createManyAndReturn({
     *   select: { ID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MatchCreateManyAndReturnArgs>(args?: SelectSubset<T, MatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Match.
     * @param {MatchDeleteArgs} args - Arguments to delete one Match.
     * @example
     * // Delete one Match
     * const Match = await prisma.match.delete({
     *   where: {
     *     // ... filter to delete one Match
     *   }
     * })
     * 
     */
    delete<T extends MatchDeleteArgs>(args: SelectSubset<T, MatchDeleteArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Match.
     * @param {MatchUpdateArgs} args - Arguments to update one Match.
     * @example
     * // Update one Match
     * const match = await prisma.match.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MatchUpdateArgs>(args: SelectSubset<T, MatchUpdateArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Matches.
     * @param {MatchDeleteManyArgs} args - Arguments to filter Matches to delete.
     * @example
     * // Delete a few Matches
     * const { count } = await prisma.match.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MatchDeleteManyArgs>(args?: SelectSubset<T, MatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MatchUpdateManyArgs>(args: SelectSubset<T, MatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Matches and returns the data updated in the database.
     * @param {MatchUpdateManyAndReturnArgs} args - Arguments to update many Matches.
     * @example
     * // Update many Matches
     * const match = await prisma.match.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Matches and only return the `ID`
     * const matchWithIDOnly = await prisma.match.updateManyAndReturn({
     *   select: { ID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MatchUpdateManyAndReturnArgs>(args: SelectSubset<T, MatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Match.
     * @param {MatchUpsertArgs} args - Arguments to update or create a Match.
     * @example
     * // Update or create a Match
     * const match = await prisma.match.upsert({
     *   create: {
     *     // ... data to create a Match
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Match we want to update
     *   }
     * })
     */
    upsert<T extends MatchUpsertArgs>(args: SelectSubset<T, MatchUpsertArgs<ExtArgs>>): Prisma__MatchClient<$Result.GetResult<Prisma.$MatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Matches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchCountArgs} args - Arguments to filter Matches to count.
     * @example
     * // Count the number of Matches
     * const count = await prisma.match.count({
     *   where: {
     *     // ... the filter for the Matches we want to count
     *   }
     * })
    **/
    count<T extends MatchCountArgs>(
      args?: Subset<T, MatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MatchAggregateArgs>(args: Subset<T, MatchAggregateArgs>): Prisma.PrismaPromise<GetMatchAggregateType<T>>

    /**
     * Group by Match.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MatchGroupByArgs['orderBy'] }
        : { orderBy?: MatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Match model
   */
  readonly fields: MatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Match.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Player1<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Player2<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Winner<T extends Match$WinnerArgs<ExtArgs> = {}>(args?: Subset<T, Match$WinnerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Invitations<T extends Match$InvitationsArgs<ExtArgs> = {}>(args?: Subset<T, Match$InvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Match model
   */
  interface MatchFieldRefs {
    readonly ID: FieldRef<"Match", 'Int'>
    readonly Player1ID: FieldRef<"Match", 'Int'>
    readonly Player2ID: FieldRef<"Match", 'Int'>
    readonly Player1Score: FieldRef<"Match", 'Int'>
    readonly Player2Score: FieldRef<"Match", 'Int'>
    readonly CreationDate: FieldRef<"Match", 'DateTime'>
    readonly WinnerID: FieldRef<"Match", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Match findUnique
   */
  export type MatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findUniqueOrThrow
   */
  export type MatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match findFirst
   */
  export type MatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findFirstOrThrow
   */
  export type MatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Match to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Matches.
     */
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match findMany
   */
  export type MatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter, which Matches to fetch.
     */
    where?: MatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Matches to fetch.
     */
    orderBy?: MatchOrderByWithRelationInput | MatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Matches.
     */
    cursor?: MatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Matches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Matches.
     */
    skip?: number
    distinct?: MatchScalarFieldEnum | MatchScalarFieldEnum[]
  }

  /**
   * Match create
   */
  export type MatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to create a Match.
     */
    data: XOR<MatchCreateInput, MatchUncheckedCreateInput>
  }

  /**
   * Match createMany
   */
  export type MatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
  }

  /**
   * Match createManyAndReturn
   */
  export type MatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to create many Matches.
     */
    data: MatchCreateManyInput | MatchCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match update
   */
  export type MatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The data needed to update a Match.
     */
    data: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
    /**
     * Choose, which Match to update.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match updateMany
   */
  export type MatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
  }

  /**
   * Match updateManyAndReturn
   */
  export type MatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * The data used to update Matches.
     */
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyInput>
    /**
     * Filter which Matches to update
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Match upsert
   */
  export type MatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * The filter to search for the Match to update in case it exists.
     */
    where: MatchWhereUniqueInput
    /**
     * In case the Match found by the `where` argument doesn't exist, create a new Match with this data.
     */
    create: XOR<MatchCreateInput, MatchUncheckedCreateInput>
    /**
     * In case the Match was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MatchUpdateInput, MatchUncheckedUpdateInput>
  }

  /**
   * Match delete
   */
  export type MatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
    /**
     * Filter which Match to delete.
     */
    where: MatchWhereUniqueInput
  }

  /**
   * Match deleteMany
   */
  export type MatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Matches to delete
     */
    where?: MatchWhereInput
    /**
     * Limit how many Matches to delete.
     */
    limit?: number
  }

  /**
   * Match.Winner
   */
  export type Match$WinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Match.Invitations
   */
  export type Match$InvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invitation
     */
    select?: InvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invitation
     */
    omit?: InvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvitationInclude<ExtArgs> | null
    where?: InvitationWhereInput
    orderBy?: InvitationOrderByWithRelationInput | InvitationOrderByWithRelationInput[]
    cursor?: InvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvitationScalarFieldEnum | InvitationScalarFieldEnum[]
  }

  /**
   * Match without action
   */
  export type MatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Match
     */
    select?: MatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Match
     */
    omit?: MatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MatchInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageAvgAggregateOutputType = {
    ID: number | null
    SenderID: number | null
    ReceiverID: number | null
  }

  export type MessageSumAggregateOutputType = {
    ID: number | null
    SenderID: number | null
    ReceiverID: number | null
  }

  export type MessageMinAggregateOutputType = {
    ID: number | null
    SenderID: number | null
    ReceiverID: number | null
    Message: string | null
    DateTime: Date | null
    IsRead: boolean | null
  }

  export type MessageMaxAggregateOutputType = {
    ID: number | null
    SenderID: number | null
    ReceiverID: number | null
    Message: string | null
    DateTime: Date | null
    IsRead: boolean | null
  }

  export type MessageCountAggregateOutputType = {
    ID: number
    SenderID: number
    ReceiverID: number
    Message: number
    DateTime: number
    IsRead: number
    _all: number
  }


  export type MessageAvgAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
  }

  export type MessageSumAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
  }

  export type MessageMinAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
    Message?: true
    DateTime?: true
    IsRead?: true
  }

  export type MessageMaxAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
    Message?: true
    DateTime?: true
    IsRead?: true
  }

  export type MessageCountAggregateInputType = {
    ID?: true
    SenderID?: true
    ReceiverID?: true
    Message?: true
    DateTime?: true
    IsRead?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _avg?: MessageAvgAggregateInputType
    _sum?: MessageSumAggregateInputType
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    ID: number
    SenderID: number
    ReceiverID: number
    Message: string
    DateTime: Date
    IsRead: boolean
    _count: MessageCountAggregateOutputType | null
    _avg: MessageAvgAggregateOutputType | null
    _sum: MessageSumAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    SenderID?: boolean
    ReceiverID?: boolean
    Message?: boolean
    DateTime?: boolean
    IsRead?: boolean
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    SenderID?: boolean
    ReceiverID?: boolean
    Message?: boolean
    DateTime?: boolean
    IsRead?: boolean
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    SenderID?: boolean
    ReceiverID?: boolean
    Message?: boolean
    DateTime?: boolean
    IsRead?: boolean
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    ID?: boolean
    SenderID?: boolean
    ReceiverID?: boolean
    Message?: boolean
    DateTime?: boolean
    IsRead?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "SenderID" | "ReceiverID" | "Message" | "DateTime" | "IsRead", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Sender?: boolean | UserDefaultArgs<ExtArgs>
    Receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      Sender: Prisma.$UserPayload<ExtArgs>
      Receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      SenderID: number
      ReceiverID: number
      Message: string
      DateTime: Date
      IsRead: boolean
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const messageWithIDOnly = await prisma.message.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `ID`
     * const messageWithIDOnly = await prisma.message.createManyAndReturn({
     *   select: { ID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `ID`
     * const messageWithIDOnly = await prisma.message.updateManyAndReturn({
     *   select: { ID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly ID: FieldRef<"Message", 'Int'>
    readonly SenderID: FieldRef<"Message", 'Int'>
    readonly ReceiverID: FieldRef<"Message", 'Int'>
    readonly Message: FieldRef<"Message", 'String'>
    readonly DateTime: FieldRef<"Message", 'DateTime'>
    readonly IsRead: FieldRef<"Message", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Tournament
   */

  export type AggregateTournament = {
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  export type TournamentAvgAggregateOutputType = {
    ID: number | null
    WinnerID: number | null
  }

  export type TournamentSumAggregateOutputType = {
    ID: number | null
    WinnerID: number | null
  }

  export type TournamentMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    CreationDate: Date | null
    WinnerID: number | null
  }

  export type TournamentMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    CreationDate: Date | null
    WinnerID: number | null
  }

  export type TournamentCountAggregateOutputType = {
    ID: number
    Name: number
    CreationDate: number
    WinnerID: number
    _all: number
  }


  export type TournamentAvgAggregateInputType = {
    ID?: true
    WinnerID?: true
  }

  export type TournamentSumAggregateInputType = {
    ID?: true
    WinnerID?: true
  }

  export type TournamentMinAggregateInputType = {
    ID?: true
    Name?: true
    CreationDate?: true
    WinnerID?: true
  }

  export type TournamentMaxAggregateInputType = {
    ID?: true
    Name?: true
    CreationDate?: true
    WinnerID?: true
  }

  export type TournamentCountAggregateInputType = {
    ID?: true
    Name?: true
    CreationDate?: true
    WinnerID?: true
    _all?: true
  }

  export type TournamentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournament to aggregate.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tournaments
    **/
    _count?: true | TournamentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentMaxAggregateInputType
  }

  export type GetTournamentAggregateType<T extends TournamentAggregateArgs> = {
        [P in keyof T & keyof AggregateTournament]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournament[P]>
      : GetScalarType<T[P], AggregateTournament[P]>
  }




  export type TournamentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentWhereInput
    orderBy?: TournamentOrderByWithAggregationInput | TournamentOrderByWithAggregationInput[]
    by: TournamentScalarFieldEnum[] | TournamentScalarFieldEnum
    having?: TournamentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentCountAggregateInputType | true
    _avg?: TournamentAvgAggregateInputType
    _sum?: TournamentSumAggregateInputType
    _min?: TournamentMinAggregateInputType
    _max?: TournamentMaxAggregateInputType
  }

  export type TournamentGroupByOutputType = {
    ID: number
    Name: string
    CreationDate: Date
    WinnerID: number | null
    _count: TournamentCountAggregateOutputType | null
    _avg: TournamentAvgAggregateOutputType | null
    _sum: TournamentSumAggregateOutputType | null
    _min: TournamentMinAggregateOutputType | null
    _max: TournamentMaxAggregateOutputType | null
  }

  type GetTournamentGroupByPayload<T extends TournamentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentGroupByOutputType[P]>
        }
      >
    >


  export type TournamentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
    Winner?: boolean | Tournament$WinnerArgs<ExtArgs>
    Matches?: boolean | Tournament$MatchesArgs<ExtArgs>
    Users?: boolean | Tournament$UsersArgs<ExtArgs>
    TournamentUsers?: boolean | Tournament$TournamentUsersArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
    Winner?: boolean | Tournament$WinnerArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
    Winner?: boolean | Tournament$WinnerArgs<ExtArgs>
  }, ExtArgs["result"]["tournament"]>

  export type TournamentSelectScalar = {
    ID?: boolean
    Name?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
  }

  export type TournamentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Name" | "CreationDate" | "WinnerID", ExtArgs["result"]["tournament"]>
  export type TournamentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Winner?: boolean | Tournament$WinnerArgs<ExtArgs>
    Matches?: boolean | Tournament$MatchesArgs<ExtArgs>
    Users?: boolean | Tournament$UsersArgs<ExtArgs>
    TournamentUsers?: boolean | Tournament$TournamentUsersArgs<ExtArgs>
    _count?: boolean | TournamentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TournamentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Winner?: boolean | Tournament$WinnerArgs<ExtArgs>
  }
  export type TournamentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Winner?: boolean | Tournament$WinnerArgs<ExtArgs>
  }

  export type $TournamentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tournament"
    objects: {
      Winner: Prisma.$TournamentUserPayload<ExtArgs> | null
      Matches: Prisma.$TournamentMatchPayload<ExtArgs>[]
      Users: Prisma.$TournamentUserPayload<ExtArgs>[]
      TournamentUsers: Prisma.$TournamentUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Name: string
      CreationDate: Date
      WinnerID: number | null
    }, ExtArgs["result"]["tournament"]>
    composites: {}
  }

  type TournamentGetPayload<S extends boolean | null | undefined | TournamentDefaultArgs> = $Result.GetResult<Prisma.$TournamentPayload, S>

  type TournamentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TournamentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentCountAggregateInputType | true
    }

  export interface TournamentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tournament'], meta: { name: 'Tournament' } }
    /**
     * Find zero or one Tournament that matches the filter.
     * @param {TournamentFindUniqueArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentFindUniqueArgs>(args: SelectSubset<T, TournamentFindUniqueArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tournament that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TournamentFindUniqueOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentFindFirstArgs>(args?: SelectSubset<T, TournamentFindFirstArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tournament that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindFirstOrThrowArgs} args - Arguments to find a Tournament
     * @example
     * // Get one Tournament
     * const tournament = await prisma.tournament.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tournaments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tournaments
     * const tournaments = await prisma.tournament.findMany()
     * 
     * // Get first 10 Tournaments
     * const tournaments = await prisma.tournament.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tournamentWithIDOnly = await prisma.tournament.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends TournamentFindManyArgs>(args?: SelectSubset<T, TournamentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tournament.
     * @param {TournamentCreateArgs} args - Arguments to create a Tournament.
     * @example
     * // Create one Tournament
     * const Tournament = await prisma.tournament.create({
     *   data: {
     *     // ... data to create a Tournament
     *   }
     * })
     * 
     */
    create<T extends TournamentCreateArgs>(args: SelectSubset<T, TournamentCreateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tournaments.
     * @param {TournamentCreateManyArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentCreateManyArgs>(args?: SelectSubset<T, TournamentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tournaments and returns the data saved in the database.
     * @param {TournamentCreateManyAndReturnArgs} args - Arguments to create many Tournaments.
     * @example
     * // Create many Tournaments
     * const tournament = await prisma.tournament.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tournaments and only return the `ID`
     * const tournamentWithIDOnly = await prisma.tournament.createManyAndReturn({
     *   select: { ID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tournament.
     * @param {TournamentDeleteArgs} args - Arguments to delete one Tournament.
     * @example
     * // Delete one Tournament
     * const Tournament = await prisma.tournament.delete({
     *   where: {
     *     // ... filter to delete one Tournament
     *   }
     * })
     * 
     */
    delete<T extends TournamentDeleteArgs>(args: SelectSubset<T, TournamentDeleteArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tournament.
     * @param {TournamentUpdateArgs} args - Arguments to update one Tournament.
     * @example
     * // Update one Tournament
     * const tournament = await prisma.tournament.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentUpdateArgs>(args: SelectSubset<T, TournamentUpdateArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tournaments.
     * @param {TournamentDeleteManyArgs} args - Arguments to filter Tournaments to delete.
     * @example
     * // Delete a few Tournaments
     * const { count } = await prisma.tournament.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentDeleteManyArgs>(args?: SelectSubset<T, TournamentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentUpdateManyArgs>(args: SelectSubset<T, TournamentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tournaments and returns the data updated in the database.
     * @param {TournamentUpdateManyAndReturnArgs} args - Arguments to update many Tournaments.
     * @example
     * // Update many Tournaments
     * const tournament = await prisma.tournament.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tournaments and only return the `ID`
     * const tournamentWithIDOnly = await prisma.tournament.updateManyAndReturn({
     *   select: { ID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TournamentUpdateManyAndReturnArgs>(args: SelectSubset<T, TournamentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tournament.
     * @param {TournamentUpsertArgs} args - Arguments to update or create a Tournament.
     * @example
     * // Update or create a Tournament
     * const tournament = await prisma.tournament.upsert({
     *   create: {
     *     // ... data to create a Tournament
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tournament we want to update
     *   }
     * })
     */
    upsert<T extends TournamentUpsertArgs>(args: SelectSubset<T, TournamentUpsertArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tournaments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentCountArgs} args - Arguments to filter Tournaments to count.
     * @example
     * // Count the number of Tournaments
     * const count = await prisma.tournament.count({
     *   where: {
     *     // ... the filter for the Tournaments we want to count
     *   }
     * })
    **/
    count<T extends TournamentCountArgs>(
      args?: Subset<T, TournamentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentAggregateArgs>(args: Subset<T, TournamentAggregateArgs>): Prisma.PrismaPromise<GetTournamentAggregateType<T>>

    /**
     * Group by Tournament.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentGroupByArgs['orderBy'] }
        : { orderBy?: TournamentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tournament model
   */
  readonly fields: TournamentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tournament.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Winner<T extends Tournament$WinnerArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$WinnerArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Matches<T extends Tournament$MatchesArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$MatchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Users<T extends Tournament$UsersArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$UsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    TournamentUsers<T extends Tournament$TournamentUsersArgs<ExtArgs> = {}>(args?: Subset<T, Tournament$TournamentUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tournament model
   */
  interface TournamentFieldRefs {
    readonly ID: FieldRef<"Tournament", 'Int'>
    readonly Name: FieldRef<"Tournament", 'String'>
    readonly CreationDate: FieldRef<"Tournament", 'DateTime'>
    readonly WinnerID: FieldRef<"Tournament", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Tournament findUnique
   */
  export type TournamentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findUniqueOrThrow
   */
  export type TournamentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament findFirst
   */
  export type TournamentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findFirstOrThrow
   */
  export type TournamentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournament to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tournaments.
     */
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament findMany
   */
  export type TournamentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter, which Tournaments to fetch.
     */
    where?: TournamentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tournaments to fetch.
     */
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tournaments.
     */
    cursor?: TournamentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tournaments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tournaments.
     */
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * Tournament create
   */
  export type TournamentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to create a Tournament.
     */
    data: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
  }

  /**
   * Tournament createMany
   */
  export type TournamentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
  }

  /**
   * Tournament createManyAndReturn
   */
  export type TournamentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * The data used to create many Tournaments.
     */
    data: TournamentCreateManyInput | TournamentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tournament update
   */
  export type TournamentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The data needed to update a Tournament.
     */
    data: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
    /**
     * Choose, which Tournament to update.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament updateMany
   */
  export type TournamentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tournaments.
     */
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyInput>
    /**
     * Filter which Tournaments to update
     */
    where?: TournamentWhereInput
    /**
     * Limit how many Tournaments to update.
     */
    limit?: number
  }

  /**
   * Tournament updateManyAndReturn
   */
  export type TournamentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * The data used to update Tournaments.
     */
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyInput>
    /**
     * Filter which Tournaments to update
     */
    where?: TournamentWhereInput
    /**
     * Limit how many Tournaments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tournament upsert
   */
  export type TournamentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * The filter to search for the Tournament to update in case it exists.
     */
    where: TournamentWhereUniqueInput
    /**
     * In case the Tournament found by the `where` argument doesn't exist, create a new Tournament with this data.
     */
    create: XOR<TournamentCreateInput, TournamentUncheckedCreateInput>
    /**
     * In case the Tournament was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentUpdateInput, TournamentUncheckedUpdateInput>
  }

  /**
   * Tournament delete
   */
  export type TournamentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    /**
     * Filter which Tournament to delete.
     */
    where: TournamentWhereUniqueInput
  }

  /**
   * Tournament deleteMany
   */
  export type TournamentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tournaments to delete
     */
    where?: TournamentWhereInput
    /**
     * Limit how many Tournaments to delete.
     */
    limit?: number
  }

  /**
   * Tournament.Winner
   */
  export type Tournament$WinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    where?: TournamentUserWhereInput
  }

  /**
   * Tournament.Matches
   */
  export type Tournament$MatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    where?: TournamentMatchWhereInput
    orderBy?: TournamentMatchOrderByWithRelationInput | TournamentMatchOrderByWithRelationInput[]
    cursor?: TournamentMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentMatchScalarFieldEnum | TournamentMatchScalarFieldEnum[]
  }

  /**
   * Tournament.Users
   */
  export type Tournament$UsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    where?: TournamentUserWhereInput
    orderBy?: TournamentUserOrderByWithRelationInput | TournamentUserOrderByWithRelationInput[]
    cursor?: TournamentUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentUserScalarFieldEnum | TournamentUserScalarFieldEnum[]
  }

  /**
   * Tournament.TournamentUsers
   */
  export type Tournament$TournamentUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    where?: TournamentUserWhereInput
    orderBy?: TournamentUserOrderByWithRelationInput | TournamentUserOrderByWithRelationInput[]
    cursor?: TournamentUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentUserScalarFieldEnum | TournamentUserScalarFieldEnum[]
  }

  /**
   * Tournament without action
   */
  export type TournamentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
  }


  /**
   * Model TournamentMatch
   */

  export type AggregateTournamentMatch = {
    _count: TournamentMatchCountAggregateOutputType | null
    _avg: TournamentMatchAvgAggregateOutputType | null
    _sum: TournamentMatchSumAggregateOutputType | null
    _min: TournamentMatchMinAggregateOutputType | null
    _max: TournamentMatchMaxAggregateOutputType | null
  }

  export type TournamentMatchAvgAggregateOutputType = {
    ID: number | null
    TournamentID: number | null
    Player1ID: number | null
    Player2ID: number | null
    Player1Score: number | null
    Player2Score: number | null
    WinnerID: number | null
  }

  export type TournamentMatchSumAggregateOutputType = {
    ID: number | null
    TournamentID: number | null
    Player1ID: number | null
    Player2ID: number | null
    Player1Score: number | null
    Player2Score: number | null
    WinnerID: number | null
  }

  export type TournamentMatchMinAggregateOutputType = {
    ID: number | null
    TournamentID: number | null
    Player1ID: number | null
    Player2ID: number | null
    Player1Score: number | null
    Player2Score: number | null
    CreationDate: Date | null
    WinnerID: number | null
  }

  export type TournamentMatchMaxAggregateOutputType = {
    ID: number | null
    TournamentID: number | null
    Player1ID: number | null
    Player2ID: number | null
    Player1Score: number | null
    Player2Score: number | null
    CreationDate: Date | null
    WinnerID: number | null
  }

  export type TournamentMatchCountAggregateOutputType = {
    ID: number
    TournamentID: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: number
    WinnerID: number
    _all: number
  }


  export type TournamentMatchAvgAggregateInputType = {
    ID?: true
    TournamentID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    WinnerID?: true
  }

  export type TournamentMatchSumAggregateInputType = {
    ID?: true
    TournamentID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    WinnerID?: true
  }

  export type TournamentMatchMinAggregateInputType = {
    ID?: true
    TournamentID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    CreationDate?: true
    WinnerID?: true
  }

  export type TournamentMatchMaxAggregateInputType = {
    ID?: true
    TournamentID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    CreationDate?: true
    WinnerID?: true
  }

  export type TournamentMatchCountAggregateInputType = {
    ID?: true
    TournamentID?: true
    Player1ID?: true
    Player2ID?: true
    Player1Score?: true
    Player2Score?: true
    CreationDate?: true
    WinnerID?: true
    _all?: true
  }

  export type TournamentMatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentMatch to aggregate.
     */
    where?: TournamentMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentMatches to fetch.
     */
    orderBy?: TournamentMatchOrderByWithRelationInput | TournamentMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentMatches
    **/
    _count?: true | TournamentMatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentMatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentMatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentMatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentMatchMaxAggregateInputType
  }

  export type GetTournamentMatchAggregateType<T extends TournamentMatchAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamentMatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentMatch[P]>
      : GetScalarType<T[P], AggregateTournamentMatch[P]>
  }




  export type TournamentMatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentMatchWhereInput
    orderBy?: TournamentMatchOrderByWithAggregationInput | TournamentMatchOrderByWithAggregationInput[]
    by: TournamentMatchScalarFieldEnum[] | TournamentMatchScalarFieldEnum
    having?: TournamentMatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentMatchCountAggregateInputType | true
    _avg?: TournamentMatchAvgAggregateInputType
    _sum?: TournamentMatchSumAggregateInputType
    _min?: TournamentMatchMinAggregateInputType
    _max?: TournamentMatchMaxAggregateInputType
  }

  export type TournamentMatchGroupByOutputType = {
    ID: number
    TournamentID: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date
    WinnerID: number | null
    _count: TournamentMatchCountAggregateOutputType | null
    _avg: TournamentMatchAvgAggregateOutputType | null
    _sum: TournamentMatchSumAggregateOutputType | null
    _min: TournamentMatchMinAggregateOutputType | null
    _max: TournamentMatchMaxAggregateOutputType | null
  }

  type GetTournamentMatchGroupByPayload<T extends TournamentMatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentMatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentMatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentMatchGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentMatchGroupByOutputType[P]>
        }
      >
    >


  export type TournamentMatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    TournamentID?: boolean
    Player1ID?: boolean
    Player2ID?: boolean
    Player1Score?: boolean
    Player2Score?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    Player1?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Player2?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Winner?: boolean | TournamentMatch$WinnerArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentMatch"]>

  export type TournamentMatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    TournamentID?: boolean
    Player1ID?: boolean
    Player2ID?: boolean
    Player1Score?: boolean
    Player2Score?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    Player1?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Player2?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Winner?: boolean | TournamentMatch$WinnerArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentMatch"]>

  export type TournamentMatchSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    TournamentID?: boolean
    Player1ID?: boolean
    Player2ID?: boolean
    Player1Score?: boolean
    Player2Score?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    Player1?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Player2?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Winner?: boolean | TournamentMatch$WinnerArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentMatch"]>

  export type TournamentMatchSelectScalar = {
    ID?: boolean
    TournamentID?: boolean
    Player1ID?: boolean
    Player2ID?: boolean
    Player1Score?: boolean
    Player2Score?: boolean
    CreationDate?: boolean
    WinnerID?: boolean
  }

  export type TournamentMatchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "TournamentID" | "Player1ID" | "Player2ID" | "Player1Score" | "Player2Score" | "CreationDate" | "WinnerID", ExtArgs["result"]["tournamentMatch"]>
  export type TournamentMatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    Player1?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Player2?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Winner?: boolean | TournamentMatch$WinnerArgs<ExtArgs>
  }
  export type TournamentMatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    Player1?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Player2?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Winner?: boolean | TournamentMatch$WinnerArgs<ExtArgs>
  }
  export type TournamentMatchIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    Player1?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Player2?: boolean | TournamentUserDefaultArgs<ExtArgs>
    Winner?: boolean | TournamentMatch$WinnerArgs<ExtArgs>
  }

  export type $TournamentMatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TournamentMatch"
    objects: {
      Tournament: Prisma.$TournamentPayload<ExtArgs>
      Player1: Prisma.$TournamentUserPayload<ExtArgs>
      Player2: Prisma.$TournamentUserPayload<ExtArgs>
      Winner: Prisma.$TournamentUserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      TournamentID: number
      Player1ID: number
      Player2ID: number
      Player1Score: number
      Player2Score: number
      CreationDate: Date
      WinnerID: number | null
    }, ExtArgs["result"]["tournamentMatch"]>
    composites: {}
  }

  type TournamentMatchGetPayload<S extends boolean | null | undefined | TournamentMatchDefaultArgs> = $Result.GetResult<Prisma.$TournamentMatchPayload, S>

  type TournamentMatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TournamentMatchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentMatchCountAggregateInputType | true
    }

  export interface TournamentMatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TournamentMatch'], meta: { name: 'TournamentMatch' } }
    /**
     * Find zero or one TournamentMatch that matches the filter.
     * @param {TournamentMatchFindUniqueArgs} args - Arguments to find a TournamentMatch
     * @example
     * // Get one TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentMatchFindUniqueArgs>(args: SelectSubset<T, TournamentMatchFindUniqueArgs<ExtArgs>>): Prisma__TournamentMatchClient<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TournamentMatch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TournamentMatchFindUniqueOrThrowArgs} args - Arguments to find a TournamentMatch
     * @example
     * // Get one TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentMatchFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentMatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentMatchClient<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentMatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentMatchFindFirstArgs} args - Arguments to find a TournamentMatch
     * @example
     * // Get one TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentMatchFindFirstArgs>(args?: SelectSubset<T, TournamentMatchFindFirstArgs<ExtArgs>>): Prisma__TournamentMatchClient<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentMatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentMatchFindFirstOrThrowArgs} args - Arguments to find a TournamentMatch
     * @example
     * // Get one TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentMatchFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentMatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentMatchClient<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TournamentMatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentMatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentMatches
     * const tournamentMatches = await prisma.tournamentMatch.findMany()
     * 
     * // Get first 10 TournamentMatches
     * const tournamentMatches = await prisma.tournamentMatch.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tournamentMatchWithIDOnly = await prisma.tournamentMatch.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends TournamentMatchFindManyArgs>(args?: SelectSubset<T, TournamentMatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TournamentMatch.
     * @param {TournamentMatchCreateArgs} args - Arguments to create a TournamentMatch.
     * @example
     * // Create one TournamentMatch
     * const TournamentMatch = await prisma.tournamentMatch.create({
     *   data: {
     *     // ... data to create a TournamentMatch
     *   }
     * })
     * 
     */
    create<T extends TournamentMatchCreateArgs>(args: SelectSubset<T, TournamentMatchCreateArgs<ExtArgs>>): Prisma__TournamentMatchClient<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TournamentMatches.
     * @param {TournamentMatchCreateManyArgs} args - Arguments to create many TournamentMatches.
     * @example
     * // Create many TournamentMatches
     * const tournamentMatch = await prisma.tournamentMatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentMatchCreateManyArgs>(args?: SelectSubset<T, TournamentMatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TournamentMatches and returns the data saved in the database.
     * @param {TournamentMatchCreateManyAndReturnArgs} args - Arguments to create many TournamentMatches.
     * @example
     * // Create many TournamentMatches
     * const tournamentMatch = await prisma.tournamentMatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TournamentMatches and only return the `ID`
     * const tournamentMatchWithIDOnly = await prisma.tournamentMatch.createManyAndReturn({
     *   select: { ID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentMatchCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentMatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TournamentMatch.
     * @param {TournamentMatchDeleteArgs} args - Arguments to delete one TournamentMatch.
     * @example
     * // Delete one TournamentMatch
     * const TournamentMatch = await prisma.tournamentMatch.delete({
     *   where: {
     *     // ... filter to delete one TournamentMatch
     *   }
     * })
     * 
     */
    delete<T extends TournamentMatchDeleteArgs>(args: SelectSubset<T, TournamentMatchDeleteArgs<ExtArgs>>): Prisma__TournamentMatchClient<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TournamentMatch.
     * @param {TournamentMatchUpdateArgs} args - Arguments to update one TournamentMatch.
     * @example
     * // Update one TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentMatchUpdateArgs>(args: SelectSubset<T, TournamentMatchUpdateArgs<ExtArgs>>): Prisma__TournamentMatchClient<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TournamentMatches.
     * @param {TournamentMatchDeleteManyArgs} args - Arguments to filter TournamentMatches to delete.
     * @example
     * // Delete a few TournamentMatches
     * const { count } = await prisma.tournamentMatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentMatchDeleteManyArgs>(args?: SelectSubset<T, TournamentMatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentMatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentMatches
     * const tournamentMatch = await prisma.tournamentMatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentMatchUpdateManyArgs>(args: SelectSubset<T, TournamentMatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentMatches and returns the data updated in the database.
     * @param {TournamentMatchUpdateManyAndReturnArgs} args - Arguments to update many TournamentMatches.
     * @example
     * // Update many TournamentMatches
     * const tournamentMatch = await prisma.tournamentMatch.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TournamentMatches and only return the `ID`
     * const tournamentMatchWithIDOnly = await prisma.tournamentMatch.updateManyAndReturn({
     *   select: { ID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TournamentMatchUpdateManyAndReturnArgs>(args: SelectSubset<T, TournamentMatchUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TournamentMatch.
     * @param {TournamentMatchUpsertArgs} args - Arguments to update or create a TournamentMatch.
     * @example
     * // Update or create a TournamentMatch
     * const tournamentMatch = await prisma.tournamentMatch.upsert({
     *   create: {
     *     // ... data to create a TournamentMatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentMatch we want to update
     *   }
     * })
     */
    upsert<T extends TournamentMatchUpsertArgs>(args: SelectSubset<T, TournamentMatchUpsertArgs<ExtArgs>>): Prisma__TournamentMatchClient<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TournamentMatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentMatchCountArgs} args - Arguments to filter TournamentMatches to count.
     * @example
     * // Count the number of TournamentMatches
     * const count = await prisma.tournamentMatch.count({
     *   where: {
     *     // ... the filter for the TournamentMatches we want to count
     *   }
     * })
    **/
    count<T extends TournamentMatchCountArgs>(
      args?: Subset<T, TournamentMatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentMatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentMatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentMatchAggregateArgs>(args: Subset<T, TournamentMatchAggregateArgs>): Prisma.PrismaPromise<GetTournamentMatchAggregateType<T>>

    /**
     * Group by TournamentMatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentMatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentMatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentMatchGroupByArgs['orderBy'] }
        : { orderBy?: TournamentMatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentMatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentMatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TournamentMatch model
   */
  readonly fields: TournamentMatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentMatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentMatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Tournament<T extends TournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentDefaultArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Player1<T extends TournamentUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentUserDefaultArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Player2<T extends TournamentUserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentUserDefaultArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Winner<T extends TournamentMatch$WinnerArgs<ExtArgs> = {}>(args?: Subset<T, TournamentMatch$WinnerArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TournamentMatch model
   */
  interface TournamentMatchFieldRefs {
    readonly ID: FieldRef<"TournamentMatch", 'Int'>
    readonly TournamentID: FieldRef<"TournamentMatch", 'Int'>
    readonly Player1ID: FieldRef<"TournamentMatch", 'Int'>
    readonly Player2ID: FieldRef<"TournamentMatch", 'Int'>
    readonly Player1Score: FieldRef<"TournamentMatch", 'Int'>
    readonly Player2Score: FieldRef<"TournamentMatch", 'Int'>
    readonly CreationDate: FieldRef<"TournamentMatch", 'DateTime'>
    readonly WinnerID: FieldRef<"TournamentMatch", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TournamentMatch findUnique
   */
  export type TournamentMatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    /**
     * Filter, which TournamentMatch to fetch.
     */
    where: TournamentMatchWhereUniqueInput
  }

  /**
   * TournamentMatch findUniqueOrThrow
   */
  export type TournamentMatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    /**
     * Filter, which TournamentMatch to fetch.
     */
    where: TournamentMatchWhereUniqueInput
  }

  /**
   * TournamentMatch findFirst
   */
  export type TournamentMatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    /**
     * Filter, which TournamentMatch to fetch.
     */
    where?: TournamentMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentMatches to fetch.
     */
    orderBy?: TournamentMatchOrderByWithRelationInput | TournamentMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentMatches.
     */
    cursor?: TournamentMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentMatches.
     */
    distinct?: TournamentMatchScalarFieldEnum | TournamentMatchScalarFieldEnum[]
  }

  /**
   * TournamentMatch findFirstOrThrow
   */
  export type TournamentMatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    /**
     * Filter, which TournamentMatch to fetch.
     */
    where?: TournamentMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentMatches to fetch.
     */
    orderBy?: TournamentMatchOrderByWithRelationInput | TournamentMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentMatches.
     */
    cursor?: TournamentMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentMatches.
     */
    distinct?: TournamentMatchScalarFieldEnum | TournamentMatchScalarFieldEnum[]
  }

  /**
   * TournamentMatch findMany
   */
  export type TournamentMatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    /**
     * Filter, which TournamentMatches to fetch.
     */
    where?: TournamentMatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentMatches to fetch.
     */
    orderBy?: TournamentMatchOrderByWithRelationInput | TournamentMatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentMatches.
     */
    cursor?: TournamentMatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentMatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentMatches.
     */
    skip?: number
    distinct?: TournamentMatchScalarFieldEnum | TournamentMatchScalarFieldEnum[]
  }

  /**
   * TournamentMatch create
   */
  export type TournamentMatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    /**
     * The data needed to create a TournamentMatch.
     */
    data: XOR<TournamentMatchCreateInput, TournamentMatchUncheckedCreateInput>
  }

  /**
   * TournamentMatch createMany
   */
  export type TournamentMatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TournamentMatches.
     */
    data: TournamentMatchCreateManyInput | TournamentMatchCreateManyInput[]
  }

  /**
   * TournamentMatch createManyAndReturn
   */
  export type TournamentMatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * The data used to create many TournamentMatches.
     */
    data: TournamentMatchCreateManyInput | TournamentMatchCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentMatch update
   */
  export type TournamentMatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    /**
     * The data needed to update a TournamentMatch.
     */
    data: XOR<TournamentMatchUpdateInput, TournamentMatchUncheckedUpdateInput>
    /**
     * Choose, which TournamentMatch to update.
     */
    where: TournamentMatchWhereUniqueInput
  }

  /**
   * TournamentMatch updateMany
   */
  export type TournamentMatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TournamentMatches.
     */
    data: XOR<TournamentMatchUpdateManyMutationInput, TournamentMatchUncheckedUpdateManyInput>
    /**
     * Filter which TournamentMatches to update
     */
    where?: TournamentMatchWhereInput
    /**
     * Limit how many TournamentMatches to update.
     */
    limit?: number
  }

  /**
   * TournamentMatch updateManyAndReturn
   */
  export type TournamentMatchUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * The data used to update TournamentMatches.
     */
    data: XOR<TournamentMatchUpdateManyMutationInput, TournamentMatchUncheckedUpdateManyInput>
    /**
     * Filter which TournamentMatches to update
     */
    where?: TournamentMatchWhereInput
    /**
     * Limit how many TournamentMatches to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentMatch upsert
   */
  export type TournamentMatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    /**
     * The filter to search for the TournamentMatch to update in case it exists.
     */
    where: TournamentMatchWhereUniqueInput
    /**
     * In case the TournamentMatch found by the `where` argument doesn't exist, create a new TournamentMatch with this data.
     */
    create: XOR<TournamentMatchCreateInput, TournamentMatchUncheckedCreateInput>
    /**
     * In case the TournamentMatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentMatchUpdateInput, TournamentMatchUncheckedUpdateInput>
  }

  /**
   * TournamentMatch delete
   */
  export type TournamentMatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    /**
     * Filter which TournamentMatch to delete.
     */
    where: TournamentMatchWhereUniqueInput
  }

  /**
   * TournamentMatch deleteMany
   */
  export type TournamentMatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentMatches to delete
     */
    where?: TournamentMatchWhereInput
    /**
     * Limit how many TournamentMatches to delete.
     */
    limit?: number
  }

  /**
   * TournamentMatch.Winner
   */
  export type TournamentMatch$WinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    where?: TournamentUserWhereInput
  }

  /**
   * TournamentMatch without action
   */
  export type TournamentMatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
  }


  /**
   * Model TournamentUser
   */

  export type AggregateTournamentUser = {
    _count: TournamentUserCountAggregateOutputType | null
    _avg: TournamentUserAvgAggregateOutputType | null
    _sum: TournamentUserSumAggregateOutputType | null
    _min: TournamentUserMinAggregateOutputType | null
    _max: TournamentUserMaxAggregateOutputType | null
  }

  export type TournamentUserAvgAggregateOutputType = {
    ID: number | null
    UserID: number | null
    TournamentID: number | null
  }

  export type TournamentUserSumAggregateOutputType = {
    ID: number | null
    UserID: number | null
    TournamentID: number | null
  }

  export type TournamentUserMinAggregateOutputType = {
    ID: number | null
    Alias: string | null
    UserID: number | null
    TournamentID: number | null
  }

  export type TournamentUserMaxAggregateOutputType = {
    ID: number | null
    Alias: string | null
    UserID: number | null
    TournamentID: number | null
  }

  export type TournamentUserCountAggregateOutputType = {
    ID: number
    Alias: number
    UserID: number
    TournamentID: number
    _all: number
  }


  export type TournamentUserAvgAggregateInputType = {
    ID?: true
    UserID?: true
    TournamentID?: true
  }

  export type TournamentUserSumAggregateInputType = {
    ID?: true
    UserID?: true
    TournamentID?: true
  }

  export type TournamentUserMinAggregateInputType = {
    ID?: true
    Alias?: true
    UserID?: true
    TournamentID?: true
  }

  export type TournamentUserMaxAggregateInputType = {
    ID?: true
    Alias?: true
    UserID?: true
    TournamentID?: true
  }

  export type TournamentUserCountAggregateInputType = {
    ID?: true
    Alias?: true
    UserID?: true
    TournamentID?: true
    _all?: true
  }

  export type TournamentUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentUser to aggregate.
     */
    where?: TournamentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentUsers to fetch.
     */
    orderBy?: TournamentUserOrderByWithRelationInput | TournamentUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TournamentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TournamentUsers
    **/
    _count?: true | TournamentUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TournamentUserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TournamentUserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TournamentUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TournamentUserMaxAggregateInputType
  }

  export type GetTournamentUserAggregateType<T extends TournamentUserAggregateArgs> = {
        [P in keyof T & keyof AggregateTournamentUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTournamentUser[P]>
      : GetScalarType<T[P], AggregateTournamentUser[P]>
  }




  export type TournamentUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TournamentUserWhereInput
    orderBy?: TournamentUserOrderByWithAggregationInput | TournamentUserOrderByWithAggregationInput[]
    by: TournamentUserScalarFieldEnum[] | TournamentUserScalarFieldEnum
    having?: TournamentUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TournamentUserCountAggregateInputType | true
    _avg?: TournamentUserAvgAggregateInputType
    _sum?: TournamentUserSumAggregateInputType
    _min?: TournamentUserMinAggregateInputType
    _max?: TournamentUserMaxAggregateInputType
  }

  export type TournamentUserGroupByOutputType = {
    ID: number
    Alias: string
    UserID: number
    TournamentID: number
    _count: TournamentUserCountAggregateOutputType | null
    _avg: TournamentUserAvgAggregateOutputType | null
    _sum: TournamentUserSumAggregateOutputType | null
    _min: TournamentUserMinAggregateOutputType | null
    _max: TournamentUserMaxAggregateOutputType | null
  }

  type GetTournamentUserGroupByPayload<T extends TournamentUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TournamentUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TournamentUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TournamentUserGroupByOutputType[P]>
            : GetScalarType<T[P], TournamentUserGroupByOutputType[P]>
        }
      >
    >


  export type TournamentUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Alias?: boolean
    UserID?: boolean
    TournamentID?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    matchesAsPlayer1?: boolean | TournamentUser$matchesAsPlayer1Args<ExtArgs>
    matchesAsPlayer2?: boolean | TournamentUser$matchesAsPlayer2Args<ExtArgs>
    matchesAsWinner?: boolean | TournamentUser$matchesAsWinnerArgs<ExtArgs>
    tournaments?: boolean | TournamentUser$tournamentsArgs<ExtArgs>
    tournamentsAsWinner?: boolean | TournamentUser$tournamentsAsWinnerArgs<ExtArgs>
    _count?: boolean | TournamentUserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentUser"]>

  export type TournamentUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Alias?: boolean
    UserID?: boolean
    TournamentID?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentUser"]>

  export type TournamentUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Alias?: boolean
    UserID?: boolean
    TournamentID?: boolean
    User?: boolean | UserDefaultArgs<ExtArgs>
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tournamentUser"]>

  export type TournamentUserSelectScalar = {
    ID?: boolean
    Alias?: boolean
    UserID?: boolean
    TournamentID?: boolean
  }

  export type TournamentUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ID" | "Alias" | "UserID" | "TournamentID", ExtArgs["result"]["tournamentUser"]>
  export type TournamentUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
    matchesAsPlayer1?: boolean | TournamentUser$matchesAsPlayer1Args<ExtArgs>
    matchesAsPlayer2?: boolean | TournamentUser$matchesAsPlayer2Args<ExtArgs>
    matchesAsWinner?: boolean | TournamentUser$matchesAsWinnerArgs<ExtArgs>
    tournaments?: boolean | TournamentUser$tournamentsArgs<ExtArgs>
    tournamentsAsWinner?: boolean | TournamentUser$tournamentsAsWinnerArgs<ExtArgs>
    _count?: boolean | TournamentUserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TournamentUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
  }
  export type TournamentUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserDefaultArgs<ExtArgs>
    Tournament?: boolean | TournamentDefaultArgs<ExtArgs>
  }

  export type $TournamentUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TournamentUser"
    objects: {
      User: Prisma.$UserPayload<ExtArgs>
      Tournament: Prisma.$TournamentPayload<ExtArgs>
      matchesAsPlayer1: Prisma.$TournamentMatchPayload<ExtArgs>[]
      matchesAsPlayer2: Prisma.$TournamentMatchPayload<ExtArgs>[]
      matchesAsWinner: Prisma.$TournamentMatchPayload<ExtArgs>[]
      tournaments: Prisma.$TournamentPayload<ExtArgs>[]
      tournamentsAsWinner: Prisma.$TournamentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Alias: string
      UserID: number
      TournamentID: number
    }, ExtArgs["result"]["tournamentUser"]>
    composites: {}
  }

  type TournamentUserGetPayload<S extends boolean | null | undefined | TournamentUserDefaultArgs> = $Result.GetResult<Prisma.$TournamentUserPayload, S>

  type TournamentUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TournamentUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TournamentUserCountAggregateInputType | true
    }

  export interface TournamentUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TournamentUser'], meta: { name: 'TournamentUser' } }
    /**
     * Find zero or one TournamentUser that matches the filter.
     * @param {TournamentUserFindUniqueArgs} args - Arguments to find a TournamentUser
     * @example
     * // Get one TournamentUser
     * const tournamentUser = await prisma.tournamentUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TournamentUserFindUniqueArgs>(args: SelectSubset<T, TournamentUserFindUniqueArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TournamentUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TournamentUserFindUniqueOrThrowArgs} args - Arguments to find a TournamentUser
     * @example
     * // Get one TournamentUser
     * const tournamentUser = await prisma.tournamentUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TournamentUserFindUniqueOrThrowArgs>(args: SelectSubset<T, TournamentUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUserFindFirstArgs} args - Arguments to find a TournamentUser
     * @example
     * // Get one TournamentUser
     * const tournamentUser = await prisma.tournamentUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TournamentUserFindFirstArgs>(args?: SelectSubset<T, TournamentUserFindFirstArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TournamentUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUserFindFirstOrThrowArgs} args - Arguments to find a TournamentUser
     * @example
     * // Get one TournamentUser
     * const tournamentUser = await prisma.tournamentUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TournamentUserFindFirstOrThrowArgs>(args?: SelectSubset<T, TournamentUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TournamentUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TournamentUsers
     * const tournamentUsers = await prisma.tournamentUser.findMany()
     * 
     * // Get first 10 TournamentUsers
     * const tournamentUsers = await prisma.tournamentUser.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const tournamentUserWithIDOnly = await prisma.tournamentUser.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends TournamentUserFindManyArgs>(args?: SelectSubset<T, TournamentUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TournamentUser.
     * @param {TournamentUserCreateArgs} args - Arguments to create a TournamentUser.
     * @example
     * // Create one TournamentUser
     * const TournamentUser = await prisma.tournamentUser.create({
     *   data: {
     *     // ... data to create a TournamentUser
     *   }
     * })
     * 
     */
    create<T extends TournamentUserCreateArgs>(args: SelectSubset<T, TournamentUserCreateArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TournamentUsers.
     * @param {TournamentUserCreateManyArgs} args - Arguments to create many TournamentUsers.
     * @example
     * // Create many TournamentUsers
     * const tournamentUser = await prisma.tournamentUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TournamentUserCreateManyArgs>(args?: SelectSubset<T, TournamentUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TournamentUsers and returns the data saved in the database.
     * @param {TournamentUserCreateManyAndReturnArgs} args - Arguments to create many TournamentUsers.
     * @example
     * // Create many TournamentUsers
     * const tournamentUser = await prisma.tournamentUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TournamentUsers and only return the `ID`
     * const tournamentUserWithIDOnly = await prisma.tournamentUser.createManyAndReturn({
     *   select: { ID: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TournamentUserCreateManyAndReturnArgs>(args?: SelectSubset<T, TournamentUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TournamentUser.
     * @param {TournamentUserDeleteArgs} args - Arguments to delete one TournamentUser.
     * @example
     * // Delete one TournamentUser
     * const TournamentUser = await prisma.tournamentUser.delete({
     *   where: {
     *     // ... filter to delete one TournamentUser
     *   }
     * })
     * 
     */
    delete<T extends TournamentUserDeleteArgs>(args: SelectSubset<T, TournamentUserDeleteArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TournamentUser.
     * @param {TournamentUserUpdateArgs} args - Arguments to update one TournamentUser.
     * @example
     * // Update one TournamentUser
     * const tournamentUser = await prisma.tournamentUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TournamentUserUpdateArgs>(args: SelectSubset<T, TournamentUserUpdateArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TournamentUsers.
     * @param {TournamentUserDeleteManyArgs} args - Arguments to filter TournamentUsers to delete.
     * @example
     * // Delete a few TournamentUsers
     * const { count } = await prisma.tournamentUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TournamentUserDeleteManyArgs>(args?: SelectSubset<T, TournamentUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TournamentUsers
     * const tournamentUser = await prisma.tournamentUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TournamentUserUpdateManyArgs>(args: SelectSubset<T, TournamentUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TournamentUsers and returns the data updated in the database.
     * @param {TournamentUserUpdateManyAndReturnArgs} args - Arguments to update many TournamentUsers.
     * @example
     * // Update many TournamentUsers
     * const tournamentUser = await prisma.tournamentUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TournamentUsers and only return the `ID`
     * const tournamentUserWithIDOnly = await prisma.tournamentUser.updateManyAndReturn({
     *   select: { ID: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TournamentUserUpdateManyAndReturnArgs>(args: SelectSubset<T, TournamentUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TournamentUser.
     * @param {TournamentUserUpsertArgs} args - Arguments to update or create a TournamentUser.
     * @example
     * // Update or create a TournamentUser
     * const tournamentUser = await prisma.tournamentUser.upsert({
     *   create: {
     *     // ... data to create a TournamentUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TournamentUser we want to update
     *   }
     * })
     */
    upsert<T extends TournamentUserUpsertArgs>(args: SelectSubset<T, TournamentUserUpsertArgs<ExtArgs>>): Prisma__TournamentUserClient<$Result.GetResult<Prisma.$TournamentUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TournamentUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUserCountArgs} args - Arguments to filter TournamentUsers to count.
     * @example
     * // Count the number of TournamentUsers
     * const count = await prisma.tournamentUser.count({
     *   where: {
     *     // ... the filter for the TournamentUsers we want to count
     *   }
     * })
    **/
    count<T extends TournamentUserCountArgs>(
      args?: Subset<T, TournamentUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TournamentUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TournamentUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TournamentUserAggregateArgs>(args: Subset<T, TournamentUserAggregateArgs>): Prisma.PrismaPromise<GetTournamentUserAggregateType<T>>

    /**
     * Group by TournamentUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TournamentUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TournamentUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TournamentUserGroupByArgs['orderBy'] }
        : { orderBy?: TournamentUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TournamentUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTournamentUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TournamentUser model
   */
  readonly fields: TournamentUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TournamentUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TournamentUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Tournament<T extends TournamentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TournamentDefaultArgs<ExtArgs>>): Prisma__TournamentClient<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    matchesAsPlayer1<T extends TournamentUser$matchesAsPlayer1Args<ExtArgs> = {}>(args?: Subset<T, TournamentUser$matchesAsPlayer1Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchesAsPlayer2<T extends TournamentUser$matchesAsPlayer2Args<ExtArgs> = {}>(args?: Subset<T, TournamentUser$matchesAsPlayer2Args<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    matchesAsWinner<T extends TournamentUser$matchesAsWinnerArgs<ExtArgs> = {}>(args?: Subset<T, TournamentUser$matchesAsWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentMatchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournaments<T extends TournamentUser$tournamentsArgs<ExtArgs> = {}>(args?: Subset<T, TournamentUser$tournamentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tournamentsAsWinner<T extends TournamentUser$tournamentsAsWinnerArgs<ExtArgs> = {}>(args?: Subset<T, TournamentUser$tournamentsAsWinnerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TournamentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TournamentUser model
   */
  interface TournamentUserFieldRefs {
    readonly ID: FieldRef<"TournamentUser", 'Int'>
    readonly Alias: FieldRef<"TournamentUser", 'String'>
    readonly UserID: FieldRef<"TournamentUser", 'Int'>
    readonly TournamentID: FieldRef<"TournamentUser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TournamentUser findUnique
   */
  export type TournamentUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    /**
     * Filter, which TournamentUser to fetch.
     */
    where: TournamentUserWhereUniqueInput
  }

  /**
   * TournamentUser findUniqueOrThrow
   */
  export type TournamentUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    /**
     * Filter, which TournamentUser to fetch.
     */
    where: TournamentUserWhereUniqueInput
  }

  /**
   * TournamentUser findFirst
   */
  export type TournamentUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    /**
     * Filter, which TournamentUser to fetch.
     */
    where?: TournamentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentUsers to fetch.
     */
    orderBy?: TournamentUserOrderByWithRelationInput | TournamentUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentUsers.
     */
    cursor?: TournamentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentUsers.
     */
    distinct?: TournamentUserScalarFieldEnum | TournamentUserScalarFieldEnum[]
  }

  /**
   * TournamentUser findFirstOrThrow
   */
  export type TournamentUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    /**
     * Filter, which TournamentUser to fetch.
     */
    where?: TournamentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentUsers to fetch.
     */
    orderBy?: TournamentUserOrderByWithRelationInput | TournamentUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TournamentUsers.
     */
    cursor?: TournamentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TournamentUsers.
     */
    distinct?: TournamentUserScalarFieldEnum | TournamentUserScalarFieldEnum[]
  }

  /**
   * TournamentUser findMany
   */
  export type TournamentUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    /**
     * Filter, which TournamentUsers to fetch.
     */
    where?: TournamentUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TournamentUsers to fetch.
     */
    orderBy?: TournamentUserOrderByWithRelationInput | TournamentUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TournamentUsers.
     */
    cursor?: TournamentUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TournamentUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TournamentUsers.
     */
    skip?: number
    distinct?: TournamentUserScalarFieldEnum | TournamentUserScalarFieldEnum[]
  }

  /**
   * TournamentUser create
   */
  export type TournamentUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    /**
     * The data needed to create a TournamentUser.
     */
    data: XOR<TournamentUserCreateInput, TournamentUserUncheckedCreateInput>
  }

  /**
   * TournamentUser createMany
   */
  export type TournamentUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TournamentUsers.
     */
    data: TournamentUserCreateManyInput | TournamentUserCreateManyInput[]
  }

  /**
   * TournamentUser createManyAndReturn
   */
  export type TournamentUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * The data used to create many TournamentUsers.
     */
    data: TournamentUserCreateManyInput | TournamentUserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentUser update
   */
  export type TournamentUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    /**
     * The data needed to update a TournamentUser.
     */
    data: XOR<TournamentUserUpdateInput, TournamentUserUncheckedUpdateInput>
    /**
     * Choose, which TournamentUser to update.
     */
    where: TournamentUserWhereUniqueInput
  }

  /**
   * TournamentUser updateMany
   */
  export type TournamentUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TournamentUsers.
     */
    data: XOR<TournamentUserUpdateManyMutationInput, TournamentUserUncheckedUpdateManyInput>
    /**
     * Filter which TournamentUsers to update
     */
    where?: TournamentUserWhereInput
    /**
     * Limit how many TournamentUsers to update.
     */
    limit?: number
  }

  /**
   * TournamentUser updateManyAndReturn
   */
  export type TournamentUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * The data used to update TournamentUsers.
     */
    data: XOR<TournamentUserUpdateManyMutationInput, TournamentUserUncheckedUpdateManyInput>
    /**
     * Filter which TournamentUsers to update
     */
    where?: TournamentUserWhereInput
    /**
     * Limit how many TournamentUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TournamentUser upsert
   */
  export type TournamentUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    /**
     * The filter to search for the TournamentUser to update in case it exists.
     */
    where: TournamentUserWhereUniqueInput
    /**
     * In case the TournamentUser found by the `where` argument doesn't exist, create a new TournamentUser with this data.
     */
    create: XOR<TournamentUserCreateInput, TournamentUserUncheckedCreateInput>
    /**
     * In case the TournamentUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TournamentUserUpdateInput, TournamentUserUncheckedUpdateInput>
  }

  /**
   * TournamentUser delete
   */
  export type TournamentUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
    /**
     * Filter which TournamentUser to delete.
     */
    where: TournamentUserWhereUniqueInput
  }

  /**
   * TournamentUser deleteMany
   */
  export type TournamentUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TournamentUsers to delete
     */
    where?: TournamentUserWhereInput
    /**
     * Limit how many TournamentUsers to delete.
     */
    limit?: number
  }

  /**
   * TournamentUser.matchesAsPlayer1
   */
  export type TournamentUser$matchesAsPlayer1Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    where?: TournamentMatchWhereInput
    orderBy?: TournamentMatchOrderByWithRelationInput | TournamentMatchOrderByWithRelationInput[]
    cursor?: TournamentMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentMatchScalarFieldEnum | TournamentMatchScalarFieldEnum[]
  }

  /**
   * TournamentUser.matchesAsPlayer2
   */
  export type TournamentUser$matchesAsPlayer2Args<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    where?: TournamentMatchWhereInput
    orderBy?: TournamentMatchOrderByWithRelationInput | TournamentMatchOrderByWithRelationInput[]
    cursor?: TournamentMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentMatchScalarFieldEnum | TournamentMatchScalarFieldEnum[]
  }

  /**
   * TournamentUser.matchesAsWinner
   */
  export type TournamentUser$matchesAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentMatch
     */
    select?: TournamentMatchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentMatch
     */
    omit?: TournamentMatchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentMatchInclude<ExtArgs> | null
    where?: TournamentMatchWhereInput
    orderBy?: TournamentMatchOrderByWithRelationInput | TournamentMatchOrderByWithRelationInput[]
    cursor?: TournamentMatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentMatchScalarFieldEnum | TournamentMatchScalarFieldEnum[]
  }

  /**
   * TournamentUser.tournaments
   */
  export type TournamentUser$tournamentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    where?: TournamentWhereInput
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    cursor?: TournamentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * TournamentUser.tournamentsAsWinner
   */
  export type TournamentUser$tournamentsAsWinnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tournament
     */
    select?: TournamentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tournament
     */
    omit?: TournamentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentInclude<ExtArgs> | null
    where?: TournamentWhereInput
    orderBy?: TournamentOrderByWithRelationInput | TournamentOrderByWithRelationInput[]
    cursor?: TournamentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TournamentScalarFieldEnum | TournamentScalarFieldEnum[]
  }

  /**
   * TournamentUser without action
   */
  export type TournamentUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TournamentUser
     */
    select?: TournamentUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TournamentUser
     */
    omit?: TournamentUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TournamentUserInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    ID: 'ID',
    Alias: 'Alias',
    Email: 'Email',
    Password: 'Password',
    Online: 'Online',
    CreationDate: 'CreationDate',
    GamesWon: 'GamesWon',
    ProfilePicture: 'ProfilePicture'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BlockedUserScalarFieldEnum: {
    ID: 'ID',
    BlockerID: 'BlockerID',
    BlockedID: 'BlockedID',
    BlockedDate: 'BlockedDate'
  };

  export type BlockedUserScalarFieldEnum = (typeof BlockedUserScalarFieldEnum)[keyof typeof BlockedUserScalarFieldEnum]


  export const FriendScalarFieldEnum: {
    ID: 'ID',
    User1ID: 'User1ID',
    User2ID: 'User2ID',
    DateBefriended: 'DateBefriended'
  };

  export type FriendScalarFieldEnum = (typeof FriendScalarFieldEnum)[keyof typeof FriendScalarFieldEnum]


  export const InvitationScalarFieldEnum: {
    ID: 'ID',
    SenderID: 'SenderID',
    ReceiverID: 'ReceiverID',
    Status: 'Status',
    SentAt: 'SentAt',
    RespondedAt: 'RespondedAt',
    MatchID: 'MatchID'
  };

  export type InvitationScalarFieldEnum = (typeof InvitationScalarFieldEnum)[keyof typeof InvitationScalarFieldEnum]


  export const LogScalarFieldEnum: {
    UUID: 'UUID',
    DateTime: 'DateTime',
    Type: 'Type',
    ServerClientID: 'ServerClientID',
    Message: 'Message'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const MatchScalarFieldEnum: {
    ID: 'ID',
    Player1ID: 'Player1ID',
    Player2ID: 'Player2ID',
    Player1Score: 'Player1Score',
    Player2Score: 'Player2Score',
    CreationDate: 'CreationDate',
    WinnerID: 'WinnerID'
  };

  export type MatchScalarFieldEnum = (typeof MatchScalarFieldEnum)[keyof typeof MatchScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    ID: 'ID',
    SenderID: 'SenderID',
    ReceiverID: 'ReceiverID',
    Message: 'Message',
    DateTime: 'DateTime',
    IsRead: 'IsRead'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const TournamentScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    CreationDate: 'CreationDate',
    WinnerID: 'WinnerID'
  };

  export type TournamentScalarFieldEnum = (typeof TournamentScalarFieldEnum)[keyof typeof TournamentScalarFieldEnum]


  export const TournamentMatchScalarFieldEnum: {
    ID: 'ID',
    TournamentID: 'TournamentID',
    Player1ID: 'Player1ID',
    Player2ID: 'Player2ID',
    Player1Score: 'Player1Score',
    Player2Score: 'Player2Score',
    CreationDate: 'CreationDate',
    WinnerID: 'WinnerID'
  };

  export type TournamentMatchScalarFieldEnum = (typeof TournamentMatchScalarFieldEnum)[keyof typeof TournamentMatchScalarFieldEnum]


  export const TournamentUserScalarFieldEnum: {
    ID: 'ID',
    Alias: 'Alias',
    UserID: 'UserID',
    TournamentID: 'TournamentID'
  };

  export type TournamentUserScalarFieldEnum = (typeof TournamentUserScalarFieldEnum)[keyof typeof TournamentUserScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    ID?: IntFilter<"User"> | number
    Alias?: StringFilter<"User"> | string
    Email?: StringFilter<"User"> | string
    Password?: StringFilter<"User"> | string
    Online?: BoolFilter<"User"> | boolean
    CreationDate?: DateTimeFilter<"User"> | Date | string
    GamesWon?: IntFilter<"User"> | number
    ProfilePicture?: BytesNullableFilter<"User"> | Bytes | null
    BlockedBy?: BlockedUserListRelationFilter
    Blocked?: BlockedUserListRelationFilter
    Friends1?: FriendListRelationFilter
    Friends2?: FriendListRelationFilter
    InvitationsSent?: InvitationListRelationFilter
    InvitationsReceived?: InvitationListRelationFilter
    matchesAsPlayer1?: MatchListRelationFilter
    matchesAsPlayer2?: MatchListRelationFilter
    matchesAsWinner?: MatchListRelationFilter
    MessagesSent?: MessageListRelationFilter
    MessagesReceived?: MessageListRelationFilter
    TournamentUsers?: TournamentUserListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    ID?: SortOrder
    Alias?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Online?: SortOrder
    CreationDate?: SortOrder
    GamesWon?: SortOrder
    ProfilePicture?: SortOrderInput | SortOrder
    BlockedBy?: BlockedUserOrderByRelationAggregateInput
    Blocked?: BlockedUserOrderByRelationAggregateInput
    Friends1?: FriendOrderByRelationAggregateInput
    Friends2?: FriendOrderByRelationAggregateInput
    InvitationsSent?: InvitationOrderByRelationAggregateInput
    InvitationsReceived?: InvitationOrderByRelationAggregateInput
    matchesAsPlayer1?: MatchOrderByRelationAggregateInput
    matchesAsPlayer2?: MatchOrderByRelationAggregateInput
    matchesAsWinner?: MatchOrderByRelationAggregateInput
    MessagesSent?: MessageOrderByRelationAggregateInput
    MessagesReceived?: MessageOrderByRelationAggregateInput
    TournamentUsers?: TournamentUserOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    Alias?: string
    Email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    Password?: StringFilter<"User"> | string
    Online?: BoolFilter<"User"> | boolean
    CreationDate?: DateTimeFilter<"User"> | Date | string
    GamesWon?: IntFilter<"User"> | number
    ProfilePicture?: BytesNullableFilter<"User"> | Bytes | null
    BlockedBy?: BlockedUserListRelationFilter
    Blocked?: BlockedUserListRelationFilter
    Friends1?: FriendListRelationFilter
    Friends2?: FriendListRelationFilter
    InvitationsSent?: InvitationListRelationFilter
    InvitationsReceived?: InvitationListRelationFilter
    matchesAsPlayer1?: MatchListRelationFilter
    matchesAsPlayer2?: MatchListRelationFilter
    matchesAsWinner?: MatchListRelationFilter
    MessagesSent?: MessageListRelationFilter
    MessagesReceived?: MessageListRelationFilter
    TournamentUsers?: TournamentUserListRelationFilter
  }, "ID" | "Alias" | "Email">

  export type UserOrderByWithAggregationInput = {
    ID?: SortOrder
    Alias?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Online?: SortOrder
    CreationDate?: SortOrder
    GamesWon?: SortOrder
    ProfilePicture?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"User"> | number
    Alias?: StringWithAggregatesFilter<"User"> | string
    Email?: StringWithAggregatesFilter<"User"> | string
    Password?: StringWithAggregatesFilter<"User"> | string
    Online?: BoolWithAggregatesFilter<"User"> | boolean
    CreationDate?: DateTimeWithAggregatesFilter<"User"> | Date | string
    GamesWon?: IntWithAggregatesFilter<"User"> | number
    ProfilePicture?: BytesNullableWithAggregatesFilter<"User"> | Bytes | null
  }

  export type BlockedUserWhereInput = {
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    ID?: IntFilter<"BlockedUser"> | number
    BlockerID?: IntFilter<"BlockedUser"> | number
    BlockedID?: IntFilter<"BlockedUser"> | number
    BlockedDate?: DateTimeFilter<"BlockedUser"> | Date | string
    Blocker?: XOR<UserScalarRelationFilter, UserWhereInput>
    Blocked?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type BlockedUserOrderByWithRelationInput = {
    ID?: SortOrder
    BlockerID?: SortOrder
    BlockedID?: SortOrder
    BlockedDate?: SortOrder
    Blocker?: UserOrderByWithRelationInput
    Blocked?: UserOrderByWithRelationInput
  }

  export type BlockedUserWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    BlockerID_BlockedID?: BlockedUserBlockerIDBlockedIDCompoundUniqueInput
    AND?: BlockedUserWhereInput | BlockedUserWhereInput[]
    OR?: BlockedUserWhereInput[]
    NOT?: BlockedUserWhereInput | BlockedUserWhereInput[]
    BlockerID?: IntFilter<"BlockedUser"> | number
    BlockedID?: IntFilter<"BlockedUser"> | number
    BlockedDate?: DateTimeFilter<"BlockedUser"> | Date | string
    Blocker?: XOR<UserScalarRelationFilter, UserWhereInput>
    Blocked?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "ID" | "BlockerID_BlockedID">

  export type BlockedUserOrderByWithAggregationInput = {
    ID?: SortOrder
    BlockerID?: SortOrder
    BlockedID?: SortOrder
    BlockedDate?: SortOrder
    _count?: BlockedUserCountOrderByAggregateInput
    _avg?: BlockedUserAvgOrderByAggregateInput
    _max?: BlockedUserMaxOrderByAggregateInput
    _min?: BlockedUserMinOrderByAggregateInput
    _sum?: BlockedUserSumOrderByAggregateInput
  }

  export type BlockedUserScalarWhereWithAggregatesInput = {
    AND?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    OR?: BlockedUserScalarWhereWithAggregatesInput[]
    NOT?: BlockedUserScalarWhereWithAggregatesInput | BlockedUserScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"BlockedUser"> | number
    BlockerID?: IntWithAggregatesFilter<"BlockedUser"> | number
    BlockedID?: IntWithAggregatesFilter<"BlockedUser"> | number
    BlockedDate?: DateTimeWithAggregatesFilter<"BlockedUser"> | Date | string
  }

  export type FriendWhereInput = {
    AND?: FriendWhereInput | FriendWhereInput[]
    OR?: FriendWhereInput[]
    NOT?: FriendWhereInput | FriendWhereInput[]
    ID?: IntFilter<"Friend"> | number
    User1ID?: IntFilter<"Friend"> | number
    User2ID?: IntFilter<"Friend"> | number
    DateBefriended?: DateTimeFilter<"Friend"> | Date | string
    User1?: XOR<UserScalarRelationFilter, UserWhereInput>
    User2?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FriendOrderByWithRelationInput = {
    ID?: SortOrder
    User1ID?: SortOrder
    User2ID?: SortOrder
    DateBefriended?: SortOrder
    User1?: UserOrderByWithRelationInput
    User2?: UserOrderByWithRelationInput
  }

  export type FriendWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    User1ID_User2ID?: FriendUser1IDUser2IDCompoundUniqueInput
    AND?: FriendWhereInput | FriendWhereInput[]
    OR?: FriendWhereInput[]
    NOT?: FriendWhereInput | FriendWhereInput[]
    User1ID?: IntFilter<"Friend"> | number
    User2ID?: IntFilter<"Friend"> | number
    DateBefriended?: DateTimeFilter<"Friend"> | Date | string
    User1?: XOR<UserScalarRelationFilter, UserWhereInput>
    User2?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "ID" | "User1ID_User2ID">

  export type FriendOrderByWithAggregationInput = {
    ID?: SortOrder
    User1ID?: SortOrder
    User2ID?: SortOrder
    DateBefriended?: SortOrder
    _count?: FriendCountOrderByAggregateInput
    _avg?: FriendAvgOrderByAggregateInput
    _max?: FriendMaxOrderByAggregateInput
    _min?: FriendMinOrderByAggregateInput
    _sum?: FriendSumOrderByAggregateInput
  }

  export type FriendScalarWhereWithAggregatesInput = {
    AND?: FriendScalarWhereWithAggregatesInput | FriendScalarWhereWithAggregatesInput[]
    OR?: FriendScalarWhereWithAggregatesInput[]
    NOT?: FriendScalarWhereWithAggregatesInput | FriendScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Friend"> | number
    User1ID?: IntWithAggregatesFilter<"Friend"> | number
    User2ID?: IntWithAggregatesFilter<"Friend"> | number
    DateBefriended?: DateTimeWithAggregatesFilter<"Friend"> | Date | string
  }

  export type InvitationWhereInput = {
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    ID?: IntFilter<"Invitation"> | number
    SenderID?: IntFilter<"Invitation"> | number
    ReceiverID?: IntFilter<"Invitation"> | number
    Status?: IntFilter<"Invitation"> | number
    SentAt?: DateTimeFilter<"Invitation"> | Date | string
    RespondedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    MatchID?: IntFilter<"Invitation"> | number
    Sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    Receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    Match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
  }

  export type InvitationOrderByWithRelationInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Status?: SortOrder
    SentAt?: SortOrder
    RespondedAt?: SortOrderInput | SortOrder
    MatchID?: SortOrder
    Sender?: UserOrderByWithRelationInput
    Receiver?: UserOrderByWithRelationInput
    Match?: MatchOrderByWithRelationInput
  }

  export type InvitationWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: InvitationWhereInput | InvitationWhereInput[]
    OR?: InvitationWhereInput[]
    NOT?: InvitationWhereInput | InvitationWhereInput[]
    SenderID?: IntFilter<"Invitation"> | number
    ReceiverID?: IntFilter<"Invitation"> | number
    Status?: IntFilter<"Invitation"> | number
    SentAt?: DateTimeFilter<"Invitation"> | Date | string
    RespondedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    MatchID?: IntFilter<"Invitation"> | number
    Sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    Receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    Match?: XOR<MatchScalarRelationFilter, MatchWhereInput>
  }, "ID">

  export type InvitationOrderByWithAggregationInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Status?: SortOrder
    SentAt?: SortOrder
    RespondedAt?: SortOrderInput | SortOrder
    MatchID?: SortOrder
    _count?: InvitationCountOrderByAggregateInput
    _avg?: InvitationAvgOrderByAggregateInput
    _max?: InvitationMaxOrderByAggregateInput
    _min?: InvitationMinOrderByAggregateInput
    _sum?: InvitationSumOrderByAggregateInput
  }

  export type InvitationScalarWhereWithAggregatesInput = {
    AND?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    OR?: InvitationScalarWhereWithAggregatesInput[]
    NOT?: InvitationScalarWhereWithAggregatesInput | InvitationScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Invitation"> | number
    SenderID?: IntWithAggregatesFilter<"Invitation"> | number
    ReceiverID?: IntWithAggregatesFilter<"Invitation"> | number
    Status?: IntWithAggregatesFilter<"Invitation"> | number
    SentAt?: DateTimeWithAggregatesFilter<"Invitation"> | Date | string
    RespondedAt?: DateTimeNullableWithAggregatesFilter<"Invitation"> | Date | string | null
    MatchID?: IntWithAggregatesFilter<"Invitation"> | number
  }

  export type LogWhereInput = {
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    UUID?: IntFilter<"Log"> | number
    DateTime?: DateTimeFilter<"Log"> | Date | string
    Type?: IntFilter<"Log"> | number
    ServerClientID?: IntFilter<"Log"> | number
    Message?: StringFilter<"Log"> | string
  }

  export type LogOrderByWithRelationInput = {
    UUID?: SortOrder
    DateTime?: SortOrder
    Type?: SortOrder
    ServerClientID?: SortOrder
    Message?: SortOrder
  }

  export type LogWhereUniqueInput = Prisma.AtLeast<{
    UUID?: number
    AND?: LogWhereInput | LogWhereInput[]
    OR?: LogWhereInput[]
    NOT?: LogWhereInput | LogWhereInput[]
    DateTime?: DateTimeFilter<"Log"> | Date | string
    Type?: IntFilter<"Log"> | number
    ServerClientID?: IntFilter<"Log"> | number
    Message?: StringFilter<"Log"> | string
  }, "UUID">

  export type LogOrderByWithAggregationInput = {
    UUID?: SortOrder
    DateTime?: SortOrder
    Type?: SortOrder
    ServerClientID?: SortOrder
    Message?: SortOrder
    _count?: LogCountOrderByAggregateInput
    _avg?: LogAvgOrderByAggregateInput
    _max?: LogMaxOrderByAggregateInput
    _min?: LogMinOrderByAggregateInput
    _sum?: LogSumOrderByAggregateInput
  }

  export type LogScalarWhereWithAggregatesInput = {
    AND?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    OR?: LogScalarWhereWithAggregatesInput[]
    NOT?: LogScalarWhereWithAggregatesInput | LogScalarWhereWithAggregatesInput[]
    UUID?: IntWithAggregatesFilter<"Log"> | number
    DateTime?: DateTimeWithAggregatesFilter<"Log"> | Date | string
    Type?: IntWithAggregatesFilter<"Log"> | number
    ServerClientID?: IntWithAggregatesFilter<"Log"> | number
    Message?: StringWithAggregatesFilter<"Log"> | string
  }

  export type MatchWhereInput = {
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    ID?: IntFilter<"Match"> | number
    Player1ID?: IntFilter<"Match"> | number
    Player2ID?: IntFilter<"Match"> | number
    Player1Score?: IntFilter<"Match"> | number
    Player2Score?: IntFilter<"Match"> | number
    CreationDate?: DateTimeFilter<"Match"> | Date | string
    WinnerID?: IntNullableFilter<"Match"> | number | null
    Player1?: XOR<UserScalarRelationFilter, UserWhereInput>
    Player2?: XOR<UserScalarRelationFilter, UserWhereInput>
    Winner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Invitations?: InvitationListRelationFilter
  }

  export type MatchOrderByWithRelationInput = {
    ID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrderInput | SortOrder
    Player1?: UserOrderByWithRelationInput
    Player2?: UserOrderByWithRelationInput
    Winner?: UserOrderByWithRelationInput
    Invitations?: InvitationOrderByRelationAggregateInput
  }

  export type MatchWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: MatchWhereInput | MatchWhereInput[]
    OR?: MatchWhereInput[]
    NOT?: MatchWhereInput | MatchWhereInput[]
    Player1ID?: IntFilter<"Match"> | number
    Player2ID?: IntFilter<"Match"> | number
    Player1Score?: IntFilter<"Match"> | number
    Player2Score?: IntFilter<"Match"> | number
    CreationDate?: DateTimeFilter<"Match"> | Date | string
    WinnerID?: IntNullableFilter<"Match"> | number | null
    Player1?: XOR<UserScalarRelationFilter, UserWhereInput>
    Player2?: XOR<UserScalarRelationFilter, UserWhereInput>
    Winner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    Invitations?: InvitationListRelationFilter
  }, "ID">

  export type MatchOrderByWithAggregationInput = {
    ID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrderInput | SortOrder
    _count?: MatchCountOrderByAggregateInput
    _avg?: MatchAvgOrderByAggregateInput
    _max?: MatchMaxOrderByAggregateInput
    _min?: MatchMinOrderByAggregateInput
    _sum?: MatchSumOrderByAggregateInput
  }

  export type MatchScalarWhereWithAggregatesInput = {
    AND?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    OR?: MatchScalarWhereWithAggregatesInput[]
    NOT?: MatchScalarWhereWithAggregatesInput | MatchScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Match"> | number
    Player1ID?: IntWithAggregatesFilter<"Match"> | number
    Player2ID?: IntWithAggregatesFilter<"Match"> | number
    Player1Score?: IntWithAggregatesFilter<"Match"> | number
    Player2Score?: IntWithAggregatesFilter<"Match"> | number
    CreationDate?: DateTimeWithAggregatesFilter<"Match"> | Date | string
    WinnerID?: IntNullableWithAggregatesFilter<"Match"> | number | null
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    ID?: IntFilter<"Message"> | number
    SenderID?: IntFilter<"Message"> | number
    ReceiverID?: IntFilter<"Message"> | number
    Message?: StringFilter<"Message"> | string
    DateTime?: DateTimeFilter<"Message"> | Date | string
    IsRead?: BoolFilter<"Message"> | boolean
    Sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    Receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Message?: SortOrder
    DateTime?: SortOrder
    IsRead?: SortOrder
    Sender?: UserOrderByWithRelationInput
    Receiver?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    SenderID?: IntFilter<"Message"> | number
    ReceiverID?: IntFilter<"Message"> | number
    Message?: StringFilter<"Message"> | string
    DateTime?: DateTimeFilter<"Message"> | Date | string
    IsRead?: BoolFilter<"Message"> | boolean
    Sender?: XOR<UserScalarRelationFilter, UserWhereInput>
    Receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "ID">

  export type MessageOrderByWithAggregationInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Message?: SortOrder
    DateTime?: SortOrder
    IsRead?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _avg?: MessageAvgOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
    _sum?: MessageSumOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Message"> | number
    SenderID?: IntWithAggregatesFilter<"Message"> | number
    ReceiverID?: IntWithAggregatesFilter<"Message"> | number
    Message?: StringWithAggregatesFilter<"Message"> | string
    DateTime?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    IsRead?: BoolWithAggregatesFilter<"Message"> | boolean
  }

  export type TournamentWhereInput = {
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    ID?: IntFilter<"Tournament"> | number
    Name?: StringFilter<"Tournament"> | string
    CreationDate?: DateTimeFilter<"Tournament"> | Date | string
    WinnerID?: IntNullableFilter<"Tournament"> | number | null
    Winner?: XOR<TournamentUserNullableScalarRelationFilter, TournamentUserWhereInput> | null
    Matches?: TournamentMatchListRelationFilter
    Users?: TournamentUserListRelationFilter
    TournamentUsers?: TournamentUserListRelationFilter
  }

  export type TournamentOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrderInput | SortOrder
    Winner?: TournamentUserOrderByWithRelationInput
    Matches?: TournamentMatchOrderByRelationAggregateInput
    Users?: TournamentUserOrderByRelationAggregateInput
    TournamentUsers?: TournamentUserOrderByRelationAggregateInput
  }

  export type TournamentWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: TournamentWhereInput | TournamentWhereInput[]
    OR?: TournamentWhereInput[]
    NOT?: TournamentWhereInput | TournamentWhereInput[]
    Name?: StringFilter<"Tournament"> | string
    CreationDate?: DateTimeFilter<"Tournament"> | Date | string
    WinnerID?: IntNullableFilter<"Tournament"> | number | null
    Winner?: XOR<TournamentUserNullableScalarRelationFilter, TournamentUserWhereInput> | null
    Matches?: TournamentMatchListRelationFilter
    Users?: TournamentUserListRelationFilter
    TournamentUsers?: TournamentUserListRelationFilter
  }, "ID">

  export type TournamentOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrderInput | SortOrder
    _count?: TournamentCountOrderByAggregateInput
    _avg?: TournamentAvgOrderByAggregateInput
    _max?: TournamentMaxOrderByAggregateInput
    _min?: TournamentMinOrderByAggregateInput
    _sum?: TournamentSumOrderByAggregateInput
  }

  export type TournamentScalarWhereWithAggregatesInput = {
    AND?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    OR?: TournamentScalarWhereWithAggregatesInput[]
    NOT?: TournamentScalarWhereWithAggregatesInput | TournamentScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"Tournament"> | number
    Name?: StringWithAggregatesFilter<"Tournament"> | string
    CreationDate?: DateTimeWithAggregatesFilter<"Tournament"> | Date | string
    WinnerID?: IntNullableWithAggregatesFilter<"Tournament"> | number | null
  }

  export type TournamentMatchWhereInput = {
    AND?: TournamentMatchWhereInput | TournamentMatchWhereInput[]
    OR?: TournamentMatchWhereInput[]
    NOT?: TournamentMatchWhereInput | TournamentMatchWhereInput[]
    ID?: IntFilter<"TournamentMatch"> | number
    TournamentID?: IntFilter<"TournamentMatch"> | number
    Player1ID?: IntFilter<"TournamentMatch"> | number
    Player2ID?: IntFilter<"TournamentMatch"> | number
    Player1Score?: IntFilter<"TournamentMatch"> | number
    Player2Score?: IntFilter<"TournamentMatch"> | number
    CreationDate?: DateTimeFilter<"TournamentMatch"> | Date | string
    WinnerID?: IntNullableFilter<"TournamentMatch"> | number | null
    Tournament?: XOR<TournamentScalarRelationFilter, TournamentWhereInput>
    Player1?: XOR<TournamentUserScalarRelationFilter, TournamentUserWhereInput>
    Player2?: XOR<TournamentUserScalarRelationFilter, TournamentUserWhereInput>
    Winner?: XOR<TournamentUserNullableScalarRelationFilter, TournamentUserWhereInput> | null
  }

  export type TournamentMatchOrderByWithRelationInput = {
    ID?: SortOrder
    TournamentID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrderInput | SortOrder
    Tournament?: TournamentOrderByWithRelationInput
    Player1?: TournamentUserOrderByWithRelationInput
    Player2?: TournamentUserOrderByWithRelationInput
    Winner?: TournamentUserOrderByWithRelationInput
  }

  export type TournamentMatchWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: TournamentMatchWhereInput | TournamentMatchWhereInput[]
    OR?: TournamentMatchWhereInput[]
    NOT?: TournamentMatchWhereInput | TournamentMatchWhereInput[]
    TournamentID?: IntFilter<"TournamentMatch"> | number
    Player1ID?: IntFilter<"TournamentMatch"> | number
    Player2ID?: IntFilter<"TournamentMatch"> | number
    Player1Score?: IntFilter<"TournamentMatch"> | number
    Player2Score?: IntFilter<"TournamentMatch"> | number
    CreationDate?: DateTimeFilter<"TournamentMatch"> | Date | string
    WinnerID?: IntNullableFilter<"TournamentMatch"> | number | null
    Tournament?: XOR<TournamentScalarRelationFilter, TournamentWhereInput>
    Player1?: XOR<TournamentUserScalarRelationFilter, TournamentUserWhereInput>
    Player2?: XOR<TournamentUserScalarRelationFilter, TournamentUserWhereInput>
    Winner?: XOR<TournamentUserNullableScalarRelationFilter, TournamentUserWhereInput> | null
  }, "ID">

  export type TournamentMatchOrderByWithAggregationInput = {
    ID?: SortOrder
    TournamentID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrderInput | SortOrder
    _count?: TournamentMatchCountOrderByAggregateInput
    _avg?: TournamentMatchAvgOrderByAggregateInput
    _max?: TournamentMatchMaxOrderByAggregateInput
    _min?: TournamentMatchMinOrderByAggregateInput
    _sum?: TournamentMatchSumOrderByAggregateInput
  }

  export type TournamentMatchScalarWhereWithAggregatesInput = {
    AND?: TournamentMatchScalarWhereWithAggregatesInput | TournamentMatchScalarWhereWithAggregatesInput[]
    OR?: TournamentMatchScalarWhereWithAggregatesInput[]
    NOT?: TournamentMatchScalarWhereWithAggregatesInput | TournamentMatchScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"TournamentMatch"> | number
    TournamentID?: IntWithAggregatesFilter<"TournamentMatch"> | number
    Player1ID?: IntWithAggregatesFilter<"TournamentMatch"> | number
    Player2ID?: IntWithAggregatesFilter<"TournamentMatch"> | number
    Player1Score?: IntWithAggregatesFilter<"TournamentMatch"> | number
    Player2Score?: IntWithAggregatesFilter<"TournamentMatch"> | number
    CreationDate?: DateTimeWithAggregatesFilter<"TournamentMatch"> | Date | string
    WinnerID?: IntNullableWithAggregatesFilter<"TournamentMatch"> | number | null
  }

  export type TournamentUserWhereInput = {
    AND?: TournamentUserWhereInput | TournamentUserWhereInput[]
    OR?: TournamentUserWhereInput[]
    NOT?: TournamentUserWhereInput | TournamentUserWhereInput[]
    ID?: IntFilter<"TournamentUser"> | number
    Alias?: StringFilter<"TournamentUser"> | string
    UserID?: IntFilter<"TournamentUser"> | number
    TournamentID?: IntFilter<"TournamentUser"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Tournament?: XOR<TournamentScalarRelationFilter, TournamentWhereInput>
    matchesAsPlayer1?: TournamentMatchListRelationFilter
    matchesAsPlayer2?: TournamentMatchListRelationFilter
    matchesAsWinner?: TournamentMatchListRelationFilter
    tournaments?: TournamentListRelationFilter
    tournamentsAsWinner?: TournamentListRelationFilter
  }

  export type TournamentUserOrderByWithRelationInput = {
    ID?: SortOrder
    Alias?: SortOrder
    UserID?: SortOrder
    TournamentID?: SortOrder
    User?: UserOrderByWithRelationInput
    Tournament?: TournamentOrderByWithRelationInput
    matchesAsPlayer1?: TournamentMatchOrderByRelationAggregateInput
    matchesAsPlayer2?: TournamentMatchOrderByRelationAggregateInput
    matchesAsWinner?: TournamentMatchOrderByRelationAggregateInput
    tournaments?: TournamentOrderByRelationAggregateInput
    tournamentsAsWinner?: TournamentOrderByRelationAggregateInput
  }

  export type TournamentUserWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: TournamentUserWhereInput | TournamentUserWhereInput[]
    OR?: TournamentUserWhereInput[]
    NOT?: TournamentUserWhereInput | TournamentUserWhereInput[]
    Alias?: StringFilter<"TournamentUser"> | string
    UserID?: IntFilter<"TournamentUser"> | number
    TournamentID?: IntFilter<"TournamentUser"> | number
    User?: XOR<UserScalarRelationFilter, UserWhereInput>
    Tournament?: XOR<TournamentScalarRelationFilter, TournamentWhereInput>
    matchesAsPlayer1?: TournamentMatchListRelationFilter
    matchesAsPlayer2?: TournamentMatchListRelationFilter
    matchesAsWinner?: TournamentMatchListRelationFilter
    tournaments?: TournamentListRelationFilter
    tournamentsAsWinner?: TournamentListRelationFilter
  }, "ID">

  export type TournamentUserOrderByWithAggregationInput = {
    ID?: SortOrder
    Alias?: SortOrder
    UserID?: SortOrder
    TournamentID?: SortOrder
    _count?: TournamentUserCountOrderByAggregateInput
    _avg?: TournamentUserAvgOrderByAggregateInput
    _max?: TournamentUserMaxOrderByAggregateInput
    _min?: TournamentUserMinOrderByAggregateInput
    _sum?: TournamentUserSumOrderByAggregateInput
  }

  export type TournamentUserScalarWhereWithAggregatesInput = {
    AND?: TournamentUserScalarWhereWithAggregatesInput | TournamentUserScalarWhereWithAggregatesInput[]
    OR?: TournamentUserScalarWhereWithAggregatesInput[]
    NOT?: TournamentUserScalarWhereWithAggregatesInput | TournamentUserScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"TournamentUser"> | number
    Alias?: StringWithAggregatesFilter<"TournamentUser"> | string
    UserID?: IntWithAggregatesFilter<"TournamentUser"> | number
    TournamentID?: IntWithAggregatesFilter<"TournamentUser"> | number
  }

  export type UserCreateInput = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
  }

  export type UserUpdateManyMutationInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type UserUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
  }

  export type BlockedUserCreateInput = {
    BlockedDate: Date | string
    Blocker: UserCreateNestedOneWithoutBlockedByInput
    Blocked: UserCreateNestedOneWithoutBlockedInput
  }

  export type BlockedUserUncheckedCreateInput = {
    ID?: number
    BlockerID: number
    BlockedID: number
    BlockedDate: Date | string
  }

  export type BlockedUserUpdateInput = {
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Blocker?: UserUpdateOneRequiredWithoutBlockedByNestedInput
    Blocked?: UserUpdateOneRequiredWithoutBlockedNestedInput
  }

  export type BlockedUserUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    BlockerID?: IntFieldUpdateOperationsInput | number
    BlockedID?: IntFieldUpdateOperationsInput | number
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserCreateManyInput = {
    ID?: number
    BlockerID: number
    BlockedID: number
    BlockedDate: Date | string
  }

  export type BlockedUserUpdateManyMutationInput = {
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    BlockerID?: IntFieldUpdateOperationsInput | number
    BlockedID?: IntFieldUpdateOperationsInput | number
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendCreateInput = {
    DateBefriended: Date | string
    User1: UserCreateNestedOneWithoutFriends1Input
    User2: UserCreateNestedOneWithoutFriends2Input
  }

  export type FriendUncheckedCreateInput = {
    ID?: number
    User1ID: number
    User2ID: number
    DateBefriended: Date | string
  }

  export type FriendUpdateInput = {
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
    User1?: UserUpdateOneRequiredWithoutFriends1NestedInput
    User2?: UserUpdateOneRequiredWithoutFriends2NestedInput
  }

  export type FriendUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    User1ID?: IntFieldUpdateOperationsInput | number
    User2ID?: IntFieldUpdateOperationsInput | number
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendCreateManyInput = {
    ID?: number
    User1ID: number
    User2ID: number
    DateBefriended: Date | string
  }

  export type FriendUpdateManyMutationInput = {
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    User1ID?: IntFieldUpdateOperationsInput | number
    User2ID?: IntFieldUpdateOperationsInput | number
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationCreateInput = {
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    Sender: UserCreateNestedOneWithoutInvitationsSentInput
    Receiver: UserCreateNestedOneWithoutInvitationsReceivedInput
    Match: MatchCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateInput = {
    ID?: number
    SenderID: number
    ReceiverID: number
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    MatchID: number
  }

  export type InvitationUpdateInput = {
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sender?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
    Receiver?: UserUpdateOneRequiredWithoutInvitationsReceivedNestedInput
    Match?: MatchUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MatchID?: IntFieldUpdateOperationsInput | number
  }

  export type InvitationCreateManyInput = {
    ID?: number
    SenderID: number
    ReceiverID: number
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    MatchID: number
  }

  export type InvitationUpdateManyMutationInput = {
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvitationUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MatchID?: IntFieldUpdateOperationsInput | number
  }

  export type LogCreateInput = {
    DateTime: Date | string
    Type: number
    ServerClientID: number
    Message: string
  }

  export type LogUncheckedCreateInput = {
    UUID?: number
    DateTime: Date | string
    Type: number
    ServerClientID: number
    Message: string
  }

  export type LogUpdateInput = {
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    ServerClientID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
  }

  export type LogUncheckedUpdateInput = {
    UUID?: IntFieldUpdateOperationsInput | number
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    ServerClientID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
  }

  export type LogCreateManyInput = {
    UUID?: number
    DateTime: Date | string
    Type: number
    ServerClientID: number
    Message: string
  }

  export type LogUpdateManyMutationInput = {
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    ServerClientID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
  }

  export type LogUncheckedUpdateManyInput = {
    UUID?: IntFieldUpdateOperationsInput | number
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    Type?: IntFieldUpdateOperationsInput | number
    ServerClientID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
  }

  export type MatchCreateInput = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Player1: UserCreateNestedOneWithoutMatchesAsPlayer1Input
    Player2: UserCreateNestedOneWithoutMatchesAsPlayer2Input
    Winner?: UserCreateNestedOneWithoutMatchesAsWinnerInput
    Invitations?: InvitationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateInput = {
    ID?: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
    Invitations?: InvitationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchUpdateInput = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Player1?: UserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput
    Player2?: UserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput
    Winner?: UserUpdateOneWithoutMatchesAsWinnerNestedInput
    Invitations?: InvitationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
    Invitations?: InvitationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchCreateManyInput = {
    ID?: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type MatchUpdateManyMutationInput = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MatchUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MessageCreateInput = {
    Message: string
    DateTime: Date | string
    IsRead: boolean
    Sender: UserCreateNestedOneWithoutMessagesSentInput
    Receiver: UserCreateNestedOneWithoutMessagesReceivedInput
  }

  export type MessageUncheckedCreateInput = {
    ID?: number
    SenderID: number
    ReceiverID: number
    Message: string
    DateTime: Date | string
    IsRead: boolean
  }

  export type MessageUpdateInput = {
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
    Sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
    Receiver?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageCreateManyInput = {
    ID?: number
    SenderID: number
    ReceiverID: number
    Message: string
    DateTime: Date | string
    IsRead: boolean
  }

  export type MessageUpdateManyMutationInput = {
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TournamentCreateInput = {
    Name: string
    CreationDate: Date | string
    Winner?: TournamentUserCreateNestedOneWithoutTournamentsAsWinnerInput
    Matches?: TournamentMatchCreateNestedManyWithoutTournamentInput
    Users?: TournamentUserCreateNestedManyWithoutTournamentsInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateInput = {
    ID?: number
    Name: string
    CreationDate: Date | string
    WinnerID?: number | null
    Matches?: TournamentMatchUncheckedCreateNestedManyWithoutTournamentInput
    Users?: TournamentUserUncheckedCreateNestedManyWithoutTournamentsInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Winner?: TournamentUserUpdateOneWithoutTournamentsAsWinnerNestedInput
    Matches?: TournamentMatchUpdateManyWithoutTournamentNestedInput
    Users?: TournamentUserUpdateManyWithoutTournamentsNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
    Matches?: TournamentMatchUncheckedUpdateManyWithoutTournamentNestedInput
    Users?: TournamentUserUncheckedUpdateManyWithoutTournamentsNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentCreateManyInput = {
    ID?: number
    Name: string
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type TournamentUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentMatchCreateInput = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Tournament: TournamentCreateNestedOneWithoutMatchesInput
    Player1: TournamentUserCreateNestedOneWithoutMatchesAsPlayer1Input
    Player2: TournamentUserCreateNestedOneWithoutMatchesAsPlayer2Input
    Winner?: TournamentUserCreateNestedOneWithoutMatchesAsWinnerInput
  }

  export type TournamentMatchUncheckedCreateInput = {
    ID?: number
    TournamentID: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type TournamentMatchUpdateInput = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Tournament?: TournamentUpdateOneRequiredWithoutMatchesNestedInput
    Player1?: TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput
    Player2?: TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput
    Winner?: TournamentUserUpdateOneWithoutMatchesAsWinnerNestedInput
  }

  export type TournamentMatchUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentMatchCreateManyInput = {
    ID?: number
    TournamentID: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type TournamentMatchUpdateManyMutationInput = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentMatchUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentUserCreateInput = {
    Alias: string
    User: UserCreateNestedOneWithoutTournamentUsersInput
    Tournament: TournamentCreateNestedOneWithoutTournamentUsersInput
    matchesAsPlayer1?: TournamentMatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserUncheckedCreateInput = {
    ID?: number
    Alias: string
    UserID: number
    TournamentID: number
    matchesAsPlayer1?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchUncheckedCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserUpdateInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutTournamentUsersNestedInput
    Tournament?: TournamentUpdateOneRequiredWithoutTournamentUsersNestedInput
    matchesAsPlayer1?: TournamentMatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    matchesAsPlayer1?: TournamentMatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUncheckedUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserCreateManyInput = {
    ID?: number
    Alias: string
    UserID: number
    TournamentID: number
  }

  export type TournamentUserUpdateManyMutationInput = {
    Alias?: StringFieldUpdateOperationsInput | string
  }

  export type TournamentUserUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type BlockedUserListRelationFilter = {
    every?: BlockedUserWhereInput
    some?: BlockedUserWhereInput
    none?: BlockedUserWhereInput
  }

  export type FriendListRelationFilter = {
    every?: FriendWhereInput
    some?: FriendWhereInput
    none?: FriendWhereInput
  }

  export type InvitationListRelationFilter = {
    every?: InvitationWhereInput
    some?: InvitationWhereInput
    none?: InvitationWhereInput
  }

  export type MatchListRelationFilter = {
    every?: MatchWhereInput
    some?: MatchWhereInput
    none?: MatchWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type TournamentUserListRelationFilter = {
    every?: TournamentUserWhereInput
    some?: TournamentUserWhereInput
    none?: TournamentUserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type BlockedUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FriendOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TournamentUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    ID?: SortOrder
    Alias?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Online?: SortOrder
    CreationDate?: SortOrder
    GamesWon?: SortOrder
    ProfilePicture?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    ID?: SortOrder
    GamesWon?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    ID?: SortOrder
    Alias?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Online?: SortOrder
    CreationDate?: SortOrder
    GamesWon?: SortOrder
    ProfilePicture?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    ID?: SortOrder
    Alias?: SortOrder
    Email?: SortOrder
    Password?: SortOrder
    Online?: SortOrder
    CreationDate?: SortOrder
    GamesWon?: SortOrder
    ProfilePicture?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    ID?: SortOrder
    GamesWon?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type BlockedUserBlockerIDBlockedIDCompoundUniqueInput = {
    BlockerID: number
    BlockedID: number
  }

  export type BlockedUserCountOrderByAggregateInput = {
    ID?: SortOrder
    BlockerID?: SortOrder
    BlockedID?: SortOrder
    BlockedDate?: SortOrder
  }

  export type BlockedUserAvgOrderByAggregateInput = {
    ID?: SortOrder
    BlockerID?: SortOrder
    BlockedID?: SortOrder
  }

  export type BlockedUserMaxOrderByAggregateInput = {
    ID?: SortOrder
    BlockerID?: SortOrder
    BlockedID?: SortOrder
    BlockedDate?: SortOrder
  }

  export type BlockedUserMinOrderByAggregateInput = {
    ID?: SortOrder
    BlockerID?: SortOrder
    BlockedID?: SortOrder
    BlockedDate?: SortOrder
  }

  export type BlockedUserSumOrderByAggregateInput = {
    ID?: SortOrder
    BlockerID?: SortOrder
    BlockedID?: SortOrder
  }

  export type FriendUser1IDUser2IDCompoundUniqueInput = {
    User1ID: number
    User2ID: number
  }

  export type FriendCountOrderByAggregateInput = {
    ID?: SortOrder
    User1ID?: SortOrder
    User2ID?: SortOrder
    DateBefriended?: SortOrder
  }

  export type FriendAvgOrderByAggregateInput = {
    ID?: SortOrder
    User1ID?: SortOrder
    User2ID?: SortOrder
  }

  export type FriendMaxOrderByAggregateInput = {
    ID?: SortOrder
    User1ID?: SortOrder
    User2ID?: SortOrder
    DateBefriended?: SortOrder
  }

  export type FriendMinOrderByAggregateInput = {
    ID?: SortOrder
    User1ID?: SortOrder
    User2ID?: SortOrder
    DateBefriended?: SortOrder
  }

  export type FriendSumOrderByAggregateInput = {
    ID?: SortOrder
    User1ID?: SortOrder
    User2ID?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type MatchScalarRelationFilter = {
    is?: MatchWhereInput
    isNot?: MatchWhereInput
  }

  export type InvitationCountOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Status?: SortOrder
    SentAt?: SortOrder
    RespondedAt?: SortOrder
    MatchID?: SortOrder
  }

  export type InvitationAvgOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Status?: SortOrder
    MatchID?: SortOrder
  }

  export type InvitationMaxOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Status?: SortOrder
    SentAt?: SortOrder
    RespondedAt?: SortOrder
    MatchID?: SortOrder
  }

  export type InvitationMinOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Status?: SortOrder
    SentAt?: SortOrder
    RespondedAt?: SortOrder
    MatchID?: SortOrder
  }

  export type InvitationSumOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Status?: SortOrder
    MatchID?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type LogCountOrderByAggregateInput = {
    UUID?: SortOrder
    DateTime?: SortOrder
    Type?: SortOrder
    ServerClientID?: SortOrder
    Message?: SortOrder
  }

  export type LogAvgOrderByAggregateInput = {
    UUID?: SortOrder
    Type?: SortOrder
    ServerClientID?: SortOrder
  }

  export type LogMaxOrderByAggregateInput = {
    UUID?: SortOrder
    DateTime?: SortOrder
    Type?: SortOrder
    ServerClientID?: SortOrder
    Message?: SortOrder
  }

  export type LogMinOrderByAggregateInput = {
    UUID?: SortOrder
    DateTime?: SortOrder
    Type?: SortOrder
    ServerClientID?: SortOrder
    Message?: SortOrder
  }

  export type LogSumOrderByAggregateInput = {
    UUID?: SortOrder
    Type?: SortOrder
    ServerClientID?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type MatchCountOrderByAggregateInput = {
    ID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrder
  }

  export type MatchAvgOrderByAggregateInput = {
    ID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    WinnerID?: SortOrder
  }

  export type MatchMaxOrderByAggregateInput = {
    ID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrder
  }

  export type MatchMinOrderByAggregateInput = {
    ID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrder
  }

  export type MatchSumOrderByAggregateInput = {
    ID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    WinnerID?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type MessageCountOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Message?: SortOrder
    DateTime?: SortOrder
    IsRead?: SortOrder
  }

  export type MessageAvgOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Message?: SortOrder
    DateTime?: SortOrder
    IsRead?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
    Message?: SortOrder
    DateTime?: SortOrder
    IsRead?: SortOrder
  }

  export type MessageSumOrderByAggregateInput = {
    ID?: SortOrder
    SenderID?: SortOrder
    ReceiverID?: SortOrder
  }

  export type TournamentUserNullableScalarRelationFilter = {
    is?: TournamentUserWhereInput | null
    isNot?: TournamentUserWhereInput | null
  }

  export type TournamentMatchListRelationFilter = {
    every?: TournamentMatchWhereInput
    some?: TournamentMatchWhereInput
    none?: TournamentMatchWhereInput
  }

  export type TournamentMatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TournamentCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentAvgOrderByAggregateInput = {
    ID?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentSumOrderByAggregateInput = {
    ID?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentScalarRelationFilter = {
    is?: TournamentWhereInput
    isNot?: TournamentWhereInput
  }

  export type TournamentUserScalarRelationFilter = {
    is?: TournamentUserWhereInput
    isNot?: TournamentUserWhereInput
  }

  export type TournamentMatchCountOrderByAggregateInput = {
    ID?: SortOrder
    TournamentID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentMatchAvgOrderByAggregateInput = {
    ID?: SortOrder
    TournamentID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentMatchMaxOrderByAggregateInput = {
    ID?: SortOrder
    TournamentID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentMatchMinOrderByAggregateInput = {
    ID?: SortOrder
    TournamentID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    CreationDate?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentMatchSumOrderByAggregateInput = {
    ID?: SortOrder
    TournamentID?: SortOrder
    Player1ID?: SortOrder
    Player2ID?: SortOrder
    Player1Score?: SortOrder
    Player2Score?: SortOrder
    WinnerID?: SortOrder
  }

  export type TournamentListRelationFilter = {
    every?: TournamentWhereInput
    some?: TournamentWhereInput
    none?: TournamentWhereInput
  }

  export type TournamentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TournamentUserCountOrderByAggregateInput = {
    ID?: SortOrder
    Alias?: SortOrder
    UserID?: SortOrder
    TournamentID?: SortOrder
  }

  export type TournamentUserAvgOrderByAggregateInput = {
    ID?: SortOrder
    UserID?: SortOrder
    TournamentID?: SortOrder
  }

  export type TournamentUserMaxOrderByAggregateInput = {
    ID?: SortOrder
    Alias?: SortOrder
    UserID?: SortOrder
    TournamentID?: SortOrder
  }

  export type TournamentUserMinOrderByAggregateInput = {
    ID?: SortOrder
    Alias?: SortOrder
    UserID?: SortOrder
    TournamentID?: SortOrder
  }

  export type TournamentUserSumOrderByAggregateInput = {
    ID?: SortOrder
    UserID?: SortOrder
    TournamentID?: SortOrder
  }

  export type BlockedUserCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlockedUserCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type FriendCreateNestedManyWithoutUser1Input = {
    create?: XOR<FriendCreateWithoutUser1Input, FriendUncheckedCreateWithoutUser1Input> | FriendCreateWithoutUser1Input[] | FriendUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: FriendCreateOrConnectWithoutUser1Input | FriendCreateOrConnectWithoutUser1Input[]
    createMany?: FriendCreateManyUser1InputEnvelope
    connect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
  }

  export type FriendCreateNestedManyWithoutUser2Input = {
    create?: XOR<FriendCreateWithoutUser2Input, FriendUncheckedCreateWithoutUser2Input> | FriendCreateWithoutUser2Input[] | FriendUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: FriendCreateOrConnectWithoutUser2Input | FriendCreateOrConnectWithoutUser2Input[]
    createMany?: FriendCreateManyUser2InputEnvelope
    connect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutSenderInput = {
    create?: XOR<InvitationCreateWithoutSenderInput, InvitationUncheckedCreateWithoutSenderInput> | InvitationCreateWithoutSenderInput[] | InvitationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutSenderInput | InvitationCreateOrConnectWithoutSenderInput[]
    createMany?: InvitationCreateManySenderInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type InvitationCreateNestedManyWithoutReceiverInput = {
    create?: XOR<InvitationCreateWithoutReceiverInput, InvitationUncheckedCreateWithoutReceiverInput> | InvitationCreateWithoutReceiverInput[] | InvitationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutReceiverInput | InvitationCreateOrConnectWithoutReceiverInput[]
    createMany?: InvitationCreateManyReceiverInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutPlayer1Input = {
    create?: XOR<MatchCreateWithoutPlayer1Input, MatchUncheckedCreateWithoutPlayer1Input> | MatchCreateWithoutPlayer1Input[] | MatchUncheckedCreateWithoutPlayer1Input[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayer1Input | MatchCreateOrConnectWithoutPlayer1Input[]
    createMany?: MatchCreateManyPlayer1InputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutPlayer2Input = {
    create?: XOR<MatchCreateWithoutPlayer2Input, MatchUncheckedCreateWithoutPlayer2Input> | MatchCreateWithoutPlayer2Input[] | MatchUncheckedCreateWithoutPlayer2Input[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayer2Input | MatchCreateOrConnectWithoutPlayer2Input[]
    createMany?: MatchCreateManyPlayer2InputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchCreateNestedManyWithoutWinnerInput = {
    create?: XOR<MatchCreateWithoutWinnerInput, MatchUncheckedCreateWithoutWinnerInput> | MatchCreateWithoutWinnerInput[] | MatchUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutWinnerInput | MatchCreateOrConnectWithoutWinnerInput[]
    createMany?: MatchCreateManyWinnerInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TournamentUserCreateNestedManyWithoutUserInput = {
    create?: XOR<TournamentUserCreateWithoutUserInput, TournamentUserUncheckedCreateWithoutUserInput> | TournamentUserCreateWithoutUserInput[] | TournamentUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutUserInput | TournamentUserCreateOrConnectWithoutUserInput[]
    createMany?: TournamentUserCreateManyUserInputEnvelope
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
  }

  export type BlockedUserUncheckedCreateNestedManyWithoutBlockerInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type BlockedUserUncheckedCreateNestedManyWithoutBlockedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
  }

  export type FriendUncheckedCreateNestedManyWithoutUser1Input = {
    create?: XOR<FriendCreateWithoutUser1Input, FriendUncheckedCreateWithoutUser1Input> | FriendCreateWithoutUser1Input[] | FriendUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: FriendCreateOrConnectWithoutUser1Input | FriendCreateOrConnectWithoutUser1Input[]
    createMany?: FriendCreateManyUser1InputEnvelope
    connect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
  }

  export type FriendUncheckedCreateNestedManyWithoutUser2Input = {
    create?: XOR<FriendCreateWithoutUser2Input, FriendUncheckedCreateWithoutUser2Input> | FriendCreateWithoutUser2Input[] | FriendUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: FriendCreateOrConnectWithoutUser2Input | FriendCreateOrConnectWithoutUser2Input[]
    createMany?: FriendCreateManyUser2InputEnvelope
    connect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<InvitationCreateWithoutSenderInput, InvitationUncheckedCreateWithoutSenderInput> | InvitationCreateWithoutSenderInput[] | InvitationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutSenderInput | InvitationCreateOrConnectWithoutSenderInput[]
    createMany?: InvitationCreateManySenderInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<InvitationCreateWithoutReceiverInput, InvitationUncheckedCreateWithoutReceiverInput> | InvitationCreateWithoutReceiverInput[] | InvitationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutReceiverInput | InvitationCreateOrConnectWithoutReceiverInput[]
    createMany?: InvitationCreateManyReceiverInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutPlayer1Input = {
    create?: XOR<MatchCreateWithoutPlayer1Input, MatchUncheckedCreateWithoutPlayer1Input> | MatchCreateWithoutPlayer1Input[] | MatchUncheckedCreateWithoutPlayer1Input[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayer1Input | MatchCreateOrConnectWithoutPlayer1Input[]
    createMany?: MatchCreateManyPlayer1InputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutPlayer2Input = {
    create?: XOR<MatchCreateWithoutPlayer2Input, MatchUncheckedCreateWithoutPlayer2Input> | MatchCreateWithoutPlayer2Input[] | MatchUncheckedCreateWithoutPlayer2Input[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayer2Input | MatchCreateOrConnectWithoutPlayer2Input[]
    createMany?: MatchCreateManyPlayer2InputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MatchUncheckedCreateNestedManyWithoutWinnerInput = {
    create?: XOR<MatchCreateWithoutWinnerInput, MatchUncheckedCreateWithoutWinnerInput> | MatchCreateWithoutWinnerInput[] | MatchUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutWinnerInput | MatchCreateOrConnectWithoutWinnerInput[]
    createMany?: MatchCreateManyWinnerInputEnvelope
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TournamentUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TournamentUserCreateWithoutUserInput, TournamentUserUncheckedCreateWithoutUserInput> | TournamentUserCreateWithoutUserInput[] | TournamentUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutUserInput | TournamentUserCreateOrConnectWithoutUserInput[]
    createMany?: TournamentUserCreateManyUserInputEnvelope
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Bytes | null
  }

  export type BlockedUserUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockerInput | BlockedUserUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockerInput | BlockedUserUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockerInput | BlockedUserUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlockedUserUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockedInput | BlockedUserUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockedInput | BlockedUserUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockedInput | BlockedUserUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type FriendUpdateManyWithoutUser1NestedInput = {
    create?: XOR<FriendCreateWithoutUser1Input, FriendUncheckedCreateWithoutUser1Input> | FriendCreateWithoutUser1Input[] | FriendUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: FriendCreateOrConnectWithoutUser1Input | FriendCreateOrConnectWithoutUser1Input[]
    upsert?: FriendUpsertWithWhereUniqueWithoutUser1Input | FriendUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: FriendCreateManyUser1InputEnvelope
    set?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    disconnect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    delete?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    connect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    update?: FriendUpdateWithWhereUniqueWithoutUser1Input | FriendUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: FriendUpdateManyWithWhereWithoutUser1Input | FriendUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: FriendScalarWhereInput | FriendScalarWhereInput[]
  }

  export type FriendUpdateManyWithoutUser2NestedInput = {
    create?: XOR<FriendCreateWithoutUser2Input, FriendUncheckedCreateWithoutUser2Input> | FriendCreateWithoutUser2Input[] | FriendUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: FriendCreateOrConnectWithoutUser2Input | FriendCreateOrConnectWithoutUser2Input[]
    upsert?: FriendUpsertWithWhereUniqueWithoutUser2Input | FriendUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: FriendCreateManyUser2InputEnvelope
    set?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    disconnect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    delete?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    connect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    update?: FriendUpdateWithWhereUniqueWithoutUser2Input | FriendUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: FriendUpdateManyWithWhereWithoutUser2Input | FriendUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: FriendScalarWhereInput | FriendScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutSenderNestedInput = {
    create?: XOR<InvitationCreateWithoutSenderInput, InvitationUncheckedCreateWithoutSenderInput> | InvitationCreateWithoutSenderInput[] | InvitationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutSenderInput | InvitationCreateOrConnectWithoutSenderInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutSenderInput | InvitationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: InvitationCreateManySenderInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutSenderInput | InvitationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutSenderInput | InvitationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type InvitationUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<InvitationCreateWithoutReceiverInput, InvitationUncheckedCreateWithoutReceiverInput> | InvitationCreateWithoutReceiverInput[] | InvitationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutReceiverInput | InvitationCreateOrConnectWithoutReceiverInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutReceiverInput | InvitationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: InvitationCreateManyReceiverInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutReceiverInput | InvitationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutReceiverInput | InvitationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutPlayer1NestedInput = {
    create?: XOR<MatchCreateWithoutPlayer1Input, MatchUncheckedCreateWithoutPlayer1Input> | MatchCreateWithoutPlayer1Input[] | MatchUncheckedCreateWithoutPlayer1Input[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayer1Input | MatchCreateOrConnectWithoutPlayer1Input[]
    upsert?: MatchUpsertWithWhereUniqueWithoutPlayer1Input | MatchUpsertWithWhereUniqueWithoutPlayer1Input[]
    createMany?: MatchCreateManyPlayer1InputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutPlayer1Input | MatchUpdateWithWhereUniqueWithoutPlayer1Input[]
    updateMany?: MatchUpdateManyWithWhereWithoutPlayer1Input | MatchUpdateManyWithWhereWithoutPlayer1Input[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutPlayer2NestedInput = {
    create?: XOR<MatchCreateWithoutPlayer2Input, MatchUncheckedCreateWithoutPlayer2Input> | MatchCreateWithoutPlayer2Input[] | MatchUncheckedCreateWithoutPlayer2Input[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayer2Input | MatchCreateOrConnectWithoutPlayer2Input[]
    upsert?: MatchUpsertWithWhereUniqueWithoutPlayer2Input | MatchUpsertWithWhereUniqueWithoutPlayer2Input[]
    createMany?: MatchCreateManyPlayer2InputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutPlayer2Input | MatchUpdateWithWhereUniqueWithoutPlayer2Input[]
    updateMany?: MatchUpdateManyWithWhereWithoutPlayer2Input | MatchUpdateManyWithWhereWithoutPlayer2Input[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<MatchCreateWithoutWinnerInput, MatchUncheckedCreateWithoutWinnerInput> | MatchCreateWithoutWinnerInput[] | MatchUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutWinnerInput | MatchCreateOrConnectWithoutWinnerInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutWinnerInput | MatchUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: MatchCreateManyWinnerInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutWinnerInput | MatchUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutWinnerInput | MatchUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TournamentUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<TournamentUserCreateWithoutUserInput, TournamentUserUncheckedCreateWithoutUserInput> | TournamentUserCreateWithoutUserInput[] | TournamentUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutUserInput | TournamentUserCreateOrConnectWithoutUserInput[]
    upsert?: TournamentUserUpsertWithWhereUniqueWithoutUserInput | TournamentUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TournamentUserCreateManyUserInputEnvelope
    set?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    disconnect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    delete?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    update?: TournamentUserUpdateWithWhereUniqueWithoutUserInput | TournamentUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TournamentUserUpdateManyWithWhereWithoutUserInput | TournamentUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TournamentUserScalarWhereInput | TournamentUserScalarWhereInput[]
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput> | BlockedUserCreateWithoutBlockerInput[] | BlockedUserUncheckedCreateWithoutBlockerInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockerInput | BlockedUserCreateOrConnectWithoutBlockerInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockerInput | BlockedUserUpsertWithWhereUniqueWithoutBlockerInput[]
    createMany?: BlockedUserCreateManyBlockerInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockerInput | BlockedUserUpdateWithWhereUniqueWithoutBlockerInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockerInput | BlockedUserUpdateManyWithWhereWithoutBlockerInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput = {
    create?: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput> | BlockedUserCreateWithoutBlockedInput[] | BlockedUserUncheckedCreateWithoutBlockedInput[]
    connectOrCreate?: BlockedUserCreateOrConnectWithoutBlockedInput | BlockedUserCreateOrConnectWithoutBlockedInput[]
    upsert?: BlockedUserUpsertWithWhereUniqueWithoutBlockedInput | BlockedUserUpsertWithWhereUniqueWithoutBlockedInput[]
    createMany?: BlockedUserCreateManyBlockedInputEnvelope
    set?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    disconnect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    delete?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    connect?: BlockedUserWhereUniqueInput | BlockedUserWhereUniqueInput[]
    update?: BlockedUserUpdateWithWhereUniqueWithoutBlockedInput | BlockedUserUpdateWithWhereUniqueWithoutBlockedInput[]
    updateMany?: BlockedUserUpdateManyWithWhereWithoutBlockedInput | BlockedUserUpdateManyWithWhereWithoutBlockedInput[]
    deleteMany?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
  }

  export type FriendUncheckedUpdateManyWithoutUser1NestedInput = {
    create?: XOR<FriendCreateWithoutUser1Input, FriendUncheckedCreateWithoutUser1Input> | FriendCreateWithoutUser1Input[] | FriendUncheckedCreateWithoutUser1Input[]
    connectOrCreate?: FriendCreateOrConnectWithoutUser1Input | FriendCreateOrConnectWithoutUser1Input[]
    upsert?: FriendUpsertWithWhereUniqueWithoutUser1Input | FriendUpsertWithWhereUniqueWithoutUser1Input[]
    createMany?: FriendCreateManyUser1InputEnvelope
    set?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    disconnect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    delete?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    connect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    update?: FriendUpdateWithWhereUniqueWithoutUser1Input | FriendUpdateWithWhereUniqueWithoutUser1Input[]
    updateMany?: FriendUpdateManyWithWhereWithoutUser1Input | FriendUpdateManyWithWhereWithoutUser1Input[]
    deleteMany?: FriendScalarWhereInput | FriendScalarWhereInput[]
  }

  export type FriendUncheckedUpdateManyWithoutUser2NestedInput = {
    create?: XOR<FriendCreateWithoutUser2Input, FriendUncheckedCreateWithoutUser2Input> | FriendCreateWithoutUser2Input[] | FriendUncheckedCreateWithoutUser2Input[]
    connectOrCreate?: FriendCreateOrConnectWithoutUser2Input | FriendCreateOrConnectWithoutUser2Input[]
    upsert?: FriendUpsertWithWhereUniqueWithoutUser2Input | FriendUpsertWithWhereUniqueWithoutUser2Input[]
    createMany?: FriendCreateManyUser2InputEnvelope
    set?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    disconnect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    delete?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    connect?: FriendWhereUniqueInput | FriendWhereUniqueInput[]
    update?: FriendUpdateWithWhereUniqueWithoutUser2Input | FriendUpdateWithWhereUniqueWithoutUser2Input[]
    updateMany?: FriendUpdateManyWithWhereWithoutUser2Input | FriendUpdateManyWithWhereWithoutUser2Input[]
    deleteMany?: FriendScalarWhereInput | FriendScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<InvitationCreateWithoutSenderInput, InvitationUncheckedCreateWithoutSenderInput> | InvitationCreateWithoutSenderInput[] | InvitationUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutSenderInput | InvitationCreateOrConnectWithoutSenderInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutSenderInput | InvitationUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: InvitationCreateManySenderInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutSenderInput | InvitationUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutSenderInput | InvitationUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type InvitationUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<InvitationCreateWithoutReceiverInput, InvitationUncheckedCreateWithoutReceiverInput> | InvitationCreateWithoutReceiverInput[] | InvitationUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutReceiverInput | InvitationCreateOrConnectWithoutReceiverInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutReceiverInput | InvitationUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: InvitationCreateManyReceiverInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutReceiverInput | InvitationUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutReceiverInput | InvitationUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutPlayer1NestedInput = {
    create?: XOR<MatchCreateWithoutPlayer1Input, MatchUncheckedCreateWithoutPlayer1Input> | MatchCreateWithoutPlayer1Input[] | MatchUncheckedCreateWithoutPlayer1Input[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayer1Input | MatchCreateOrConnectWithoutPlayer1Input[]
    upsert?: MatchUpsertWithWhereUniqueWithoutPlayer1Input | MatchUpsertWithWhereUniqueWithoutPlayer1Input[]
    createMany?: MatchCreateManyPlayer1InputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutPlayer1Input | MatchUpdateWithWhereUniqueWithoutPlayer1Input[]
    updateMany?: MatchUpdateManyWithWhereWithoutPlayer1Input | MatchUpdateManyWithWhereWithoutPlayer1Input[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutPlayer2NestedInput = {
    create?: XOR<MatchCreateWithoutPlayer2Input, MatchUncheckedCreateWithoutPlayer2Input> | MatchCreateWithoutPlayer2Input[] | MatchUncheckedCreateWithoutPlayer2Input[]
    connectOrCreate?: MatchCreateOrConnectWithoutPlayer2Input | MatchCreateOrConnectWithoutPlayer2Input[]
    upsert?: MatchUpsertWithWhereUniqueWithoutPlayer2Input | MatchUpsertWithWhereUniqueWithoutPlayer2Input[]
    createMany?: MatchCreateManyPlayer2InputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutPlayer2Input | MatchUpdateWithWhereUniqueWithoutPlayer2Input[]
    updateMany?: MatchUpdateManyWithWhereWithoutPlayer2Input | MatchUpdateManyWithWhereWithoutPlayer2Input[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MatchUncheckedUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<MatchCreateWithoutWinnerInput, MatchUncheckedCreateWithoutWinnerInput> | MatchCreateWithoutWinnerInput[] | MatchUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: MatchCreateOrConnectWithoutWinnerInput | MatchCreateOrConnectWithoutWinnerInput[]
    upsert?: MatchUpsertWithWhereUniqueWithoutWinnerInput | MatchUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: MatchCreateManyWinnerInputEnvelope
    set?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    disconnect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    delete?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    connect?: MatchWhereUniqueInput | MatchWhereUniqueInput[]
    update?: MatchUpdateWithWhereUniqueWithoutWinnerInput | MatchUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: MatchUpdateManyWithWhereWithoutWinnerInput | MatchUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: MatchScalarWhereInput | MatchScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TournamentUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TournamentUserCreateWithoutUserInput, TournamentUserUncheckedCreateWithoutUserInput> | TournamentUserCreateWithoutUserInput[] | TournamentUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutUserInput | TournamentUserCreateOrConnectWithoutUserInput[]
    upsert?: TournamentUserUpsertWithWhereUniqueWithoutUserInput | TournamentUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TournamentUserCreateManyUserInputEnvelope
    set?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    disconnect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    delete?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    update?: TournamentUserUpdateWithWhereUniqueWithoutUserInput | TournamentUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TournamentUserUpdateManyWithWhereWithoutUserInput | TournamentUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TournamentUserScalarWhereInput | TournamentUserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBlockedByInput = {
    create?: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBlockedInput = {
    create?: XOR<UserCreateWithoutBlockedInput, UserUncheckedCreateWithoutBlockedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBlockedByNestedInput = {
    create?: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedByInput
    upsert?: UserUpsertWithoutBlockedByInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedByInput, UserUpdateWithoutBlockedByInput>, UserUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserUpdateOneRequiredWithoutBlockedNestedInput = {
    create?: XOR<UserCreateWithoutBlockedInput, UserUncheckedCreateWithoutBlockedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBlockedInput
    upsert?: UserUpsertWithoutBlockedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBlockedInput, UserUpdateWithoutBlockedInput>, UserUncheckedUpdateWithoutBlockedInput>
  }

  export type UserCreateNestedOneWithoutFriends1Input = {
    create?: XOR<UserCreateWithoutFriends1Input, UserUncheckedCreateWithoutFriends1Input>
    connectOrCreate?: UserCreateOrConnectWithoutFriends1Input
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFriends2Input = {
    create?: XOR<UserCreateWithoutFriends2Input, UserUncheckedCreateWithoutFriends2Input>
    connectOrCreate?: UserCreateOrConnectWithoutFriends2Input
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFriends1NestedInput = {
    create?: XOR<UserCreateWithoutFriends1Input, UserUncheckedCreateWithoutFriends1Input>
    connectOrCreate?: UserCreateOrConnectWithoutFriends1Input
    upsert?: UserUpsertWithoutFriends1Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriends1Input, UserUpdateWithoutFriends1Input>, UserUncheckedUpdateWithoutFriends1Input>
  }

  export type UserUpdateOneRequiredWithoutFriends2NestedInput = {
    create?: XOR<UserCreateWithoutFriends2Input, UserUncheckedCreateWithoutFriends2Input>
    connectOrCreate?: UserCreateOrConnectWithoutFriends2Input
    upsert?: UserUpsertWithoutFriends2Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFriends2Input, UserUpdateWithoutFriends2Input>, UserUncheckedUpdateWithoutFriends2Input>
  }

  export type UserCreateNestedOneWithoutInvitationsSentInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsReceivedInput = {
    create?: XOR<UserCreateWithoutInvitationsReceivedInput, UserUncheckedCreateWithoutInvitationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type MatchCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<MatchCreateWithoutInvitationsInput, MatchUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutInvitationsInput
    connect?: MatchWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutInvitationsSentNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsSentInput
    upsert?: UserUpsertWithoutInvitationsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsSentInput, UserUpdateWithoutInvitationsSentInput>, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type UserUpdateOneRequiredWithoutInvitationsReceivedNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsReceivedInput, UserUncheckedCreateWithoutInvitationsReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsReceivedInput
    upsert?: UserUpsertWithoutInvitationsReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsReceivedInput, UserUpdateWithoutInvitationsReceivedInput>, UserUncheckedUpdateWithoutInvitationsReceivedInput>
  }

  export type MatchUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<MatchCreateWithoutInvitationsInput, MatchUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: MatchCreateOrConnectWithoutInvitationsInput
    upsert?: MatchUpsertWithoutInvitationsInput
    connect?: MatchWhereUniqueInput
    update?: XOR<XOR<MatchUpdateToOneWithWhereWithoutInvitationsInput, MatchUpdateWithoutInvitationsInput>, MatchUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserCreateNestedOneWithoutMatchesAsPlayer1Input = {
    create?: XOR<UserCreateWithoutMatchesAsPlayer1Input, UserUncheckedCreateWithoutMatchesAsPlayer1Input>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsPlayer1Input
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchesAsPlayer2Input = {
    create?: XOR<UserCreateWithoutMatchesAsPlayer2Input, UserUncheckedCreateWithoutMatchesAsPlayer2Input>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsPlayer2Input
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMatchesAsWinnerInput = {
    create?: XOR<UserCreateWithoutMatchesAsWinnerInput, UserUncheckedCreateWithoutMatchesAsWinnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsWinnerInput
    connect?: UserWhereUniqueInput
  }

  export type InvitationCreateNestedManyWithoutMatchInput = {
    create?: XOR<InvitationCreateWithoutMatchInput, InvitationUncheckedCreateWithoutMatchInput> | InvitationCreateWithoutMatchInput[] | InvitationUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutMatchInput | InvitationCreateOrConnectWithoutMatchInput[]
    createMany?: InvitationCreateManyMatchInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type InvitationUncheckedCreateNestedManyWithoutMatchInput = {
    create?: XOR<InvitationCreateWithoutMatchInput, InvitationUncheckedCreateWithoutMatchInput> | InvitationCreateWithoutMatchInput[] | InvitationUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutMatchInput | InvitationCreateOrConnectWithoutMatchInput[]
    createMany?: InvitationCreateManyMatchInputEnvelope
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput = {
    create?: XOR<UserCreateWithoutMatchesAsPlayer1Input, UserUncheckedCreateWithoutMatchesAsPlayer1Input>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsPlayer1Input
    upsert?: UserUpsertWithoutMatchesAsPlayer1Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchesAsPlayer1Input, UserUpdateWithoutMatchesAsPlayer1Input>, UserUncheckedUpdateWithoutMatchesAsPlayer1Input>
  }

  export type UserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput = {
    create?: XOR<UserCreateWithoutMatchesAsPlayer2Input, UserUncheckedCreateWithoutMatchesAsPlayer2Input>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsPlayer2Input
    upsert?: UserUpsertWithoutMatchesAsPlayer2Input
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchesAsPlayer2Input, UserUpdateWithoutMatchesAsPlayer2Input>, UserUncheckedUpdateWithoutMatchesAsPlayer2Input>
  }

  export type UserUpdateOneWithoutMatchesAsWinnerNestedInput = {
    create?: XOR<UserCreateWithoutMatchesAsWinnerInput, UserUncheckedCreateWithoutMatchesAsWinnerInput>
    connectOrCreate?: UserCreateOrConnectWithoutMatchesAsWinnerInput
    upsert?: UserUpsertWithoutMatchesAsWinnerInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMatchesAsWinnerInput, UserUpdateWithoutMatchesAsWinnerInput>, UserUncheckedUpdateWithoutMatchesAsWinnerInput>
  }

  export type InvitationUpdateManyWithoutMatchNestedInput = {
    create?: XOR<InvitationCreateWithoutMatchInput, InvitationUncheckedCreateWithoutMatchInput> | InvitationCreateWithoutMatchInput[] | InvitationUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutMatchInput | InvitationCreateOrConnectWithoutMatchInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutMatchInput | InvitationUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: InvitationCreateManyMatchInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutMatchInput | InvitationUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutMatchInput | InvitationUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InvitationUncheckedUpdateManyWithoutMatchNestedInput = {
    create?: XOR<InvitationCreateWithoutMatchInput, InvitationUncheckedCreateWithoutMatchInput> | InvitationCreateWithoutMatchInput[] | InvitationUncheckedCreateWithoutMatchInput[]
    connectOrCreate?: InvitationCreateOrConnectWithoutMatchInput | InvitationCreateOrConnectWithoutMatchInput[]
    upsert?: InvitationUpsertWithWhereUniqueWithoutMatchInput | InvitationUpsertWithWhereUniqueWithoutMatchInput[]
    createMany?: InvitationCreateManyMatchInputEnvelope
    set?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    disconnect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    delete?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    connect?: InvitationWhereUniqueInput | InvitationWhereUniqueInput[]
    update?: InvitationUpdateWithWhereUniqueWithoutMatchInput | InvitationUpdateWithWhereUniqueWithoutMatchInput[]
    updateMany?: InvitationUpdateManyWithWhereWithoutMatchInput | InvitationUpdateManyWithWhereWithoutMatchInput[]
    deleteMany?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMessagesSentInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesReceivedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMessagesSentNestedInput = {
    create?: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesSentInput
    upsert?: UserUpsertWithoutMessagesSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesSentInput, UserUpdateWithoutMessagesSentInput>, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesReceivedNestedInput = {
    create?: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesReceivedInput
    upsert?: UserUpsertWithoutMessagesReceivedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesReceivedInput, UserUpdateWithoutMessagesReceivedInput>, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type TournamentUserCreateNestedOneWithoutTournamentsAsWinnerInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentsAsWinnerInput, TournamentUserUncheckedCreateWithoutTournamentsAsWinnerInput>
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentsAsWinnerInput
    connect?: TournamentUserWhereUniqueInput
  }

  export type TournamentMatchCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentMatchCreateWithoutTournamentInput, TournamentMatchUncheckedCreateWithoutTournamentInput> | TournamentMatchCreateWithoutTournamentInput[] | TournamentMatchUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentInput | TournamentMatchCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentMatchCreateManyTournamentInputEnvelope
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
  }

  export type TournamentUserCreateNestedManyWithoutTournamentsInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentsInput, TournamentUserUncheckedCreateWithoutTournamentsInput> | TournamentUserCreateWithoutTournamentsInput[] | TournamentUserUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentsInput | TournamentUserCreateOrConnectWithoutTournamentsInput[]
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
  }

  export type TournamentUserCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentInput, TournamentUserUncheckedCreateWithoutTournamentInput> | TournamentUserCreateWithoutTournamentInput[] | TournamentUserUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentInput | TournamentUserCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentUserCreateManyTournamentInputEnvelope
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
  }

  export type TournamentMatchUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentMatchCreateWithoutTournamentInput, TournamentMatchUncheckedCreateWithoutTournamentInput> | TournamentMatchCreateWithoutTournamentInput[] | TournamentMatchUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentInput | TournamentMatchCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentMatchCreateManyTournamentInputEnvelope
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
  }

  export type TournamentUserUncheckedCreateNestedManyWithoutTournamentsInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentsInput, TournamentUserUncheckedCreateWithoutTournamentsInput> | TournamentUserCreateWithoutTournamentsInput[] | TournamentUserUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentsInput | TournamentUserCreateOrConnectWithoutTournamentsInput[]
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
  }

  export type TournamentUserUncheckedCreateNestedManyWithoutTournamentInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentInput, TournamentUserUncheckedCreateWithoutTournamentInput> | TournamentUserCreateWithoutTournamentInput[] | TournamentUserUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentInput | TournamentUserCreateOrConnectWithoutTournamentInput[]
    createMany?: TournamentUserCreateManyTournamentInputEnvelope
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
  }

  export type TournamentUserUpdateOneWithoutTournamentsAsWinnerNestedInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentsAsWinnerInput, TournamentUserUncheckedCreateWithoutTournamentsAsWinnerInput>
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentsAsWinnerInput
    upsert?: TournamentUserUpsertWithoutTournamentsAsWinnerInput
    disconnect?: TournamentUserWhereInput | boolean
    delete?: TournamentUserWhereInput | boolean
    connect?: TournamentUserWhereUniqueInput
    update?: XOR<XOR<TournamentUserUpdateToOneWithWhereWithoutTournamentsAsWinnerInput, TournamentUserUpdateWithoutTournamentsAsWinnerInput>, TournamentUserUncheckedUpdateWithoutTournamentsAsWinnerInput>
  }

  export type TournamentMatchUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentMatchCreateWithoutTournamentInput, TournamentMatchUncheckedCreateWithoutTournamentInput> | TournamentMatchCreateWithoutTournamentInput[] | TournamentMatchUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentInput | TournamentMatchCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentMatchUpsertWithWhereUniqueWithoutTournamentInput | TournamentMatchUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentMatchCreateManyTournamentInputEnvelope
    set?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    disconnect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    delete?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    update?: TournamentMatchUpdateWithWhereUniqueWithoutTournamentInput | TournamentMatchUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentMatchUpdateManyWithWhereWithoutTournamentInput | TournamentMatchUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
  }

  export type TournamentUserUpdateManyWithoutTournamentsNestedInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentsInput, TournamentUserUncheckedCreateWithoutTournamentsInput> | TournamentUserCreateWithoutTournamentsInput[] | TournamentUserUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentsInput | TournamentUserCreateOrConnectWithoutTournamentsInput[]
    upsert?: TournamentUserUpsertWithWhereUniqueWithoutTournamentsInput | TournamentUserUpsertWithWhereUniqueWithoutTournamentsInput[]
    set?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    disconnect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    delete?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    update?: TournamentUserUpdateWithWhereUniqueWithoutTournamentsInput | TournamentUserUpdateWithWhereUniqueWithoutTournamentsInput[]
    updateMany?: TournamentUserUpdateManyWithWhereWithoutTournamentsInput | TournamentUserUpdateManyWithWhereWithoutTournamentsInput[]
    deleteMany?: TournamentUserScalarWhereInput | TournamentUserScalarWhereInput[]
  }

  export type TournamentUserUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentInput, TournamentUserUncheckedCreateWithoutTournamentInput> | TournamentUserCreateWithoutTournamentInput[] | TournamentUserUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentInput | TournamentUserCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentUserUpsertWithWhereUniqueWithoutTournamentInput | TournamentUserUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentUserCreateManyTournamentInputEnvelope
    set?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    disconnect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    delete?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    update?: TournamentUserUpdateWithWhereUniqueWithoutTournamentInput | TournamentUserUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentUserUpdateManyWithWhereWithoutTournamentInput | TournamentUserUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentUserScalarWhereInput | TournamentUserScalarWhereInput[]
  }

  export type TournamentMatchUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentMatchCreateWithoutTournamentInput, TournamentMatchUncheckedCreateWithoutTournamentInput> | TournamentMatchCreateWithoutTournamentInput[] | TournamentMatchUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutTournamentInput | TournamentMatchCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentMatchUpsertWithWhereUniqueWithoutTournamentInput | TournamentMatchUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentMatchCreateManyTournamentInputEnvelope
    set?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    disconnect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    delete?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    update?: TournamentMatchUpdateWithWhereUniqueWithoutTournamentInput | TournamentMatchUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentMatchUpdateManyWithWhereWithoutTournamentInput | TournamentMatchUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
  }

  export type TournamentUserUncheckedUpdateManyWithoutTournamentsNestedInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentsInput, TournamentUserUncheckedCreateWithoutTournamentsInput> | TournamentUserCreateWithoutTournamentsInput[] | TournamentUserUncheckedCreateWithoutTournamentsInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentsInput | TournamentUserCreateOrConnectWithoutTournamentsInput[]
    upsert?: TournamentUserUpsertWithWhereUniqueWithoutTournamentsInput | TournamentUserUpsertWithWhereUniqueWithoutTournamentsInput[]
    set?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    disconnect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    delete?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    update?: TournamentUserUpdateWithWhereUniqueWithoutTournamentsInput | TournamentUserUpdateWithWhereUniqueWithoutTournamentsInput[]
    updateMany?: TournamentUserUpdateManyWithWhereWithoutTournamentsInput | TournamentUserUpdateManyWithWhereWithoutTournamentsInput[]
    deleteMany?: TournamentUserScalarWhereInput | TournamentUserScalarWhereInput[]
  }

  export type TournamentUserUncheckedUpdateManyWithoutTournamentNestedInput = {
    create?: XOR<TournamentUserCreateWithoutTournamentInput, TournamentUserUncheckedCreateWithoutTournamentInput> | TournamentUserCreateWithoutTournamentInput[] | TournamentUserUncheckedCreateWithoutTournamentInput[]
    connectOrCreate?: TournamentUserCreateOrConnectWithoutTournamentInput | TournamentUserCreateOrConnectWithoutTournamentInput[]
    upsert?: TournamentUserUpsertWithWhereUniqueWithoutTournamentInput | TournamentUserUpsertWithWhereUniqueWithoutTournamentInput[]
    createMany?: TournamentUserCreateManyTournamentInputEnvelope
    set?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    disconnect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    delete?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    connect?: TournamentUserWhereUniqueInput | TournamentUserWhereUniqueInput[]
    update?: TournamentUserUpdateWithWhereUniqueWithoutTournamentInput | TournamentUserUpdateWithWhereUniqueWithoutTournamentInput[]
    updateMany?: TournamentUserUpdateManyWithWhereWithoutTournamentInput | TournamentUserUpdateManyWithWhereWithoutTournamentInput[]
    deleteMany?: TournamentUserScalarWhereInput | TournamentUserScalarWhereInput[]
  }

  export type TournamentCreateNestedOneWithoutMatchesInput = {
    create?: XOR<TournamentCreateWithoutMatchesInput, TournamentUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutMatchesInput
    connect?: TournamentWhereUniqueInput
  }

  export type TournamentUserCreateNestedOneWithoutMatchesAsPlayer1Input = {
    create?: XOR<TournamentUserCreateWithoutMatchesAsPlayer1Input, TournamentUserUncheckedCreateWithoutMatchesAsPlayer1Input>
    connectOrCreate?: TournamentUserCreateOrConnectWithoutMatchesAsPlayer1Input
    connect?: TournamentUserWhereUniqueInput
  }

  export type TournamentUserCreateNestedOneWithoutMatchesAsPlayer2Input = {
    create?: XOR<TournamentUserCreateWithoutMatchesAsPlayer2Input, TournamentUserUncheckedCreateWithoutMatchesAsPlayer2Input>
    connectOrCreate?: TournamentUserCreateOrConnectWithoutMatchesAsPlayer2Input
    connect?: TournamentUserWhereUniqueInput
  }

  export type TournamentUserCreateNestedOneWithoutMatchesAsWinnerInput = {
    create?: XOR<TournamentUserCreateWithoutMatchesAsWinnerInput, TournamentUserUncheckedCreateWithoutMatchesAsWinnerInput>
    connectOrCreate?: TournamentUserCreateOrConnectWithoutMatchesAsWinnerInput
    connect?: TournamentUserWhereUniqueInput
  }

  export type TournamentUpdateOneRequiredWithoutMatchesNestedInput = {
    create?: XOR<TournamentCreateWithoutMatchesInput, TournamentUncheckedCreateWithoutMatchesInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutMatchesInput
    upsert?: TournamentUpsertWithoutMatchesInput
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutMatchesInput, TournamentUpdateWithoutMatchesInput>, TournamentUncheckedUpdateWithoutMatchesInput>
  }

  export type TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput = {
    create?: XOR<TournamentUserCreateWithoutMatchesAsPlayer1Input, TournamentUserUncheckedCreateWithoutMatchesAsPlayer1Input>
    connectOrCreate?: TournamentUserCreateOrConnectWithoutMatchesAsPlayer1Input
    upsert?: TournamentUserUpsertWithoutMatchesAsPlayer1Input
    connect?: TournamentUserWhereUniqueInput
    update?: XOR<XOR<TournamentUserUpdateToOneWithWhereWithoutMatchesAsPlayer1Input, TournamentUserUpdateWithoutMatchesAsPlayer1Input>, TournamentUserUncheckedUpdateWithoutMatchesAsPlayer1Input>
  }

  export type TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput = {
    create?: XOR<TournamentUserCreateWithoutMatchesAsPlayer2Input, TournamentUserUncheckedCreateWithoutMatchesAsPlayer2Input>
    connectOrCreate?: TournamentUserCreateOrConnectWithoutMatchesAsPlayer2Input
    upsert?: TournamentUserUpsertWithoutMatchesAsPlayer2Input
    connect?: TournamentUserWhereUniqueInput
    update?: XOR<XOR<TournamentUserUpdateToOneWithWhereWithoutMatchesAsPlayer2Input, TournamentUserUpdateWithoutMatchesAsPlayer2Input>, TournamentUserUncheckedUpdateWithoutMatchesAsPlayer2Input>
  }

  export type TournamentUserUpdateOneWithoutMatchesAsWinnerNestedInput = {
    create?: XOR<TournamentUserCreateWithoutMatchesAsWinnerInput, TournamentUserUncheckedCreateWithoutMatchesAsWinnerInput>
    connectOrCreate?: TournamentUserCreateOrConnectWithoutMatchesAsWinnerInput
    upsert?: TournamentUserUpsertWithoutMatchesAsWinnerInput
    disconnect?: TournamentUserWhereInput | boolean
    delete?: TournamentUserWhereInput | boolean
    connect?: TournamentUserWhereUniqueInput
    update?: XOR<XOR<TournamentUserUpdateToOneWithWhereWithoutMatchesAsWinnerInput, TournamentUserUpdateWithoutMatchesAsWinnerInput>, TournamentUserUncheckedUpdateWithoutMatchesAsWinnerInput>
  }

  export type UserCreateNestedOneWithoutTournamentUsersInput = {
    create?: XOR<UserCreateWithoutTournamentUsersInput, UserUncheckedCreateWithoutTournamentUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamentUsersInput
    connect?: UserWhereUniqueInput
  }

  export type TournamentCreateNestedOneWithoutTournamentUsersInput = {
    create?: XOR<TournamentCreateWithoutTournamentUsersInput, TournamentUncheckedCreateWithoutTournamentUsersInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentUsersInput
    connect?: TournamentWhereUniqueInput
  }

  export type TournamentMatchCreateNestedManyWithoutPlayer1Input = {
    create?: XOR<TournamentMatchCreateWithoutPlayer1Input, TournamentMatchUncheckedCreateWithoutPlayer1Input> | TournamentMatchCreateWithoutPlayer1Input[] | TournamentMatchUncheckedCreateWithoutPlayer1Input[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutPlayer1Input | TournamentMatchCreateOrConnectWithoutPlayer1Input[]
    createMany?: TournamentMatchCreateManyPlayer1InputEnvelope
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
  }

  export type TournamentMatchCreateNestedManyWithoutPlayer2Input = {
    create?: XOR<TournamentMatchCreateWithoutPlayer2Input, TournamentMatchUncheckedCreateWithoutPlayer2Input> | TournamentMatchCreateWithoutPlayer2Input[] | TournamentMatchUncheckedCreateWithoutPlayer2Input[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutPlayer2Input | TournamentMatchCreateOrConnectWithoutPlayer2Input[]
    createMany?: TournamentMatchCreateManyPlayer2InputEnvelope
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
  }

  export type TournamentMatchCreateNestedManyWithoutWinnerInput = {
    create?: XOR<TournamentMatchCreateWithoutWinnerInput, TournamentMatchUncheckedCreateWithoutWinnerInput> | TournamentMatchCreateWithoutWinnerInput[] | TournamentMatchUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutWinnerInput | TournamentMatchCreateOrConnectWithoutWinnerInput[]
    createMany?: TournamentMatchCreateManyWinnerInputEnvelope
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
  }

  export type TournamentCreateNestedManyWithoutUsersInput = {
    create?: XOR<TournamentCreateWithoutUsersInput, TournamentUncheckedCreateWithoutUsersInput> | TournamentCreateWithoutUsersInput[] | TournamentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutUsersInput | TournamentCreateOrConnectWithoutUsersInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
  }

  export type TournamentCreateNestedManyWithoutWinnerInput = {
    create?: XOR<TournamentCreateWithoutWinnerInput, TournamentUncheckedCreateWithoutWinnerInput> | TournamentCreateWithoutWinnerInput[] | TournamentUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutWinnerInput | TournamentCreateOrConnectWithoutWinnerInput[]
    createMany?: TournamentCreateManyWinnerInputEnvelope
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
  }

  export type TournamentMatchUncheckedCreateNestedManyWithoutPlayer1Input = {
    create?: XOR<TournamentMatchCreateWithoutPlayer1Input, TournamentMatchUncheckedCreateWithoutPlayer1Input> | TournamentMatchCreateWithoutPlayer1Input[] | TournamentMatchUncheckedCreateWithoutPlayer1Input[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutPlayer1Input | TournamentMatchCreateOrConnectWithoutPlayer1Input[]
    createMany?: TournamentMatchCreateManyPlayer1InputEnvelope
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
  }

  export type TournamentMatchUncheckedCreateNestedManyWithoutPlayer2Input = {
    create?: XOR<TournamentMatchCreateWithoutPlayer2Input, TournamentMatchUncheckedCreateWithoutPlayer2Input> | TournamentMatchCreateWithoutPlayer2Input[] | TournamentMatchUncheckedCreateWithoutPlayer2Input[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutPlayer2Input | TournamentMatchCreateOrConnectWithoutPlayer2Input[]
    createMany?: TournamentMatchCreateManyPlayer2InputEnvelope
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
  }

  export type TournamentMatchUncheckedCreateNestedManyWithoutWinnerInput = {
    create?: XOR<TournamentMatchCreateWithoutWinnerInput, TournamentMatchUncheckedCreateWithoutWinnerInput> | TournamentMatchCreateWithoutWinnerInput[] | TournamentMatchUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutWinnerInput | TournamentMatchCreateOrConnectWithoutWinnerInput[]
    createMany?: TournamentMatchCreateManyWinnerInputEnvelope
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
  }

  export type TournamentUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<TournamentCreateWithoutUsersInput, TournamentUncheckedCreateWithoutUsersInput> | TournamentCreateWithoutUsersInput[] | TournamentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutUsersInput | TournamentCreateOrConnectWithoutUsersInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
  }

  export type TournamentUncheckedCreateNestedManyWithoutWinnerInput = {
    create?: XOR<TournamentCreateWithoutWinnerInput, TournamentUncheckedCreateWithoutWinnerInput> | TournamentCreateWithoutWinnerInput[] | TournamentUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutWinnerInput | TournamentCreateOrConnectWithoutWinnerInput[]
    createMany?: TournamentCreateManyWinnerInputEnvelope
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTournamentUsersNestedInput = {
    create?: XOR<UserCreateWithoutTournamentUsersInput, UserUncheckedCreateWithoutTournamentUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTournamentUsersInput
    upsert?: UserUpsertWithoutTournamentUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTournamentUsersInput, UserUpdateWithoutTournamentUsersInput>, UserUncheckedUpdateWithoutTournamentUsersInput>
  }

  export type TournamentUpdateOneRequiredWithoutTournamentUsersNestedInput = {
    create?: XOR<TournamentCreateWithoutTournamentUsersInput, TournamentUncheckedCreateWithoutTournamentUsersInput>
    connectOrCreate?: TournamentCreateOrConnectWithoutTournamentUsersInput
    upsert?: TournamentUpsertWithoutTournamentUsersInput
    connect?: TournamentWhereUniqueInput
    update?: XOR<XOR<TournamentUpdateToOneWithWhereWithoutTournamentUsersInput, TournamentUpdateWithoutTournamentUsersInput>, TournamentUncheckedUpdateWithoutTournamentUsersInput>
  }

  export type TournamentMatchUpdateManyWithoutPlayer1NestedInput = {
    create?: XOR<TournamentMatchCreateWithoutPlayer1Input, TournamentMatchUncheckedCreateWithoutPlayer1Input> | TournamentMatchCreateWithoutPlayer1Input[] | TournamentMatchUncheckedCreateWithoutPlayer1Input[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutPlayer1Input | TournamentMatchCreateOrConnectWithoutPlayer1Input[]
    upsert?: TournamentMatchUpsertWithWhereUniqueWithoutPlayer1Input | TournamentMatchUpsertWithWhereUniqueWithoutPlayer1Input[]
    createMany?: TournamentMatchCreateManyPlayer1InputEnvelope
    set?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    disconnect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    delete?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    update?: TournamentMatchUpdateWithWhereUniqueWithoutPlayer1Input | TournamentMatchUpdateWithWhereUniqueWithoutPlayer1Input[]
    updateMany?: TournamentMatchUpdateManyWithWhereWithoutPlayer1Input | TournamentMatchUpdateManyWithWhereWithoutPlayer1Input[]
    deleteMany?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
  }

  export type TournamentMatchUpdateManyWithoutPlayer2NestedInput = {
    create?: XOR<TournamentMatchCreateWithoutPlayer2Input, TournamentMatchUncheckedCreateWithoutPlayer2Input> | TournamentMatchCreateWithoutPlayer2Input[] | TournamentMatchUncheckedCreateWithoutPlayer2Input[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutPlayer2Input | TournamentMatchCreateOrConnectWithoutPlayer2Input[]
    upsert?: TournamentMatchUpsertWithWhereUniqueWithoutPlayer2Input | TournamentMatchUpsertWithWhereUniqueWithoutPlayer2Input[]
    createMany?: TournamentMatchCreateManyPlayer2InputEnvelope
    set?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    disconnect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    delete?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    update?: TournamentMatchUpdateWithWhereUniqueWithoutPlayer2Input | TournamentMatchUpdateWithWhereUniqueWithoutPlayer2Input[]
    updateMany?: TournamentMatchUpdateManyWithWhereWithoutPlayer2Input | TournamentMatchUpdateManyWithWhereWithoutPlayer2Input[]
    deleteMany?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
  }

  export type TournamentMatchUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<TournamentMatchCreateWithoutWinnerInput, TournamentMatchUncheckedCreateWithoutWinnerInput> | TournamentMatchCreateWithoutWinnerInput[] | TournamentMatchUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutWinnerInput | TournamentMatchCreateOrConnectWithoutWinnerInput[]
    upsert?: TournamentMatchUpsertWithWhereUniqueWithoutWinnerInput | TournamentMatchUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: TournamentMatchCreateManyWinnerInputEnvelope
    set?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    disconnect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    delete?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    update?: TournamentMatchUpdateWithWhereUniqueWithoutWinnerInput | TournamentMatchUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: TournamentMatchUpdateManyWithWhereWithoutWinnerInput | TournamentMatchUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
  }

  export type TournamentUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TournamentCreateWithoutUsersInput, TournamentUncheckedCreateWithoutUsersInput> | TournamentCreateWithoutUsersInput[] | TournamentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutUsersInput | TournamentCreateOrConnectWithoutUsersInput[]
    upsert?: TournamentUpsertWithWhereUniqueWithoutUsersInput | TournamentUpsertWithWhereUniqueWithoutUsersInput[]
    set?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    disconnect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    delete?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    update?: TournamentUpdateWithWhereUniqueWithoutUsersInput | TournamentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TournamentUpdateManyWithWhereWithoutUsersInput | TournamentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
  }

  export type TournamentUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<TournamentCreateWithoutWinnerInput, TournamentUncheckedCreateWithoutWinnerInput> | TournamentCreateWithoutWinnerInput[] | TournamentUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutWinnerInput | TournamentCreateOrConnectWithoutWinnerInput[]
    upsert?: TournamentUpsertWithWhereUniqueWithoutWinnerInput | TournamentUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: TournamentCreateManyWinnerInputEnvelope
    set?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    disconnect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    delete?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    update?: TournamentUpdateWithWhereUniqueWithoutWinnerInput | TournamentUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: TournamentUpdateManyWithWhereWithoutWinnerInput | TournamentUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
  }

  export type TournamentMatchUncheckedUpdateManyWithoutPlayer1NestedInput = {
    create?: XOR<TournamentMatchCreateWithoutPlayer1Input, TournamentMatchUncheckedCreateWithoutPlayer1Input> | TournamentMatchCreateWithoutPlayer1Input[] | TournamentMatchUncheckedCreateWithoutPlayer1Input[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutPlayer1Input | TournamentMatchCreateOrConnectWithoutPlayer1Input[]
    upsert?: TournamentMatchUpsertWithWhereUniqueWithoutPlayer1Input | TournamentMatchUpsertWithWhereUniqueWithoutPlayer1Input[]
    createMany?: TournamentMatchCreateManyPlayer1InputEnvelope
    set?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    disconnect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    delete?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    update?: TournamentMatchUpdateWithWhereUniqueWithoutPlayer1Input | TournamentMatchUpdateWithWhereUniqueWithoutPlayer1Input[]
    updateMany?: TournamentMatchUpdateManyWithWhereWithoutPlayer1Input | TournamentMatchUpdateManyWithWhereWithoutPlayer1Input[]
    deleteMany?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
  }

  export type TournamentMatchUncheckedUpdateManyWithoutPlayer2NestedInput = {
    create?: XOR<TournamentMatchCreateWithoutPlayer2Input, TournamentMatchUncheckedCreateWithoutPlayer2Input> | TournamentMatchCreateWithoutPlayer2Input[] | TournamentMatchUncheckedCreateWithoutPlayer2Input[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutPlayer2Input | TournamentMatchCreateOrConnectWithoutPlayer2Input[]
    upsert?: TournamentMatchUpsertWithWhereUniqueWithoutPlayer2Input | TournamentMatchUpsertWithWhereUniqueWithoutPlayer2Input[]
    createMany?: TournamentMatchCreateManyPlayer2InputEnvelope
    set?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    disconnect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    delete?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    update?: TournamentMatchUpdateWithWhereUniqueWithoutPlayer2Input | TournamentMatchUpdateWithWhereUniqueWithoutPlayer2Input[]
    updateMany?: TournamentMatchUpdateManyWithWhereWithoutPlayer2Input | TournamentMatchUpdateManyWithWhereWithoutPlayer2Input[]
    deleteMany?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
  }

  export type TournamentMatchUncheckedUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<TournamentMatchCreateWithoutWinnerInput, TournamentMatchUncheckedCreateWithoutWinnerInput> | TournamentMatchCreateWithoutWinnerInput[] | TournamentMatchUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: TournamentMatchCreateOrConnectWithoutWinnerInput | TournamentMatchCreateOrConnectWithoutWinnerInput[]
    upsert?: TournamentMatchUpsertWithWhereUniqueWithoutWinnerInput | TournamentMatchUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: TournamentMatchCreateManyWinnerInputEnvelope
    set?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    disconnect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    delete?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    connect?: TournamentMatchWhereUniqueInput | TournamentMatchWhereUniqueInput[]
    update?: TournamentMatchUpdateWithWhereUniqueWithoutWinnerInput | TournamentMatchUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: TournamentMatchUpdateManyWithWhereWithoutWinnerInput | TournamentMatchUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
  }

  export type TournamentUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<TournamentCreateWithoutUsersInput, TournamentUncheckedCreateWithoutUsersInput> | TournamentCreateWithoutUsersInput[] | TournamentUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutUsersInput | TournamentCreateOrConnectWithoutUsersInput[]
    upsert?: TournamentUpsertWithWhereUniqueWithoutUsersInput | TournamentUpsertWithWhereUniqueWithoutUsersInput[]
    set?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    disconnect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    delete?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    update?: TournamentUpdateWithWhereUniqueWithoutUsersInput | TournamentUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: TournamentUpdateManyWithWhereWithoutUsersInput | TournamentUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
  }

  export type TournamentUncheckedUpdateManyWithoutWinnerNestedInput = {
    create?: XOR<TournamentCreateWithoutWinnerInput, TournamentUncheckedCreateWithoutWinnerInput> | TournamentCreateWithoutWinnerInput[] | TournamentUncheckedCreateWithoutWinnerInput[]
    connectOrCreate?: TournamentCreateOrConnectWithoutWinnerInput | TournamentCreateOrConnectWithoutWinnerInput[]
    upsert?: TournamentUpsertWithWhereUniqueWithoutWinnerInput | TournamentUpsertWithWhereUniqueWithoutWinnerInput[]
    createMany?: TournamentCreateManyWinnerInputEnvelope
    set?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    disconnect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    delete?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    connect?: TournamentWhereUniqueInput | TournamentWhereUniqueInput[]
    update?: TournamentUpdateWithWhereUniqueWithoutWinnerInput | TournamentUpdateWithWhereUniqueWithoutWinnerInput[]
    updateMany?: TournamentUpdateManyWithWhereWithoutWinnerInput | TournamentUpdateManyWithWhereWithoutWinnerInput[]
    deleteMany?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BlockedUserCreateWithoutBlockerInput = {
    BlockedDate: Date | string
    Blocked: UserCreateNestedOneWithoutBlockedInput
  }

  export type BlockedUserUncheckedCreateWithoutBlockerInput = {
    ID?: number
    BlockedID: number
    BlockedDate: Date | string
  }

  export type BlockedUserCreateOrConnectWithoutBlockerInput = {
    where: BlockedUserWhereUniqueInput
    create: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput>
  }

  export type BlockedUserCreateManyBlockerInputEnvelope = {
    data: BlockedUserCreateManyBlockerInput | BlockedUserCreateManyBlockerInput[]
  }

  export type BlockedUserCreateWithoutBlockedInput = {
    BlockedDate: Date | string
    Blocker: UserCreateNestedOneWithoutBlockedByInput
  }

  export type BlockedUserUncheckedCreateWithoutBlockedInput = {
    ID?: number
    BlockerID: number
    BlockedDate: Date | string
  }

  export type BlockedUserCreateOrConnectWithoutBlockedInput = {
    where: BlockedUserWhereUniqueInput
    create: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput>
  }

  export type BlockedUserCreateManyBlockedInputEnvelope = {
    data: BlockedUserCreateManyBlockedInput | BlockedUserCreateManyBlockedInput[]
  }

  export type FriendCreateWithoutUser1Input = {
    DateBefriended: Date | string
    User2: UserCreateNestedOneWithoutFriends2Input
  }

  export type FriendUncheckedCreateWithoutUser1Input = {
    ID?: number
    User2ID: number
    DateBefriended: Date | string
  }

  export type FriendCreateOrConnectWithoutUser1Input = {
    where: FriendWhereUniqueInput
    create: XOR<FriendCreateWithoutUser1Input, FriendUncheckedCreateWithoutUser1Input>
  }

  export type FriendCreateManyUser1InputEnvelope = {
    data: FriendCreateManyUser1Input | FriendCreateManyUser1Input[]
  }

  export type FriendCreateWithoutUser2Input = {
    DateBefriended: Date | string
    User1: UserCreateNestedOneWithoutFriends1Input
  }

  export type FriendUncheckedCreateWithoutUser2Input = {
    ID?: number
    User1ID: number
    DateBefriended: Date | string
  }

  export type FriendCreateOrConnectWithoutUser2Input = {
    where: FriendWhereUniqueInput
    create: XOR<FriendCreateWithoutUser2Input, FriendUncheckedCreateWithoutUser2Input>
  }

  export type FriendCreateManyUser2InputEnvelope = {
    data: FriendCreateManyUser2Input | FriendCreateManyUser2Input[]
  }

  export type InvitationCreateWithoutSenderInput = {
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    Receiver: UserCreateNestedOneWithoutInvitationsReceivedInput
    Match: MatchCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutSenderInput = {
    ID?: number
    ReceiverID: number
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    MatchID: number
  }

  export type InvitationCreateOrConnectWithoutSenderInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutSenderInput, InvitationUncheckedCreateWithoutSenderInput>
  }

  export type InvitationCreateManySenderInputEnvelope = {
    data: InvitationCreateManySenderInput | InvitationCreateManySenderInput[]
  }

  export type InvitationCreateWithoutReceiverInput = {
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    Sender: UserCreateNestedOneWithoutInvitationsSentInput
    Match: MatchCreateNestedOneWithoutInvitationsInput
  }

  export type InvitationUncheckedCreateWithoutReceiverInput = {
    ID?: number
    SenderID: number
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    MatchID: number
  }

  export type InvitationCreateOrConnectWithoutReceiverInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutReceiverInput, InvitationUncheckedCreateWithoutReceiverInput>
  }

  export type InvitationCreateManyReceiverInputEnvelope = {
    data: InvitationCreateManyReceiverInput | InvitationCreateManyReceiverInput[]
  }

  export type MatchCreateWithoutPlayer1Input = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Player2: UserCreateNestedOneWithoutMatchesAsPlayer2Input
    Winner?: UserCreateNestedOneWithoutMatchesAsWinnerInput
    Invitations?: InvitationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutPlayer1Input = {
    ID?: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
    Invitations?: InvitationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutPlayer1Input = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutPlayer1Input, MatchUncheckedCreateWithoutPlayer1Input>
  }

  export type MatchCreateManyPlayer1InputEnvelope = {
    data: MatchCreateManyPlayer1Input | MatchCreateManyPlayer1Input[]
  }

  export type MatchCreateWithoutPlayer2Input = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Player1: UserCreateNestedOneWithoutMatchesAsPlayer1Input
    Winner?: UserCreateNestedOneWithoutMatchesAsWinnerInput
    Invitations?: InvitationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutPlayer2Input = {
    ID?: number
    Player1ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
    Invitations?: InvitationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutPlayer2Input = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutPlayer2Input, MatchUncheckedCreateWithoutPlayer2Input>
  }

  export type MatchCreateManyPlayer2InputEnvelope = {
    data: MatchCreateManyPlayer2Input | MatchCreateManyPlayer2Input[]
  }

  export type MatchCreateWithoutWinnerInput = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Player1: UserCreateNestedOneWithoutMatchesAsPlayer1Input
    Player2: UserCreateNestedOneWithoutMatchesAsPlayer2Input
    Invitations?: InvitationCreateNestedManyWithoutMatchInput
  }

  export type MatchUncheckedCreateWithoutWinnerInput = {
    ID?: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Invitations?: InvitationUncheckedCreateNestedManyWithoutMatchInput
  }

  export type MatchCreateOrConnectWithoutWinnerInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutWinnerInput, MatchUncheckedCreateWithoutWinnerInput>
  }

  export type MatchCreateManyWinnerInputEnvelope = {
    data: MatchCreateManyWinnerInput | MatchCreateManyWinnerInput[]
  }

  export type MessageCreateWithoutSenderInput = {
    Message: string
    DateTime: Date | string
    IsRead: boolean
    Receiver: UserCreateNestedOneWithoutMessagesReceivedInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    ID?: number
    ReceiverID: number
    Message: string
    DateTime: Date | string
    IsRead: boolean
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
  }

  export type MessageCreateWithoutReceiverInput = {
    Message: string
    DateTime: Date | string
    IsRead: boolean
    Sender: UserCreateNestedOneWithoutMessagesSentInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    ID?: number
    SenderID: number
    Message: string
    DateTime: Date | string
    IsRead: boolean
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
  }

  export type TournamentUserCreateWithoutUserInput = {
    Alias: string
    Tournament: TournamentCreateNestedOneWithoutTournamentUsersInput
    matchesAsPlayer1?: TournamentMatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserUncheckedCreateWithoutUserInput = {
    ID?: number
    Alias: string
    TournamentID: number
    matchesAsPlayer1?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchUncheckedCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserCreateOrConnectWithoutUserInput = {
    where: TournamentUserWhereUniqueInput
    create: XOR<TournamentUserCreateWithoutUserInput, TournamentUserUncheckedCreateWithoutUserInput>
  }

  export type TournamentUserCreateManyUserInputEnvelope = {
    data: TournamentUserCreateManyUserInput | TournamentUserCreateManyUserInput[]
  }

  export type BlockedUserUpsertWithWhereUniqueWithoutBlockerInput = {
    where: BlockedUserWhereUniqueInput
    update: XOR<BlockedUserUpdateWithoutBlockerInput, BlockedUserUncheckedUpdateWithoutBlockerInput>
    create: XOR<BlockedUserCreateWithoutBlockerInput, BlockedUserUncheckedCreateWithoutBlockerInput>
  }

  export type BlockedUserUpdateWithWhereUniqueWithoutBlockerInput = {
    where: BlockedUserWhereUniqueInput
    data: XOR<BlockedUserUpdateWithoutBlockerInput, BlockedUserUncheckedUpdateWithoutBlockerInput>
  }

  export type BlockedUserUpdateManyWithWhereWithoutBlockerInput = {
    where: BlockedUserScalarWhereInput
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyWithoutBlockerInput>
  }

  export type BlockedUserScalarWhereInput = {
    AND?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
    OR?: BlockedUserScalarWhereInput[]
    NOT?: BlockedUserScalarWhereInput | BlockedUserScalarWhereInput[]
    ID?: IntFilter<"BlockedUser"> | number
    BlockerID?: IntFilter<"BlockedUser"> | number
    BlockedID?: IntFilter<"BlockedUser"> | number
    BlockedDate?: DateTimeFilter<"BlockedUser"> | Date | string
  }

  export type BlockedUserUpsertWithWhereUniqueWithoutBlockedInput = {
    where: BlockedUserWhereUniqueInput
    update: XOR<BlockedUserUpdateWithoutBlockedInput, BlockedUserUncheckedUpdateWithoutBlockedInput>
    create: XOR<BlockedUserCreateWithoutBlockedInput, BlockedUserUncheckedCreateWithoutBlockedInput>
  }

  export type BlockedUserUpdateWithWhereUniqueWithoutBlockedInput = {
    where: BlockedUserWhereUniqueInput
    data: XOR<BlockedUserUpdateWithoutBlockedInput, BlockedUserUncheckedUpdateWithoutBlockedInput>
  }

  export type BlockedUserUpdateManyWithWhereWithoutBlockedInput = {
    where: BlockedUserScalarWhereInput
    data: XOR<BlockedUserUpdateManyMutationInput, BlockedUserUncheckedUpdateManyWithoutBlockedInput>
  }

  export type FriendUpsertWithWhereUniqueWithoutUser1Input = {
    where: FriendWhereUniqueInput
    update: XOR<FriendUpdateWithoutUser1Input, FriendUncheckedUpdateWithoutUser1Input>
    create: XOR<FriendCreateWithoutUser1Input, FriendUncheckedCreateWithoutUser1Input>
  }

  export type FriendUpdateWithWhereUniqueWithoutUser1Input = {
    where: FriendWhereUniqueInput
    data: XOR<FriendUpdateWithoutUser1Input, FriendUncheckedUpdateWithoutUser1Input>
  }

  export type FriendUpdateManyWithWhereWithoutUser1Input = {
    where: FriendScalarWhereInput
    data: XOR<FriendUpdateManyMutationInput, FriendUncheckedUpdateManyWithoutUser1Input>
  }

  export type FriendScalarWhereInput = {
    AND?: FriendScalarWhereInput | FriendScalarWhereInput[]
    OR?: FriendScalarWhereInput[]
    NOT?: FriendScalarWhereInput | FriendScalarWhereInput[]
    ID?: IntFilter<"Friend"> | number
    User1ID?: IntFilter<"Friend"> | number
    User2ID?: IntFilter<"Friend"> | number
    DateBefriended?: DateTimeFilter<"Friend"> | Date | string
  }

  export type FriendUpsertWithWhereUniqueWithoutUser2Input = {
    where: FriendWhereUniqueInput
    update: XOR<FriendUpdateWithoutUser2Input, FriendUncheckedUpdateWithoutUser2Input>
    create: XOR<FriendCreateWithoutUser2Input, FriendUncheckedCreateWithoutUser2Input>
  }

  export type FriendUpdateWithWhereUniqueWithoutUser2Input = {
    where: FriendWhereUniqueInput
    data: XOR<FriendUpdateWithoutUser2Input, FriendUncheckedUpdateWithoutUser2Input>
  }

  export type FriendUpdateManyWithWhereWithoutUser2Input = {
    where: FriendScalarWhereInput
    data: XOR<FriendUpdateManyMutationInput, FriendUncheckedUpdateManyWithoutUser2Input>
  }

  export type InvitationUpsertWithWhereUniqueWithoutSenderInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutSenderInput, InvitationUncheckedUpdateWithoutSenderInput>
    create: XOR<InvitationCreateWithoutSenderInput, InvitationUncheckedCreateWithoutSenderInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutSenderInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutSenderInput, InvitationUncheckedUpdateWithoutSenderInput>
  }

  export type InvitationUpdateManyWithWhereWithoutSenderInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutSenderInput>
  }

  export type InvitationScalarWhereInput = {
    AND?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    OR?: InvitationScalarWhereInput[]
    NOT?: InvitationScalarWhereInput | InvitationScalarWhereInput[]
    ID?: IntFilter<"Invitation"> | number
    SenderID?: IntFilter<"Invitation"> | number
    ReceiverID?: IntFilter<"Invitation"> | number
    Status?: IntFilter<"Invitation"> | number
    SentAt?: DateTimeFilter<"Invitation"> | Date | string
    RespondedAt?: DateTimeNullableFilter<"Invitation"> | Date | string | null
    MatchID?: IntFilter<"Invitation"> | number
  }

  export type InvitationUpsertWithWhereUniqueWithoutReceiverInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutReceiverInput, InvitationUncheckedUpdateWithoutReceiverInput>
    create: XOR<InvitationCreateWithoutReceiverInput, InvitationUncheckedCreateWithoutReceiverInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutReceiverInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutReceiverInput, InvitationUncheckedUpdateWithoutReceiverInput>
  }

  export type InvitationUpdateManyWithWhereWithoutReceiverInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutReceiverInput>
  }

  export type MatchUpsertWithWhereUniqueWithoutPlayer1Input = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutPlayer1Input, MatchUncheckedUpdateWithoutPlayer1Input>
    create: XOR<MatchCreateWithoutPlayer1Input, MatchUncheckedCreateWithoutPlayer1Input>
  }

  export type MatchUpdateWithWhereUniqueWithoutPlayer1Input = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutPlayer1Input, MatchUncheckedUpdateWithoutPlayer1Input>
  }

  export type MatchUpdateManyWithWhereWithoutPlayer1Input = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutPlayer1Input>
  }

  export type MatchScalarWhereInput = {
    AND?: MatchScalarWhereInput | MatchScalarWhereInput[]
    OR?: MatchScalarWhereInput[]
    NOT?: MatchScalarWhereInput | MatchScalarWhereInput[]
    ID?: IntFilter<"Match"> | number
    Player1ID?: IntFilter<"Match"> | number
    Player2ID?: IntFilter<"Match"> | number
    Player1Score?: IntFilter<"Match"> | number
    Player2Score?: IntFilter<"Match"> | number
    CreationDate?: DateTimeFilter<"Match"> | Date | string
    WinnerID?: IntNullableFilter<"Match"> | number | null
  }

  export type MatchUpsertWithWhereUniqueWithoutPlayer2Input = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutPlayer2Input, MatchUncheckedUpdateWithoutPlayer2Input>
    create: XOR<MatchCreateWithoutPlayer2Input, MatchUncheckedCreateWithoutPlayer2Input>
  }

  export type MatchUpdateWithWhereUniqueWithoutPlayer2Input = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutPlayer2Input, MatchUncheckedUpdateWithoutPlayer2Input>
  }

  export type MatchUpdateManyWithWhereWithoutPlayer2Input = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutPlayer2Input>
  }

  export type MatchUpsertWithWhereUniqueWithoutWinnerInput = {
    where: MatchWhereUniqueInput
    update: XOR<MatchUpdateWithoutWinnerInput, MatchUncheckedUpdateWithoutWinnerInput>
    create: XOR<MatchCreateWithoutWinnerInput, MatchUncheckedCreateWithoutWinnerInput>
  }

  export type MatchUpdateWithWhereUniqueWithoutWinnerInput = {
    where: MatchWhereUniqueInput
    data: XOR<MatchUpdateWithoutWinnerInput, MatchUncheckedUpdateWithoutWinnerInput>
  }

  export type MatchUpdateManyWithWhereWithoutWinnerInput = {
    where: MatchScalarWhereInput
    data: XOR<MatchUpdateManyMutationInput, MatchUncheckedUpdateManyWithoutWinnerInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    ID?: IntFilter<"Message"> | number
    SenderID?: IntFilter<"Message"> | number
    ReceiverID?: IntFilter<"Message"> | number
    Message?: StringFilter<"Message"> | string
    DateTime?: DateTimeFilter<"Message"> | Date | string
    IsRead?: BoolFilter<"Message"> | boolean
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type TournamentUserUpsertWithWhereUniqueWithoutUserInput = {
    where: TournamentUserWhereUniqueInput
    update: XOR<TournamentUserUpdateWithoutUserInput, TournamentUserUncheckedUpdateWithoutUserInput>
    create: XOR<TournamentUserCreateWithoutUserInput, TournamentUserUncheckedCreateWithoutUserInput>
  }

  export type TournamentUserUpdateWithWhereUniqueWithoutUserInput = {
    where: TournamentUserWhereUniqueInput
    data: XOR<TournamentUserUpdateWithoutUserInput, TournamentUserUncheckedUpdateWithoutUserInput>
  }

  export type TournamentUserUpdateManyWithWhereWithoutUserInput = {
    where: TournamentUserScalarWhereInput
    data: XOR<TournamentUserUpdateManyMutationInput, TournamentUserUncheckedUpdateManyWithoutUserInput>
  }

  export type TournamentUserScalarWhereInput = {
    AND?: TournamentUserScalarWhereInput | TournamentUserScalarWhereInput[]
    OR?: TournamentUserScalarWhereInput[]
    NOT?: TournamentUserScalarWhereInput | TournamentUserScalarWhereInput[]
    ID?: IntFilter<"TournamentUser"> | number
    Alias?: StringFilter<"TournamentUser"> | string
    UserID?: IntFilter<"TournamentUser"> | number
    TournamentID?: IntFilter<"TournamentUser"> | number
  }

  export type UserCreateWithoutBlockedByInput = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlockedByInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlockedByInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
  }

  export type UserCreateWithoutBlockedInput = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBlockedInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBlockedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBlockedInput, UserUncheckedCreateWithoutBlockedInput>
  }

  export type UserUpsertWithoutBlockedByInput = {
    update: XOR<UserUpdateWithoutBlockedByInput, UserUncheckedUpdateWithoutBlockedByInput>
    create: XOR<UserCreateWithoutBlockedByInput, UserUncheckedCreateWithoutBlockedByInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedByInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedByInput, UserUncheckedUpdateWithoutBlockedByInput>
  }

  export type UserUpdateWithoutBlockedByInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedByInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutBlockedInput = {
    update: XOR<UserUpdateWithoutBlockedInput, UserUncheckedUpdateWithoutBlockedInput>
    create: XOR<UserCreateWithoutBlockedInput, UserUncheckedCreateWithoutBlockedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBlockedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBlockedInput, UserUncheckedUpdateWithoutBlockedInput>
  }

  export type UserUpdateWithoutBlockedInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBlockedInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFriends1Input = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriends1Input = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriends1Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriends1Input, UserUncheckedCreateWithoutFriends1Input>
  }

  export type UserCreateWithoutFriends2Input = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFriends2Input = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFriends2Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFriends2Input, UserUncheckedCreateWithoutFriends2Input>
  }

  export type UserUpsertWithoutFriends1Input = {
    update: XOR<UserUpdateWithoutFriends1Input, UserUncheckedUpdateWithoutFriends1Input>
    create: XOR<UserCreateWithoutFriends1Input, UserUncheckedCreateWithoutFriends1Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriends1Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriends1Input, UserUncheckedUpdateWithoutFriends1Input>
  }

  export type UserUpdateWithoutFriends1Input = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriends1Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFriends2Input = {
    update: XOR<UserUpdateWithoutFriends2Input, UserUncheckedUpdateWithoutFriends2Input>
    create: XOR<UserCreateWithoutFriends2Input, UserUncheckedCreateWithoutFriends2Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFriends2Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFriends2Input, UserUncheckedUpdateWithoutFriends2Input>
  }

  export type UserUpdateWithoutFriends2Input = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFriends2Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInvitationsSentInput = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsSentInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
  }

  export type UserCreateWithoutInvitationsReceivedInput = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsReceivedInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsReceivedInput, UserUncheckedCreateWithoutInvitationsReceivedInput>
  }

  export type MatchCreateWithoutInvitationsInput = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Player1: UserCreateNestedOneWithoutMatchesAsPlayer1Input
    Player2: UserCreateNestedOneWithoutMatchesAsPlayer2Input
    Winner?: UserCreateNestedOneWithoutMatchesAsWinnerInput
  }

  export type MatchUncheckedCreateWithoutInvitationsInput = {
    ID?: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type MatchCreateOrConnectWithoutInvitationsInput = {
    where: MatchWhereUniqueInput
    create: XOR<MatchCreateWithoutInvitationsInput, MatchUncheckedCreateWithoutInvitationsInput>
  }

  export type UserUpsertWithoutInvitationsSentInput = {
    update: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
    create: XOR<UserCreateWithoutInvitationsSentInput, UserUncheckedCreateWithoutInvitationsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsSentInput, UserUncheckedUpdateWithoutInvitationsSentInput>
  }

  export type UserUpdateWithoutInvitationsSentInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsSentInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutInvitationsReceivedInput = {
    update: XOR<UserUpdateWithoutInvitationsReceivedInput, UserUncheckedUpdateWithoutInvitationsReceivedInput>
    create: XOR<UserCreateWithoutInvitationsReceivedInput, UserUncheckedCreateWithoutInvitationsReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsReceivedInput, UserUncheckedUpdateWithoutInvitationsReceivedInput>
  }

  export type UserUpdateWithoutInvitationsReceivedInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsReceivedInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MatchUpsertWithoutInvitationsInput = {
    update: XOR<MatchUpdateWithoutInvitationsInput, MatchUncheckedUpdateWithoutInvitationsInput>
    create: XOR<MatchCreateWithoutInvitationsInput, MatchUncheckedCreateWithoutInvitationsInput>
    where?: MatchWhereInput
  }

  export type MatchUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: MatchWhereInput
    data: XOR<MatchUpdateWithoutInvitationsInput, MatchUncheckedUpdateWithoutInvitationsInput>
  }

  export type MatchUpdateWithoutInvitationsInput = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Player1?: UserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput
    Player2?: UserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput
    Winner?: UserUpdateOneWithoutMatchesAsWinnerNestedInput
  }

  export type MatchUncheckedUpdateWithoutInvitationsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UserCreateWithoutMatchesAsPlayer1Input = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchesAsPlayer1Input = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchesAsPlayer1Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchesAsPlayer1Input, UserUncheckedCreateWithoutMatchesAsPlayer1Input>
  }

  export type UserCreateWithoutMatchesAsPlayer2Input = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchesAsPlayer2Input = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchesAsPlayer2Input = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchesAsPlayer2Input, UserUncheckedCreateWithoutMatchesAsPlayer2Input>
  }

  export type UserCreateWithoutMatchesAsWinnerInput = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMatchesAsWinnerInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMatchesAsWinnerInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMatchesAsWinnerInput, UserUncheckedCreateWithoutMatchesAsWinnerInput>
  }

  export type InvitationCreateWithoutMatchInput = {
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    Sender: UserCreateNestedOneWithoutInvitationsSentInput
    Receiver: UserCreateNestedOneWithoutInvitationsReceivedInput
  }

  export type InvitationUncheckedCreateWithoutMatchInput = {
    ID?: number
    SenderID: number
    ReceiverID: number
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
  }

  export type InvitationCreateOrConnectWithoutMatchInput = {
    where: InvitationWhereUniqueInput
    create: XOR<InvitationCreateWithoutMatchInput, InvitationUncheckedCreateWithoutMatchInput>
  }

  export type InvitationCreateManyMatchInputEnvelope = {
    data: InvitationCreateManyMatchInput | InvitationCreateManyMatchInput[]
  }

  export type UserUpsertWithoutMatchesAsPlayer1Input = {
    update: XOR<UserUpdateWithoutMatchesAsPlayer1Input, UserUncheckedUpdateWithoutMatchesAsPlayer1Input>
    create: XOR<UserCreateWithoutMatchesAsPlayer1Input, UserUncheckedCreateWithoutMatchesAsPlayer1Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchesAsPlayer1Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchesAsPlayer1Input, UserUncheckedUpdateWithoutMatchesAsPlayer1Input>
  }

  export type UserUpdateWithoutMatchesAsPlayer1Input = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchesAsPlayer1Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMatchesAsPlayer2Input = {
    update: XOR<UserUpdateWithoutMatchesAsPlayer2Input, UserUncheckedUpdateWithoutMatchesAsPlayer2Input>
    create: XOR<UserCreateWithoutMatchesAsPlayer2Input, UserUncheckedCreateWithoutMatchesAsPlayer2Input>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchesAsPlayer2Input = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchesAsPlayer2Input, UserUncheckedUpdateWithoutMatchesAsPlayer2Input>
  }

  export type UserUpdateWithoutMatchesAsPlayer2Input = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchesAsPlayer2Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMatchesAsWinnerInput = {
    update: XOR<UserUpdateWithoutMatchesAsWinnerInput, UserUncheckedUpdateWithoutMatchesAsWinnerInput>
    create: XOR<UserCreateWithoutMatchesAsWinnerInput, UserUncheckedCreateWithoutMatchesAsWinnerInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMatchesAsWinnerInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMatchesAsWinnerInput, UserUncheckedUpdateWithoutMatchesAsWinnerInput>
  }

  export type UserUpdateWithoutMatchesAsWinnerInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMatchesAsWinnerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InvitationUpsertWithWhereUniqueWithoutMatchInput = {
    where: InvitationWhereUniqueInput
    update: XOR<InvitationUpdateWithoutMatchInput, InvitationUncheckedUpdateWithoutMatchInput>
    create: XOR<InvitationCreateWithoutMatchInput, InvitationUncheckedCreateWithoutMatchInput>
  }

  export type InvitationUpdateWithWhereUniqueWithoutMatchInput = {
    where: InvitationWhereUniqueInput
    data: XOR<InvitationUpdateWithoutMatchInput, InvitationUncheckedUpdateWithoutMatchInput>
  }

  export type InvitationUpdateManyWithWhereWithoutMatchInput = {
    where: InvitationScalarWhereInput
    data: XOR<InvitationUpdateManyMutationInput, InvitationUncheckedUpdateManyWithoutMatchInput>
  }

  export type UserCreateWithoutMessagesSentInput = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesSentInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
  }

  export type UserCreateWithoutMessagesReceivedInput = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMessagesReceivedInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMessagesReceivedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
  }

  export type UserUpsertWithoutMessagesSentInput = {
    update: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
    create: XOR<UserCreateWithoutMessagesSentInput, UserUncheckedCreateWithoutMessagesSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesSentInput, UserUncheckedUpdateWithoutMessagesSentInput>
  }

  export type UserUpdateWithoutMessagesSentInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesSentInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMessagesReceivedInput = {
    update: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
    create: XOR<UserCreateWithoutMessagesReceivedInput, UserUncheckedCreateWithoutMessagesReceivedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesReceivedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesReceivedInput, UserUncheckedUpdateWithoutMessagesReceivedInput>
  }

  export type UserUpdateWithoutMessagesReceivedInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesReceivedInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TournamentUserCreateWithoutTournamentsAsWinnerInput = {
    Alias: string
    User: UserCreateNestedOneWithoutTournamentUsersInput
    Tournament: TournamentCreateNestedOneWithoutTournamentUsersInput
    matchesAsPlayer1?: TournamentMatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentCreateNestedManyWithoutUsersInput
  }

  export type TournamentUserUncheckedCreateWithoutTournamentsAsWinnerInput = {
    ID?: number
    Alias: string
    UserID: number
    TournamentID: number
    matchesAsPlayer1?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchUncheckedCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutUsersInput
  }

  export type TournamentUserCreateOrConnectWithoutTournamentsAsWinnerInput = {
    where: TournamentUserWhereUniqueInput
    create: XOR<TournamentUserCreateWithoutTournamentsAsWinnerInput, TournamentUserUncheckedCreateWithoutTournamentsAsWinnerInput>
  }

  export type TournamentMatchCreateWithoutTournamentInput = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Player1: TournamentUserCreateNestedOneWithoutMatchesAsPlayer1Input
    Player2: TournamentUserCreateNestedOneWithoutMatchesAsPlayer2Input
    Winner?: TournamentUserCreateNestedOneWithoutMatchesAsWinnerInput
  }

  export type TournamentMatchUncheckedCreateWithoutTournamentInput = {
    ID?: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type TournamentMatchCreateOrConnectWithoutTournamentInput = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchCreateWithoutTournamentInput, TournamentMatchUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentMatchCreateManyTournamentInputEnvelope = {
    data: TournamentMatchCreateManyTournamentInput | TournamentMatchCreateManyTournamentInput[]
  }

  export type TournamentUserCreateWithoutTournamentsInput = {
    Alias: string
    User: UserCreateNestedOneWithoutTournamentUsersInput
    Tournament: TournamentCreateNestedOneWithoutTournamentUsersInput
    matchesAsPlayer1?: TournamentMatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchCreateNestedManyWithoutWinnerInput
    tournamentsAsWinner?: TournamentCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserUncheckedCreateWithoutTournamentsInput = {
    ID?: number
    Alias: string
    UserID: number
    TournamentID: number
    matchesAsPlayer1?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchUncheckedCreateNestedManyWithoutWinnerInput
    tournamentsAsWinner?: TournamentUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserCreateOrConnectWithoutTournamentsInput = {
    where: TournamentUserWhereUniqueInput
    create: XOR<TournamentUserCreateWithoutTournamentsInput, TournamentUserUncheckedCreateWithoutTournamentsInput>
  }

  export type TournamentUserCreateWithoutTournamentInput = {
    Alias: string
    User: UserCreateNestedOneWithoutTournamentUsersInput
    matchesAsPlayer1?: TournamentMatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserUncheckedCreateWithoutTournamentInput = {
    ID?: number
    Alias: string
    UserID: number
    matchesAsPlayer1?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchUncheckedCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserCreateOrConnectWithoutTournamentInput = {
    where: TournamentUserWhereUniqueInput
    create: XOR<TournamentUserCreateWithoutTournamentInput, TournamentUserUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentUserCreateManyTournamentInputEnvelope = {
    data: TournamentUserCreateManyTournamentInput | TournamentUserCreateManyTournamentInput[]
  }

  export type TournamentUserUpsertWithoutTournamentsAsWinnerInput = {
    update: XOR<TournamentUserUpdateWithoutTournamentsAsWinnerInput, TournamentUserUncheckedUpdateWithoutTournamentsAsWinnerInput>
    create: XOR<TournamentUserCreateWithoutTournamentsAsWinnerInput, TournamentUserUncheckedCreateWithoutTournamentsAsWinnerInput>
    where?: TournamentUserWhereInput
  }

  export type TournamentUserUpdateToOneWithWhereWithoutTournamentsAsWinnerInput = {
    where?: TournamentUserWhereInput
    data: XOR<TournamentUserUpdateWithoutTournamentsAsWinnerInput, TournamentUserUncheckedUpdateWithoutTournamentsAsWinnerInput>
  }

  export type TournamentUserUpdateWithoutTournamentsAsWinnerInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutTournamentUsersNestedInput
    Tournament?: TournamentUpdateOneRequiredWithoutTournamentUsersNestedInput
    matchesAsPlayer1?: TournamentMatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUpdateManyWithoutUsersNestedInput
  }

  export type TournamentUserUncheckedUpdateWithoutTournamentsAsWinnerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    matchesAsPlayer1?: TournamentMatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUncheckedUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type TournamentMatchUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentMatchWhereUniqueInput
    update: XOR<TournamentMatchUpdateWithoutTournamentInput, TournamentMatchUncheckedUpdateWithoutTournamentInput>
    create: XOR<TournamentMatchCreateWithoutTournamentInput, TournamentMatchUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentMatchUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentMatchWhereUniqueInput
    data: XOR<TournamentMatchUpdateWithoutTournamentInput, TournamentMatchUncheckedUpdateWithoutTournamentInput>
  }

  export type TournamentMatchUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentMatchScalarWhereInput
    data: XOR<TournamentMatchUpdateManyMutationInput, TournamentMatchUncheckedUpdateManyWithoutTournamentInput>
  }

  export type TournamentMatchScalarWhereInput = {
    AND?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
    OR?: TournamentMatchScalarWhereInput[]
    NOT?: TournamentMatchScalarWhereInput | TournamentMatchScalarWhereInput[]
    ID?: IntFilter<"TournamentMatch"> | number
    TournamentID?: IntFilter<"TournamentMatch"> | number
    Player1ID?: IntFilter<"TournamentMatch"> | number
    Player2ID?: IntFilter<"TournamentMatch"> | number
    Player1Score?: IntFilter<"TournamentMatch"> | number
    Player2Score?: IntFilter<"TournamentMatch"> | number
    CreationDate?: DateTimeFilter<"TournamentMatch"> | Date | string
    WinnerID?: IntNullableFilter<"TournamentMatch"> | number | null
  }

  export type TournamentUserUpsertWithWhereUniqueWithoutTournamentsInput = {
    where: TournamentUserWhereUniqueInput
    update: XOR<TournamentUserUpdateWithoutTournamentsInput, TournamentUserUncheckedUpdateWithoutTournamentsInput>
    create: XOR<TournamentUserCreateWithoutTournamentsInput, TournamentUserUncheckedCreateWithoutTournamentsInput>
  }

  export type TournamentUserUpdateWithWhereUniqueWithoutTournamentsInput = {
    where: TournamentUserWhereUniqueInput
    data: XOR<TournamentUserUpdateWithoutTournamentsInput, TournamentUserUncheckedUpdateWithoutTournamentsInput>
  }

  export type TournamentUserUpdateManyWithWhereWithoutTournamentsInput = {
    where: TournamentUserScalarWhereInput
    data: XOR<TournamentUserUpdateManyMutationInput, TournamentUserUncheckedUpdateManyWithoutTournamentsInput>
  }

  export type TournamentUserUpsertWithWhereUniqueWithoutTournamentInput = {
    where: TournamentUserWhereUniqueInput
    update: XOR<TournamentUserUpdateWithoutTournamentInput, TournamentUserUncheckedUpdateWithoutTournamentInput>
    create: XOR<TournamentUserCreateWithoutTournamentInput, TournamentUserUncheckedCreateWithoutTournamentInput>
  }

  export type TournamentUserUpdateWithWhereUniqueWithoutTournamentInput = {
    where: TournamentUserWhereUniqueInput
    data: XOR<TournamentUserUpdateWithoutTournamentInput, TournamentUserUncheckedUpdateWithoutTournamentInput>
  }

  export type TournamentUserUpdateManyWithWhereWithoutTournamentInput = {
    where: TournamentUserScalarWhereInput
    data: XOR<TournamentUserUpdateManyMutationInput, TournamentUserUncheckedUpdateManyWithoutTournamentInput>
  }

  export type TournamentCreateWithoutMatchesInput = {
    Name: string
    CreationDate: Date | string
    Winner?: TournamentUserCreateNestedOneWithoutTournamentsAsWinnerInput
    Users?: TournamentUserCreateNestedManyWithoutTournamentsInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutMatchesInput = {
    ID?: number
    Name: string
    CreationDate: Date | string
    WinnerID?: number | null
    Users?: TournamentUserUncheckedCreateNestedManyWithoutTournamentsInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutMatchesInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutMatchesInput, TournamentUncheckedCreateWithoutMatchesInput>
  }

  export type TournamentUserCreateWithoutMatchesAsPlayer1Input = {
    Alias: string
    User: UserCreateNestedOneWithoutTournamentUsersInput
    Tournament: TournamentCreateNestedOneWithoutTournamentUsersInput
    matchesAsPlayer2?: TournamentMatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserUncheckedCreateWithoutMatchesAsPlayer1Input = {
    ID?: number
    Alias: string
    UserID: number
    TournamentID: number
    matchesAsPlayer2?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: TournamentMatchUncheckedCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserCreateOrConnectWithoutMatchesAsPlayer1Input = {
    where: TournamentUserWhereUniqueInput
    create: XOR<TournamentUserCreateWithoutMatchesAsPlayer1Input, TournamentUserUncheckedCreateWithoutMatchesAsPlayer1Input>
  }

  export type TournamentUserCreateWithoutMatchesAsPlayer2Input = {
    Alias: string
    User: UserCreateNestedOneWithoutTournamentUsersInput
    Tournament: TournamentCreateNestedOneWithoutTournamentUsersInput
    matchesAsPlayer1?: TournamentMatchCreateNestedManyWithoutPlayer1Input
    matchesAsWinner?: TournamentMatchCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserUncheckedCreateWithoutMatchesAsPlayer2Input = {
    ID?: number
    Alias: string
    UserID: number
    TournamentID: number
    matchesAsPlayer1?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsWinner?: TournamentMatchUncheckedCreateNestedManyWithoutWinnerInput
    tournaments?: TournamentUncheckedCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserCreateOrConnectWithoutMatchesAsPlayer2Input = {
    where: TournamentUserWhereUniqueInput
    create: XOR<TournamentUserCreateWithoutMatchesAsPlayer2Input, TournamentUserUncheckedCreateWithoutMatchesAsPlayer2Input>
  }

  export type TournamentUserCreateWithoutMatchesAsWinnerInput = {
    Alias: string
    User: UserCreateNestedOneWithoutTournamentUsersInput
    Tournament: TournamentCreateNestedOneWithoutTournamentUsersInput
    matchesAsPlayer1?: TournamentMatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchCreateNestedManyWithoutPlayer2Input
    tournaments?: TournamentCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserUncheckedCreateWithoutMatchesAsWinnerInput = {
    ID?: number
    Alias: string
    UserID: number
    TournamentID: number
    matchesAsPlayer1?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: TournamentMatchUncheckedCreateNestedManyWithoutPlayer2Input
    tournaments?: TournamentUncheckedCreateNestedManyWithoutUsersInput
    tournamentsAsWinner?: TournamentUncheckedCreateNestedManyWithoutWinnerInput
  }

  export type TournamentUserCreateOrConnectWithoutMatchesAsWinnerInput = {
    where: TournamentUserWhereUniqueInput
    create: XOR<TournamentUserCreateWithoutMatchesAsWinnerInput, TournamentUserUncheckedCreateWithoutMatchesAsWinnerInput>
  }

  export type TournamentUpsertWithoutMatchesInput = {
    update: XOR<TournamentUpdateWithoutMatchesInput, TournamentUncheckedUpdateWithoutMatchesInput>
    create: XOR<TournamentCreateWithoutMatchesInput, TournamentUncheckedCreateWithoutMatchesInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutMatchesInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutMatchesInput, TournamentUncheckedUpdateWithoutMatchesInput>
  }

  export type TournamentUpdateWithoutMatchesInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Winner?: TournamentUserUpdateOneWithoutTournamentsAsWinnerNestedInput
    Users?: TournamentUserUpdateManyWithoutTournamentsNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutMatchesInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
    Users?: TournamentUserUncheckedUpdateManyWithoutTournamentsNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUserUpsertWithoutMatchesAsPlayer1Input = {
    update: XOR<TournamentUserUpdateWithoutMatchesAsPlayer1Input, TournamentUserUncheckedUpdateWithoutMatchesAsPlayer1Input>
    create: XOR<TournamentUserCreateWithoutMatchesAsPlayer1Input, TournamentUserUncheckedCreateWithoutMatchesAsPlayer1Input>
    where?: TournamentUserWhereInput
  }

  export type TournamentUserUpdateToOneWithWhereWithoutMatchesAsPlayer1Input = {
    where?: TournamentUserWhereInput
    data: XOR<TournamentUserUpdateWithoutMatchesAsPlayer1Input, TournamentUserUncheckedUpdateWithoutMatchesAsPlayer1Input>
  }

  export type TournamentUserUpdateWithoutMatchesAsPlayer1Input = {
    Alias?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutTournamentUsersNestedInput
    Tournament?: TournamentUpdateOneRequiredWithoutTournamentUsersNestedInput
    matchesAsPlayer2?: TournamentMatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateWithoutMatchesAsPlayer1Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    matchesAsPlayer2?: TournamentMatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUncheckedUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUpsertWithoutMatchesAsPlayer2Input = {
    update: XOR<TournamentUserUpdateWithoutMatchesAsPlayer2Input, TournamentUserUncheckedUpdateWithoutMatchesAsPlayer2Input>
    create: XOR<TournamentUserCreateWithoutMatchesAsPlayer2Input, TournamentUserUncheckedCreateWithoutMatchesAsPlayer2Input>
    where?: TournamentUserWhereInput
  }

  export type TournamentUserUpdateToOneWithWhereWithoutMatchesAsPlayer2Input = {
    where?: TournamentUserWhereInput
    data: XOR<TournamentUserUpdateWithoutMatchesAsPlayer2Input, TournamentUserUncheckedUpdateWithoutMatchesAsPlayer2Input>
  }

  export type TournamentUserUpdateWithoutMatchesAsPlayer2Input = {
    Alias?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutTournamentUsersNestedInput
    Tournament?: TournamentUpdateOneRequiredWithoutTournamentUsersNestedInput
    matchesAsPlayer1?: TournamentMatchUpdateManyWithoutPlayer1NestedInput
    matchesAsWinner?: TournamentMatchUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateWithoutMatchesAsPlayer2Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    matchesAsPlayer1?: TournamentMatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsWinner?: TournamentMatchUncheckedUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUpsertWithoutMatchesAsWinnerInput = {
    update: XOR<TournamentUserUpdateWithoutMatchesAsWinnerInput, TournamentUserUncheckedUpdateWithoutMatchesAsWinnerInput>
    create: XOR<TournamentUserCreateWithoutMatchesAsWinnerInput, TournamentUserUncheckedCreateWithoutMatchesAsWinnerInput>
    where?: TournamentUserWhereInput
  }

  export type TournamentUserUpdateToOneWithWhereWithoutMatchesAsWinnerInput = {
    where?: TournamentUserWhereInput
    data: XOR<TournamentUserUpdateWithoutMatchesAsWinnerInput, TournamentUserUncheckedUpdateWithoutMatchesAsWinnerInput>
  }

  export type TournamentUserUpdateWithoutMatchesAsWinnerInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutTournamentUsersNestedInput
    Tournament?: TournamentUpdateOneRequiredWithoutTournamentUsersNestedInput
    matchesAsPlayer1?: TournamentMatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUpdateManyWithoutPlayer2NestedInput
    tournaments?: TournamentUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateWithoutMatchesAsWinnerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    matchesAsPlayer1?: TournamentMatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUncheckedUpdateManyWithoutPlayer2NestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type UserCreateWithoutTournamentUsersInput = {
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserCreateNestedManyWithoutBlockedInput
    Friends1?: FriendCreateNestedManyWithoutUser1Input
    Friends2?: FriendCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutTournamentUsersInput = {
    ID?: number
    Alias: string
    Email: string
    Password: string
    Online: boolean
    CreationDate: Date | string
    GamesWon?: number
    ProfilePicture?: Bytes | null
    BlockedBy?: BlockedUserUncheckedCreateNestedManyWithoutBlockerInput
    Blocked?: BlockedUserUncheckedCreateNestedManyWithoutBlockedInput
    Friends1?: FriendUncheckedCreateNestedManyWithoutUser1Input
    Friends2?: FriendUncheckedCreateNestedManyWithoutUser2Input
    InvitationsSent?: InvitationUncheckedCreateNestedManyWithoutSenderInput
    InvitationsReceived?: InvitationUncheckedCreateNestedManyWithoutReceiverInput
    matchesAsPlayer1?: MatchUncheckedCreateNestedManyWithoutPlayer1Input
    matchesAsPlayer2?: MatchUncheckedCreateNestedManyWithoutPlayer2Input
    matchesAsWinner?: MatchUncheckedCreateNestedManyWithoutWinnerInput
    MessagesSent?: MessageUncheckedCreateNestedManyWithoutSenderInput
    MessagesReceived?: MessageUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutTournamentUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTournamentUsersInput, UserUncheckedCreateWithoutTournamentUsersInput>
  }

  export type TournamentCreateWithoutTournamentUsersInput = {
    Name: string
    CreationDate: Date | string
    Winner?: TournamentUserCreateNestedOneWithoutTournamentsAsWinnerInput
    Matches?: TournamentMatchCreateNestedManyWithoutTournamentInput
    Users?: TournamentUserCreateNestedManyWithoutTournamentsInput
  }

  export type TournamentUncheckedCreateWithoutTournamentUsersInput = {
    ID?: number
    Name: string
    CreationDate: Date | string
    WinnerID?: number | null
    Matches?: TournamentMatchUncheckedCreateNestedManyWithoutTournamentInput
    Users?: TournamentUserUncheckedCreateNestedManyWithoutTournamentsInput
  }

  export type TournamentCreateOrConnectWithoutTournamentUsersInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutTournamentUsersInput, TournamentUncheckedCreateWithoutTournamentUsersInput>
  }

  export type TournamentMatchCreateWithoutPlayer1Input = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Tournament: TournamentCreateNestedOneWithoutMatchesInput
    Player2: TournamentUserCreateNestedOneWithoutMatchesAsPlayer2Input
    Winner?: TournamentUserCreateNestedOneWithoutMatchesAsWinnerInput
  }

  export type TournamentMatchUncheckedCreateWithoutPlayer1Input = {
    ID?: number
    TournamentID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type TournamentMatchCreateOrConnectWithoutPlayer1Input = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchCreateWithoutPlayer1Input, TournamentMatchUncheckedCreateWithoutPlayer1Input>
  }

  export type TournamentMatchCreateManyPlayer1InputEnvelope = {
    data: TournamentMatchCreateManyPlayer1Input | TournamentMatchCreateManyPlayer1Input[]
  }

  export type TournamentMatchCreateWithoutPlayer2Input = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Tournament: TournamentCreateNestedOneWithoutMatchesInput
    Player1: TournamentUserCreateNestedOneWithoutMatchesAsPlayer1Input
    Winner?: TournamentUserCreateNestedOneWithoutMatchesAsWinnerInput
  }

  export type TournamentMatchUncheckedCreateWithoutPlayer2Input = {
    ID?: number
    TournamentID: number
    Player1ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type TournamentMatchCreateOrConnectWithoutPlayer2Input = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchCreateWithoutPlayer2Input, TournamentMatchUncheckedCreateWithoutPlayer2Input>
  }

  export type TournamentMatchCreateManyPlayer2InputEnvelope = {
    data: TournamentMatchCreateManyPlayer2Input | TournamentMatchCreateManyPlayer2Input[]
  }

  export type TournamentMatchCreateWithoutWinnerInput = {
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    Tournament: TournamentCreateNestedOneWithoutMatchesInput
    Player1: TournamentUserCreateNestedOneWithoutMatchesAsPlayer1Input
    Player2: TournamentUserCreateNestedOneWithoutMatchesAsPlayer2Input
  }

  export type TournamentMatchUncheckedCreateWithoutWinnerInput = {
    ID?: number
    TournamentID: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
  }

  export type TournamentMatchCreateOrConnectWithoutWinnerInput = {
    where: TournamentMatchWhereUniqueInput
    create: XOR<TournamentMatchCreateWithoutWinnerInput, TournamentMatchUncheckedCreateWithoutWinnerInput>
  }

  export type TournamentMatchCreateManyWinnerInputEnvelope = {
    data: TournamentMatchCreateManyWinnerInput | TournamentMatchCreateManyWinnerInput[]
  }

  export type TournamentCreateWithoutUsersInput = {
    Name: string
    CreationDate: Date | string
    Winner?: TournamentUserCreateNestedOneWithoutTournamentsAsWinnerInput
    Matches?: TournamentMatchCreateNestedManyWithoutTournamentInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutUsersInput = {
    ID?: number
    Name: string
    CreationDate: Date | string
    WinnerID?: number | null
    Matches?: TournamentMatchUncheckedCreateNestedManyWithoutTournamentInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutUsersInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutUsersInput, TournamentUncheckedCreateWithoutUsersInput>
  }

  export type TournamentCreateWithoutWinnerInput = {
    Name: string
    CreationDate: Date | string
    Matches?: TournamentMatchCreateNestedManyWithoutTournamentInput
    Users?: TournamentUserCreateNestedManyWithoutTournamentsInput
    TournamentUsers?: TournamentUserCreateNestedManyWithoutTournamentInput
  }

  export type TournamentUncheckedCreateWithoutWinnerInput = {
    ID?: number
    Name: string
    CreationDate: Date | string
    Matches?: TournamentMatchUncheckedCreateNestedManyWithoutTournamentInput
    Users?: TournamentUserUncheckedCreateNestedManyWithoutTournamentsInput
    TournamentUsers?: TournamentUserUncheckedCreateNestedManyWithoutTournamentInput
  }

  export type TournamentCreateOrConnectWithoutWinnerInput = {
    where: TournamentWhereUniqueInput
    create: XOR<TournamentCreateWithoutWinnerInput, TournamentUncheckedCreateWithoutWinnerInput>
  }

  export type TournamentCreateManyWinnerInputEnvelope = {
    data: TournamentCreateManyWinnerInput | TournamentCreateManyWinnerInput[]
  }

  export type UserUpsertWithoutTournamentUsersInput = {
    update: XOR<UserUpdateWithoutTournamentUsersInput, UserUncheckedUpdateWithoutTournamentUsersInput>
    create: XOR<UserCreateWithoutTournamentUsersInput, UserUncheckedCreateWithoutTournamentUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTournamentUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTournamentUsersInput, UserUncheckedUpdateWithoutTournamentUsersInput>
  }

  export type UserUpdateWithoutTournamentUsersInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutTournamentUsersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    Email?: StringFieldUpdateOperationsInput | string
    Password?: StringFieldUpdateOperationsInput | string
    Online?: BoolFieldUpdateOperationsInput | boolean
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    GamesWon?: IntFieldUpdateOperationsInput | number
    ProfilePicture?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    BlockedBy?: BlockedUserUncheckedUpdateManyWithoutBlockerNestedInput
    Blocked?: BlockedUserUncheckedUpdateManyWithoutBlockedNestedInput
    Friends1?: FriendUncheckedUpdateManyWithoutUser1NestedInput
    Friends2?: FriendUncheckedUpdateManyWithoutUser2NestedInput
    InvitationsSent?: InvitationUncheckedUpdateManyWithoutSenderNestedInput
    InvitationsReceived?: InvitationUncheckedUpdateManyWithoutReceiverNestedInput
    matchesAsPlayer1?: MatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: MatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: MatchUncheckedUpdateManyWithoutWinnerNestedInput
    MessagesSent?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    MessagesReceived?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type TournamentUpsertWithoutTournamentUsersInput = {
    update: XOR<TournamentUpdateWithoutTournamentUsersInput, TournamentUncheckedUpdateWithoutTournamentUsersInput>
    create: XOR<TournamentCreateWithoutTournamentUsersInput, TournamentUncheckedCreateWithoutTournamentUsersInput>
    where?: TournamentWhereInput
  }

  export type TournamentUpdateToOneWithWhereWithoutTournamentUsersInput = {
    where?: TournamentWhereInput
    data: XOR<TournamentUpdateWithoutTournamentUsersInput, TournamentUncheckedUpdateWithoutTournamentUsersInput>
  }

  export type TournamentUpdateWithoutTournamentUsersInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Winner?: TournamentUserUpdateOneWithoutTournamentsAsWinnerNestedInput
    Matches?: TournamentMatchUpdateManyWithoutTournamentNestedInput
    Users?: TournamentUserUpdateManyWithoutTournamentsNestedInput
  }

  export type TournamentUncheckedUpdateWithoutTournamentUsersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
    Matches?: TournamentMatchUncheckedUpdateManyWithoutTournamentNestedInput
    Users?: TournamentUserUncheckedUpdateManyWithoutTournamentsNestedInput
  }

  export type TournamentMatchUpsertWithWhereUniqueWithoutPlayer1Input = {
    where: TournamentMatchWhereUniqueInput
    update: XOR<TournamentMatchUpdateWithoutPlayer1Input, TournamentMatchUncheckedUpdateWithoutPlayer1Input>
    create: XOR<TournamentMatchCreateWithoutPlayer1Input, TournamentMatchUncheckedCreateWithoutPlayer1Input>
  }

  export type TournamentMatchUpdateWithWhereUniqueWithoutPlayer1Input = {
    where: TournamentMatchWhereUniqueInput
    data: XOR<TournamentMatchUpdateWithoutPlayer1Input, TournamentMatchUncheckedUpdateWithoutPlayer1Input>
  }

  export type TournamentMatchUpdateManyWithWhereWithoutPlayer1Input = {
    where: TournamentMatchScalarWhereInput
    data: XOR<TournamentMatchUpdateManyMutationInput, TournamentMatchUncheckedUpdateManyWithoutPlayer1Input>
  }

  export type TournamentMatchUpsertWithWhereUniqueWithoutPlayer2Input = {
    where: TournamentMatchWhereUniqueInput
    update: XOR<TournamentMatchUpdateWithoutPlayer2Input, TournamentMatchUncheckedUpdateWithoutPlayer2Input>
    create: XOR<TournamentMatchCreateWithoutPlayer2Input, TournamentMatchUncheckedCreateWithoutPlayer2Input>
  }

  export type TournamentMatchUpdateWithWhereUniqueWithoutPlayer2Input = {
    where: TournamentMatchWhereUniqueInput
    data: XOR<TournamentMatchUpdateWithoutPlayer2Input, TournamentMatchUncheckedUpdateWithoutPlayer2Input>
  }

  export type TournamentMatchUpdateManyWithWhereWithoutPlayer2Input = {
    where: TournamentMatchScalarWhereInput
    data: XOR<TournamentMatchUpdateManyMutationInput, TournamentMatchUncheckedUpdateManyWithoutPlayer2Input>
  }

  export type TournamentMatchUpsertWithWhereUniqueWithoutWinnerInput = {
    where: TournamentMatchWhereUniqueInput
    update: XOR<TournamentMatchUpdateWithoutWinnerInput, TournamentMatchUncheckedUpdateWithoutWinnerInput>
    create: XOR<TournamentMatchCreateWithoutWinnerInput, TournamentMatchUncheckedCreateWithoutWinnerInput>
  }

  export type TournamentMatchUpdateWithWhereUniqueWithoutWinnerInput = {
    where: TournamentMatchWhereUniqueInput
    data: XOR<TournamentMatchUpdateWithoutWinnerInput, TournamentMatchUncheckedUpdateWithoutWinnerInput>
  }

  export type TournamentMatchUpdateManyWithWhereWithoutWinnerInput = {
    where: TournamentMatchScalarWhereInput
    data: XOR<TournamentMatchUpdateManyMutationInput, TournamentMatchUncheckedUpdateManyWithoutWinnerInput>
  }

  export type TournamentUpsertWithWhereUniqueWithoutUsersInput = {
    where: TournamentWhereUniqueInput
    update: XOR<TournamentUpdateWithoutUsersInput, TournamentUncheckedUpdateWithoutUsersInput>
    create: XOR<TournamentCreateWithoutUsersInput, TournamentUncheckedCreateWithoutUsersInput>
  }

  export type TournamentUpdateWithWhereUniqueWithoutUsersInput = {
    where: TournamentWhereUniqueInput
    data: XOR<TournamentUpdateWithoutUsersInput, TournamentUncheckedUpdateWithoutUsersInput>
  }

  export type TournamentUpdateManyWithWhereWithoutUsersInput = {
    where: TournamentScalarWhereInput
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyWithoutUsersInput>
  }

  export type TournamentScalarWhereInput = {
    AND?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
    OR?: TournamentScalarWhereInput[]
    NOT?: TournamentScalarWhereInput | TournamentScalarWhereInput[]
    ID?: IntFilter<"Tournament"> | number
    Name?: StringFilter<"Tournament"> | string
    CreationDate?: DateTimeFilter<"Tournament"> | Date | string
    WinnerID?: IntNullableFilter<"Tournament"> | number | null
  }

  export type TournamentUpsertWithWhereUniqueWithoutWinnerInput = {
    where: TournamentWhereUniqueInput
    update: XOR<TournamentUpdateWithoutWinnerInput, TournamentUncheckedUpdateWithoutWinnerInput>
    create: XOR<TournamentCreateWithoutWinnerInput, TournamentUncheckedCreateWithoutWinnerInput>
  }

  export type TournamentUpdateWithWhereUniqueWithoutWinnerInput = {
    where: TournamentWhereUniqueInput
    data: XOR<TournamentUpdateWithoutWinnerInput, TournamentUncheckedUpdateWithoutWinnerInput>
  }

  export type TournamentUpdateManyWithWhereWithoutWinnerInput = {
    where: TournamentScalarWhereInput
    data: XOR<TournamentUpdateManyMutationInput, TournamentUncheckedUpdateManyWithoutWinnerInput>
  }

  export type BlockedUserCreateManyBlockerInput = {
    ID?: number
    BlockedID: number
    BlockedDate: Date | string
  }

  export type BlockedUserCreateManyBlockedInput = {
    ID?: number
    BlockerID: number
    BlockedDate: Date | string
  }

  export type FriendCreateManyUser1Input = {
    ID?: number
    User2ID: number
    DateBefriended: Date | string
  }

  export type FriendCreateManyUser2Input = {
    ID?: number
    User1ID: number
    DateBefriended: Date | string
  }

  export type InvitationCreateManySenderInput = {
    ID?: number
    ReceiverID: number
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    MatchID: number
  }

  export type InvitationCreateManyReceiverInput = {
    ID?: number
    SenderID: number
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
    MatchID: number
  }

  export type MatchCreateManyPlayer1Input = {
    ID?: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type MatchCreateManyPlayer2Input = {
    ID?: number
    Player1ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type MatchCreateManyWinnerInput = {
    ID?: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
  }

  export type MessageCreateManySenderInput = {
    ID?: number
    ReceiverID: number
    Message: string
    DateTime: Date | string
    IsRead: boolean
  }

  export type MessageCreateManyReceiverInput = {
    ID?: number
    SenderID: number
    Message: string
    DateTime: Date | string
    IsRead: boolean
  }

  export type TournamentUserCreateManyUserInput = {
    ID?: number
    Alias: string
    TournamentID: number
  }

  export type BlockedUserUpdateWithoutBlockerInput = {
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Blocked?: UserUpdateOneRequiredWithoutBlockedNestedInput
  }

  export type BlockedUserUncheckedUpdateWithoutBlockerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    BlockedID?: IntFieldUpdateOperationsInput | number
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    BlockedID?: IntFieldUpdateOperationsInput | number
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUpdateWithoutBlockedInput = {
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Blocker?: UserUpdateOneRequiredWithoutBlockedByNestedInput
  }

  export type BlockedUserUncheckedUpdateWithoutBlockedInput = {
    ID?: IntFieldUpdateOperationsInput | number
    BlockerID?: IntFieldUpdateOperationsInput | number
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlockedUserUncheckedUpdateManyWithoutBlockedInput = {
    ID?: IntFieldUpdateOperationsInput | number
    BlockerID?: IntFieldUpdateOperationsInput | number
    BlockedDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendUpdateWithoutUser1Input = {
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
    User2?: UserUpdateOneRequiredWithoutFriends2NestedInput
  }

  export type FriendUncheckedUpdateWithoutUser1Input = {
    ID?: IntFieldUpdateOperationsInput | number
    User2ID?: IntFieldUpdateOperationsInput | number
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendUncheckedUpdateManyWithoutUser1Input = {
    ID?: IntFieldUpdateOperationsInput | number
    User2ID?: IntFieldUpdateOperationsInput | number
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendUpdateWithoutUser2Input = {
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
    User1?: UserUpdateOneRequiredWithoutFriends1NestedInput
  }

  export type FriendUncheckedUpdateWithoutUser2Input = {
    ID?: IntFieldUpdateOperationsInput | number
    User1ID?: IntFieldUpdateOperationsInput | number
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FriendUncheckedUpdateManyWithoutUser2Input = {
    ID?: IntFieldUpdateOperationsInput | number
    User1ID?: IntFieldUpdateOperationsInput | number
    DateBefriended?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvitationUpdateWithoutSenderInput = {
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Receiver?: UserUpdateOneRequiredWithoutInvitationsReceivedNestedInput
    Match?: MatchUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutSenderInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MatchID?: IntFieldUpdateOperationsInput | number
  }

  export type InvitationUncheckedUpdateManyWithoutSenderInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MatchID?: IntFieldUpdateOperationsInput | number
  }

  export type InvitationUpdateWithoutReceiverInput = {
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sender?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
    Match?: MatchUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type InvitationUncheckedUpdateWithoutReceiverInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MatchID?: IntFieldUpdateOperationsInput | number
  }

  export type InvitationUncheckedUpdateManyWithoutReceiverInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    MatchID?: IntFieldUpdateOperationsInput | number
  }

  export type MatchUpdateWithoutPlayer1Input = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Player2?: UserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput
    Winner?: UserUpdateOneWithoutMatchesAsWinnerNestedInput
    Invitations?: InvitationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutPlayer1Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
    Invitations?: InvitationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutPlayer1Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MatchUpdateWithoutPlayer2Input = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Player1?: UserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput
    Winner?: UserUpdateOneWithoutMatchesAsWinnerNestedInput
    Invitations?: InvitationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutPlayer2Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
    Invitations?: InvitationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutPlayer2Input = {
    ID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MatchUpdateWithoutWinnerInput = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Player1?: UserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput
    Player2?: UserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput
    Invitations?: InvitationUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateWithoutWinnerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Invitations?: InvitationUncheckedUpdateManyWithoutMatchNestedInput
  }

  export type MatchUncheckedUpdateManyWithoutWinnerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
    Receiver?: UserUpdateOneRequiredWithoutMessagesReceivedNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    ID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUpdateWithoutReceiverInput = {
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
    Sender?: UserUpdateOneRequiredWithoutMessagesSentNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    Message?: StringFieldUpdateOperationsInput | string
    DateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    IsRead?: BoolFieldUpdateOperationsInput | boolean
  }

  export type TournamentUserUpdateWithoutUserInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    Tournament?: TournamentUpdateOneRequiredWithoutTournamentUsersNestedInput
    matchesAsPlayer1?: TournamentMatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateWithoutUserInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    TournamentID?: IntFieldUpdateOperationsInput | number
    matchesAsPlayer1?: TournamentMatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUncheckedUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateManyWithoutUserInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    TournamentID?: IntFieldUpdateOperationsInput | number
  }

  export type InvitationCreateManyMatchInput = {
    ID?: number
    SenderID: number
    ReceiverID: number
    Status: number
    SentAt: Date | string
    RespondedAt?: Date | string | null
  }

  export type InvitationUpdateWithoutMatchInput = {
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Sender?: UserUpdateOneRequiredWithoutInvitationsSentNestedInput
    Receiver?: UserUpdateOneRequiredWithoutInvitationsReceivedNestedInput
  }

  export type InvitationUncheckedUpdateWithoutMatchInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InvitationUncheckedUpdateManyWithoutMatchInput = {
    ID?: IntFieldUpdateOperationsInput | number
    SenderID?: IntFieldUpdateOperationsInput | number
    ReceiverID?: IntFieldUpdateOperationsInput | number
    Status?: IntFieldUpdateOperationsInput | number
    SentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    RespondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TournamentMatchCreateManyTournamentInput = {
    ID?: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type TournamentUserCreateManyTournamentInput = {
    ID?: number
    Alias: string
    UserID: number
  }

  export type TournamentMatchUpdateWithoutTournamentInput = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Player1?: TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput
    Player2?: TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput
    Winner?: TournamentUserUpdateOneWithoutMatchesAsWinnerNestedInput
  }

  export type TournamentMatchUncheckedUpdateWithoutTournamentInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentMatchUncheckedUpdateManyWithoutTournamentInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentUserUpdateWithoutTournamentsInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutTournamentUsersNestedInput
    Tournament?: TournamentUpdateOneRequiredWithoutTournamentUsersNestedInput
    matchesAsPlayer1?: TournamentMatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUpdateManyWithoutWinnerNestedInput
    tournamentsAsWinner?: TournamentUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateWithoutTournamentsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    matchesAsPlayer1?: TournamentMatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUncheckedUpdateManyWithoutWinnerNestedInput
    tournamentsAsWinner?: TournamentUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateManyWithoutTournamentsInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
  }

  export type TournamentUserUpdateWithoutTournamentInput = {
    Alias?: StringFieldUpdateOperationsInput | string
    User?: UserUpdateOneRequiredWithoutTournamentUsersNestedInput
    matchesAsPlayer1?: TournamentMatchUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateWithoutTournamentInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
    matchesAsPlayer1?: TournamentMatchUncheckedUpdateManyWithoutPlayer1NestedInput
    matchesAsPlayer2?: TournamentMatchUncheckedUpdateManyWithoutPlayer2NestedInput
    matchesAsWinner?: TournamentMatchUncheckedUpdateManyWithoutWinnerNestedInput
    tournaments?: TournamentUncheckedUpdateManyWithoutUsersNestedInput
    tournamentsAsWinner?: TournamentUncheckedUpdateManyWithoutWinnerNestedInput
  }

  export type TournamentUserUncheckedUpdateManyWithoutTournamentInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Alias?: StringFieldUpdateOperationsInput | string
    UserID?: IntFieldUpdateOperationsInput | number
  }

  export type TournamentMatchCreateManyPlayer1Input = {
    ID?: number
    TournamentID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type TournamentMatchCreateManyPlayer2Input = {
    ID?: number
    TournamentID: number
    Player1ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
    WinnerID?: number | null
  }

  export type TournamentMatchCreateManyWinnerInput = {
    ID?: number
    TournamentID: number
    Player1ID: number
    Player2ID: number
    Player1Score: number
    Player2Score: number
    CreationDate: Date | string
  }

  export type TournamentCreateManyWinnerInput = {
    ID?: number
    Name: string
    CreationDate: Date | string
  }

  export type TournamentMatchUpdateWithoutPlayer1Input = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Tournament?: TournamentUpdateOneRequiredWithoutMatchesNestedInput
    Player2?: TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput
    Winner?: TournamentUserUpdateOneWithoutMatchesAsWinnerNestedInput
  }

  export type TournamentMatchUncheckedUpdateWithoutPlayer1Input = {
    ID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentMatchUncheckedUpdateManyWithoutPlayer1Input = {
    ID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentMatchUpdateWithoutPlayer2Input = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Tournament?: TournamentUpdateOneRequiredWithoutMatchesNestedInput
    Player1?: TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput
    Winner?: TournamentUserUpdateOneWithoutMatchesAsWinnerNestedInput
  }

  export type TournamentMatchUncheckedUpdateWithoutPlayer2Input = {
    ID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentMatchUncheckedUpdateManyWithoutPlayer2Input = {
    ID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentMatchUpdateWithoutWinnerInput = {
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Tournament?: TournamentUpdateOneRequiredWithoutMatchesNestedInput
    Player1?: TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer1NestedInput
    Player2?: TournamentUserUpdateOneRequiredWithoutMatchesAsPlayer2NestedInput
  }

  export type TournamentMatchUncheckedUpdateWithoutWinnerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentMatchUncheckedUpdateManyWithoutWinnerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    TournamentID?: IntFieldUpdateOperationsInput | number
    Player1ID?: IntFieldUpdateOperationsInput | number
    Player2ID?: IntFieldUpdateOperationsInput | number
    Player1Score?: IntFieldUpdateOperationsInput | number
    Player2Score?: IntFieldUpdateOperationsInput | number
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TournamentUpdateWithoutUsersInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Winner?: TournamentUserUpdateOneWithoutTournamentsAsWinnerNestedInput
    Matches?: TournamentMatchUpdateManyWithoutTournamentNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutUsersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
    Matches?: TournamentMatchUncheckedUpdateManyWithoutTournamentNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateManyWithoutUsersInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    WinnerID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TournamentUpdateWithoutWinnerInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Matches?: TournamentMatchUpdateManyWithoutTournamentNestedInput
    Users?: TournamentUserUpdateManyWithoutTournamentsNestedInput
    TournamentUsers?: TournamentUserUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateWithoutWinnerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    Matches?: TournamentMatchUncheckedUpdateManyWithoutTournamentNestedInput
    Users?: TournamentUserUncheckedUpdateManyWithoutTournamentsNestedInput
    TournamentUsers?: TournamentUserUncheckedUpdateManyWithoutTournamentNestedInput
  }

  export type TournamentUncheckedUpdateManyWithoutWinnerInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreationDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}